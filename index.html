<!DOCTYPE html> 
<html lang="pt-BR"> 
<head> 
    <meta charset="UTF-8"> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <title>Dashboard SUAD</title> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script> 
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css"> 
    <style> 
        :root {
            --primary: #4361ee;
            --primary-light: #4895ef;
            --secondary: #4cc9f0;
            --accent: #7209b7;
            --success: #2ecc71;
            --warning: #f39c12;
            --danger: #e74c3c;
            --dark: #2b2d42;
            --dark-light: #3d405b;
            --light: #f8f9fa;
            --gray: #e5e5e5;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --transition: all 0.3s ease;
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
            --spacing-xl: 2rem;
            --border-radius: 0.5rem;
            --border-radius-lg: 1rem;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: var(--font-family);
        }

        body {
            background-color: #f5f7fa;
            color: #333;
            overflow-x: hidden;
            line-height: 1.6;
        }

        .dashboard {
            display: grid;
            grid-template-columns: 250px 1fr;
            min-height: 100vh;
        }

        .sidebar {
            background: linear-gradient(180deg, var(--dark) 0%, var(--dark-light) 100%);
            color: white;
            padding: var(--spacing-md);
            position: fixed;
            width: 250px;
            height: 100vh;
            overflow-y: auto;
            transition: var(--transition);
            z-index: 100;
            box-shadow: var(--shadow);
        }

        .logo {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-lg) 0;
            margin-bottom: var(--spacing-xl);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .logo h1 {
            font-size: 1.5rem;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .menu {
            list-style: none;
            margin-top: var(--spacing-lg);
        }

        .menu-item {
            padding: var(--spacing-md) var(--spacing-lg);
            border-radius: var(--border-radius);
            margin-bottom: var(--spacing-sm);
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
        }

        .menu-item:hover, .menu-item.active {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        .menu-item i {
            margin-right: var(--spacing-md);
            font-size: 1.125rem;
            width: 24px;
            text-align: center;
        }

        .menu-item span {
            font-weight: 500;
        }

        .main-content {
            grid-column: 2;
            padding: var(--spacing-xl);
            transition: var(--transition);
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-xl);
            padding-bottom: var(--spacing-lg);
            border-bottom: 1px solid var(--gray);
        }

        .header h2 {
            font-size: 1.5rem;
            color: var(--dark);
            font-weight: 700;
        }

        .file-input-container {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-container input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }

        .btn {
            padding: 0.75rem 1.25rem;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 600;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow);
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-light);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-success:hover {
            background: #27ae60;
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        
        .btn-warning {
            background: var(--warning);
            color: white;
        }
        
        .btn-warning:hover {
            background: #e67e22;
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .btn i {
            margin-right: 0.5rem;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: var(--spacing-lg);
            margin-bottom: var(--spacing-xl);
        }

        .card {
            background: white;
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow);
            padding: var(--spacing-lg);
            transition: var(--transition);
            height: 100%;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-lg);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-lg);
            color: var(--dark);
        }

        .card-title {
            font-size: 1.125rem;
            font-weight: 600;
        }

        .card-value {
            font-size: 1.75rem;
            font-weight: 700;
            margin: var(--spacing-md) 0;
            color: var(--primary);
        }

        .card-text {
            color: #7f8c8d;
            font-size: 0.875rem;
        }

        .chart-container {
            height: 300px;
            margin-top: var(--spacing-md);
            position: relative;
        }

        .data-grid {
            width: 100%;
            overflow-x: auto;
            margin-top: var(--spacing-xl);
            background: white;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
        }

        .data-grid table {
            width: 100%;
            border-collapse: collapse;
            text-align: left;
        }

        .data-grid th {
            background: var(--dark);
            color: white;
            padding: 0.75rem 1rem;
            font-weight: 600;
            position: sticky;
            top: 0;
        }

        .data-grid td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--gray);
        }

        .data-grid tr:last-child td {
            border-bottom: none;
        }

        .data-grid tr:hover {
            background: #f8f9fa;
        }

        .filter-container {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            background: white;
            padding: var(--spacing-lg);
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow);
        }

        .filter-group {
            flex: 1;
            min-width: 200px;
        }

        .filter-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            font-size: 0.875rem;
            color: var(--dark);
        }

        .filter-select, .filter-input {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid var(--gray);
            border-radius: var(--border-radius);
            font-size: 0.875rem;
            transition: var(--transition);
        }

        .filter-select:focus, .filter-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.2);
        }

        .badge {
            padding: 0.35rem 0.75rem;
            border-radius: 50rem;
            font-size: 0.75rem;
            font-weight: 600;
            display: inline-block;
        }

        .badge-success {
            background: #d5f5e3;
            color: #27ae60;
        }

        .badge-warning {
            background: #fef9e7;
            color: #f39c12;
        }

        .badge-danger {
            background: #fadbd8;
            color: #e74c3c;
        }

        .pagination {
            display: flex;
            justify-content: center;
            margin-top: var(--spacing-lg);
            gap: 0.5rem;
        }

        .page-btn {
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--gray);
            background: white;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: var(--transition);
            min-width: 40px;
            text-align: center;
        }

        .page-btn:hover, .page-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .page-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .loader {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: var(--spacing-md);
        }

        .loader.active {
            display: flex;
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border-left-color: var(--primary);
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .tab-container {
            margin-bottom: var(--spacing-xl);
        }

        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: var(--spacing-lg);
            overflow-x: auto;
            padding-bottom: 0.25rem;
        }

        .tab {
            padding: 0.75rem 1.25rem;
            background: white;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 600;
            transition: var(--transition);
            box-shadow: var(--shadow);
            white-space: nowrap;
        }

        .tab:hover, .tab.active {
            background: var(--primary);
            color: white;
        }

        .tab-content {
            background: white;
            border-radius: var(--border-radius-lg);
            padding: var(--spacing-lg);
            box-shadow: var(--shadow);
            min-height: 400px;
        }

        .tab-pane {
            display: none;
        }

        .tab-pane.active {
            display: block;
        }

        .message {
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
            margin-bottom: var(--spacing-lg);
            display: none;
        }

        .message.active {
            display: block;
        }

        .error-message {
            background: #fadbd8;
            color: #c0392b;
            border-left: 4px solid #e74c3c;
        }

        .success-message {
            background: #d5f5e3;
            color: #27ae60;
            border-left: 4px solid #2ecc71;
        }

        .info-message {
            background: #ebf5fb;
            color: #2980b9;
            border-left: 4px solid #3498db;
        }

        .toggle-sidebar {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: var(--primary);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1000;
            box-shadow: var(--shadow);
            transition: var(--transition);
            display: none;
        }

        .toggle-sidebar:hover {
            transform: scale(1.1);
        }

        .sidebar-collapsed .sidebar {
            transform: translateX(-250px);
        }

        .sidebar-collapsed .main-content {
            grid-column: 1 / -1;
            margin-left: 0;
        }

        .summary-box {
            background: white;
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
            box-shadow: var(--shadow);
        }

        .summary-box h4 {
            font-size: 1rem;
            margin-bottom: 0.5rem;
            color: var(--dark);
        }

        .summary-box p {
            font-size: 0.875rem;
            color: #7f8c8d;
        }

        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-xl);
            text-align: center;
        }

        .empty-state i {
            font-size: 3rem;
            color: var(--gray);
            margin-bottom: var(--spacing-md);
        }

        .empty-state h3 {
            font-size: 1.25rem;
            margin-bottom: var(--spacing-md);
            color: var(--dark);
        }

        .empty-state p {
            color: #7f8c8d;
            max-width: 500px;
            margin-bottom: var(--spacing-lg);
        }

        /* Responsivo */
        @media (max-width: 991px) {
            .dashboard {
                grid-template-columns: 1fr;
            }

            .sidebar {
                width: 70px;
                padding: var(--spacing-md) calc(var(--spacing-md) / 2);
            }

            .logo h1, .menu-item span {
                display: none;
            }

            .menu-item {
                justify-content: center;
                padding: var(--spacing-md);
            }

            .menu-item i {
                margin-right: 0;
                font-size: 1.25rem;
            }

            .main-content {
                grid-column: 1;
                margin-left: 70px;
                padding: var(--spacing-lg);
            }

            .toggle-sidebar {
                display: flex;
            }
        }

        @media (max-width: 767px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }

            .header {
                flex-direction: column;
                align-items: flex-start;
                gap: var(--spacing-md);
            }

            .filter-container {
                flex-direction: column;
            }

            .tabs {
                flex-wrap: wrap;
            }

            .main-content {
                padding: var(--spacing-md);
            }
        }

        /* Temas */
        body.dark-theme {
            background-color: #121212;
            color: #e0e0e0;
        }

        body.dark-theme .card,
        body.dark-theme .filter-container,
        body.dark-theme .tab-content,
        body.dark-theme .tab {
            background: #1e1e1e;
            color: #e0e0e0;
        }

        body.dark-theme .card-text {
            color: #9e9e9e;
        }

        body.dark-theme .data-grid td {
            border-bottom: 1px solid #333;
        }

        body.dark-theme .data-grid tr:hover {
            background: #2c2c2c;
        }

        body.dark-theme .filter-select,
        body.dark-theme .filter-input {
            background: #2c2c2c;
            border: 1px solid #444;
            color: #e0e0e0;
        }

        body.dark-theme .page-btn {
            background: #2c2c2c;
            border: 1px solid #444;
            color: #e0e0e0;
        }

        body.blue-theme {
            --primary: #1a73e8;
            --primary-light: #4285f4;
            --dark: #174ea6;
            --dark-light: #1967d2;
        }

        body.green-theme {
            --primary: #0f9d58;
            --primary-light: #34a853;
            --dark: #0b8043;
            --dark-light: #137333;
        }
        
        /* Debug Panel */
        #debugPanel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
            padding: 10px;
            font-size: 12px;
            max-width: 300px;
            display: none;
        }
        
        #debugPanel.active {
            display: block;
        }
        
        #debugPanel h4 {
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        
        #debugContent {
            max-height: 200px;
            overflow-y: auto;
        }
        
        #debugPanel button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            margin-top: 10px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="loader" id="loader"> 
        <div class="spinner"></div> 
        <p>Processando dados...</p> 
    </div>
    <div class="toggle-sidebar" id="toggleSidebar">
        <i class="fas fa-bars"></i>
    </div>

    <div class="dashboard" id="dashboard">
        <div class="sidebar" id="sidebar">
            <div class="logo">
                <h1>SUAD Dashboard</h1>
            </div>
            <ul class="menu">
                <li class="menu-item active" data-section="dashboard">
                    <i class="fas fa-chart-pie"></i>
                    <span>Dashboard</span>
                </li>
                <li class="menu-item" data-section="relatorios">
                    <i class="fas fa-file-alt"></i>
                    <span>Relatórios</span>
                </li>
                <li class="menu-item" data-section="analises">
                    <i class="fas fa-chart-line"></i>
                    <span>Análises</span>
                </li>
                <li class="menu-item" data-section="configuracoes">
                    <i class="fas fa-cog"></i>
                    <span>Configurações</span>
                </li>
            </ul>
        </div>
        
        <div class="main-content">
            <div class="message error-message" id="errorMessage"></div>
            <div class="message success-message" id="successMessage"></div>
            <div class="message info-message" id="infoMessage"></div>
            
            <section id="mainDashboard">
                <div class="header">
                    <h2>Painel de Controle</h2>
                    <div class="file-input-container">
                        <button class="btn btn-primary">
                            <i class="fas fa-upload"></i>Carregar Planilha
                            <input type="file" id="fileInput" accept=".xlsx,.xls,.csv" />
                        </button>
                    </div>
                </div>
                
                <div id="emptyState" class="empty-state">
                    <i class="fas fa-database"></i>
                    <h3>Sem dados para exibir</h3>
                    <p>Carregue uma planilha para visualizar os dados ou clique no botão abaixo para carregar dados de exemplo.</p>
                    <button class="btn btn-primary" id="loadSampleBtn">
                        <i class="fas fa-magic"></i>Carregar Dados de Exemplo
                    </button>
                </div>
                
                <div id="dashboardContent" style="display: none;">
                    <div class="filter-container">
                        <div class="filter-group">
                            <label class="filter-label">Período</label>
                            <select class="filter-select" id="periodoFilter">
                                <option value="todos">Todos</option>
                                <option value="atual">Mês Atual</option>
                                <option value="anterior">Mês Anterior</option>
                                <option value="trimestre">Último Trimestre</option>
                                <option value="anual">Anual</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Departamento</label>
                            <select class="filter-select" id="departamentoFilter">
                                <option value="todos">Todos</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Status</label>
                            <select class="filter-select" id="statusFilter">
                                <option value="todos">Todos</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Busca</label>
                            <input type="text" class="filter-input" id="searchInput" placeholder="Digite para buscar...">
                        </div>
                    </div>
                    
                    <div class="dashboard-grid">
                        <div class="card">
                            <div class="card-header">
                                <div class="card-title">Total de Registros</div>
                                <i class="fas fa-file-alt"></i>
                            </div>
                            <div class="card-value" id="totalRegistros">0</div>
                            <div class="card-text">Registros encontrados na planilha</div>
                        </div>
                        <div class="card">
                            <div class="card-header">
                                <div class="card-title">Média de Valores</div>
                                <i class="fas fa-calculator"></i>
                            </div>
                            <div class="card-value" id="mediaValores">R$ 0,00</div>
                            <div class="card-text">Média de todos os valores registrados</div>
                        </div>
                        <div class="card">
                            <div class="card-header">
                                <div class="card-title">Status</div>
                                <i class="fas fa-tasks"></i>
                            </div>
                            <div class="card-value" id="statusCount">0 / 0</div>
                            <div class="card-text">Completos vs. Pendentes</div>
                        </div>
                        <div class="card">
                            <div class="card-header">
                                <div class="card-title">Última Atualização</div>
                                <i class="fas fa-clock"></i>
                            </div>
                            <div class="card-value" id="ultimaAtualizacao">--/--/----</div>
                            <div class="card-text">Data da última atualização dos dados</div>
                        </div>
                    </div>
                    
                    <div class="tab-container">
                        <div class="tabs">
                            <div class="tab active" data-tab="grafico">Gráficos</div>
                            <div class="tab" data-tab="tabela">Tabela de Dados</div>
                            <div class="tab" data-tab="estatisticas">Estatísticas</div>
                        </div>
                        
                        <div class="tab-content">
                            <div class="tab-pane active" id="grafico">
                                <div class="chart-container">
                                    <canvas id="mainChart"></canvas>
                                </div>
                                <div class="chart-container">
                                    <canvas id="secondaryChart"></canvas>
                                </div>
                            </div>
                            
                            <div class="tab-pane" id="tabela">
                                <div class="data-grid">
                                    <table id="dataTable">
                                        <thead>
                                            <tr id="tableHeaders">
                                                <th>ID</th>
                                                <th>Data</th>
                                                <th>Departamento</th>
                                                <th>Valor</th>
                                                <th>Status</th>
                                            </tr>
                                        </thead>
                                        <tbody id="tableBody">
                                            <!-- Dados serão inseridos aqui -->
                                        </tbody>
                                    </table>
                                </div>
                                <div class="pagination" id="pagination">
                                    <!-- Botões de paginação serão inseridos aqui -->
                                </div>
                            </div>
                            
                            <div class="tab-pane" id="estatisticas">
                                <div class="dashboard-grid">
                                    <div class="card">
                                        <div class="card-header">
                                            <div class="card-title">Distribuição por Departamento</div>
                                        </div>
                                        <div class="chart-container">
                                            <canvas id="departmentChart"></canvas>
                                        </div>
                                    </div>
                                    <div class="card">
                                        <div class="card-header">
                                            <div class="card-title">Tendência por Período</div>
                                        </div>
                                        <div class="chart-container">
                                            <canvas id="trendChart"></canvas>
                                        </div>
                                    </div>
                                </div>
                                <div class="card" style="margin-top: 20px;">
                                    <div class="card-header">
                                        <div class="card-title">Resumo Estatístico</div>
                                    </div>
                                    <div id="statisticsSummary" style="margin-top: 15px;">
                                        <!-- Resumo estatístico será inserido aqui -->
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
            
            <section id="relatoriosSection" style="display: none;">
                <div class="header">
                    <h2>Relatórios</h2>
                </div>
                <div class="filter-container">
                    <div class="filter-group">
                        <label class="filter-label">Tipo de Relatório</label>
                        <select class="filter-select" id="reportType">
                            <option value="mensal">Relatório Mensal</option>
                            <option value="departamento">Relatório por Departamento</option>
                            <option value="status">Relatório por Status</option>
                            <option value="completo">Relatório Completo</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Formato</label>
                        <select class="filter-select" id="reportFormat">
                            <option value="tabela">Tabela</option>
                            <option value="grafico">Gráfico</option>
                            <option value="ambos">Ambos</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <button class="btn btn-primary" id="generateReportBtn">
                            <i class="fas fa-file-export"></i>Gerar Relatório
                        </button>
                    </div>
                </div>
                
                <div class="card" id="reportContent" style="margin-top: 20px;">
                    <div class="card-header">
                        <div class="card-title" id="reportTitle">Relatório</div>
                        <button class="btn btn-success" id="exportReportBtn">
                            <i class="fas fa-download"></i>Exportar
                        </button>
                    </div>
                    <div id="reportBody" style="margin-top: 20px;">
                        <!-- O conteúdo do relatório será inserido aqui -->
                        <div class="empty-state">
                            <i class="fas fa-file-alt"></i>
                            <h3>Nenhum relatório gerado</h3>
                            <p>Selecione as opções e clique em "Gerar Relatório" para visualizar.</p>
                        </div>
                    </div>
                </div>
            </section>
            
            <section id="analisesSection" style="display: none;">
                <div class="header">
                    <h2>Análises Avançadas</h2>
                </div>
                <div class="dashboard-grid">
                    <div class="card">
                        <div class="card-header">
                            <div class="card-title">Tendências</div>
                        </div>
                        <div class="chart-container">
                            <canvas id="trendAnalysisChart"></canvas>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card-header">
                            <div class="card-title">Previsões</div>
                        </div>
                        <div class="chart-container">
                            <canvas id="forecastChart"></canvas>
                        </div>
                    </div>
                </div>
                
                <div class="card" style="margin-top: 20px;">
                    <div class="card-header">
                        <div class="card-title">Correlações</div>
                    </div>
                    <div class="chart-container">
                        <canvas id="correlationChart"></canvas>
                    </div>
                    <div id="correlationSummary" style="margin-top: 15px; padding: 0 15px 15px;">
                        <!-- Resumo de correlações será inserido aqui -->
                    </div>
                </div>
            </section>
            
            <section id="configuracoesSection" style="display: none;">
                <div class="header">
                    <h2>Configurações</h2>
                </div>
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">Configurações Gerais</div>
                    </div>
                    <div style="margin-top: 20px;">
                        <div class="filter-group" style="margin-bottom: 15px;">
                            <label class="filter-label">Tema</label>
                            <select class="filter-select" id="themeSelect">
                                <option value="light">Claro</option>
                                <option value="dark">Escuro</option>
                                <option value="blue">Azul</option>
                                <option value="green">Verde</option>
                            </select>
                        </div>
                        <div class="filter-group" style="margin-bottom: 15px;">
                            <label class="filter-label">Itens por página</label>
                            <select class="filter-select" id="itemsPerPage">
                                <option value="10">10</option>
                                <option value="25">25</option>
                                <option value="50">50</option>
                                <option value="100">100</option>
                            </select>
                        </div>
                        <div class="filter-group" style="margin-bottom: 15px;">
                            <label class="filter-label">Formato de data</label>
                            <select class="filter-select" id="dateFormat">
                                <option value="dd/mm/yyyy">DD/MM/AAAA</option>
                                <option value="mm/dd/yyyy">MM/DD/AAAA</option>
                                <option value="yyyy-mm-dd">AAAA-MM-DD</option>
                            </select>
                        </div>
                        <button class="btn btn-primary" id="saveConfigBtn" style="margin-top: 10px;">
                            <i class="fas fa-save"></i>Salvar Configurações
                        </button>
                    </div>
                </div>
                
                <div class="card" style="margin-top: 20px;">
                    <div class="card-header">
                        <div class="card-title">Configurações de Visualização</div>
                    </div>
                    <div style="margin-top: 20px;">
                        <div class="filter-group" style="margin-bottom: 15px;">
                            <label class="filter-label">Tipo de gráfico padrão</label>
                            <select class="filter-select" id="defaultChartType">
                                <option value="bar">Barras</option>
                                <option value="line">Linha</option>
                                <option value="pie">Pizza</option>
                                <option value="doughnut">Rosca</option>
                            </select>
                        </div>
                        <div class="filter-group" style="margin-bottom: 15px;">
                            <label class="filter-label">Paleta de cores</label>
                            <select class="filter-select" id="colorPalette">
                                <option value="default">Padrão</option>
                                <option value="pastel">Pastel</option>
                                <option value="bright">Vibrante</option>
                                <option value="monochrome">Monocromático</option>
                            </select>
                        </div>
                        <div class="filter-group" style="margin-bottom: 15px;">
                            <label class="filter-label">Animações</label>
                            <select class="filter-select" id="animations">
                                <option value="enabled">Habilitadas</option>
                                <option value="disabled">Desabilitadas</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div class="card" style="margin-top: 20px;">
                    <div class="card-header">
                        <div class="card-title">Sobre o Dashboard</div>
                    </div>
                    <div style="margin-top: 15px; padding: 0 15px 15px;">
                        <p>SUAD Dashboard v1.0.0</p>
                        <p style="margin-top: 10px;">Este dashboard foi desenvolvido para visualização e análise de dados financeiros e operacionais.</p>
                        <p style="margin-top: 10px;">Para suporte ou dúvidas, entre em contato com a equipe de TI.</p>
                    </div>
                </div>
                
                <div class="card" style="margin-top: 20px;">
                    <div class="card-header">
                        <div class="card-title">Ferramentas de Diagnóstico</div>
                    </div>
                    <div style="margin-top: 15px; padding: 10px 15px 15px;">
                        <p>Utilize estas ferramentas para identificar e corrigir problemas no dashboard.</p>
                        <div style="display: flex; gap: 10px; margin-top: 15px;">
                            <button class="btn btn-warning" id="btnDiagnosticar">
                                <i class="fas fa-stethoscope"></i> Diagnóstico
                            </button>
                            <button class="btn btn-warning" id="btnReiniciar">
                                <i class="fas fa-sync"></i> Reiniciar Dashboard
                            </button>
                            <button class="btn btn-warning" id="btnLimparCache">
                                <i class="fas fa-broom"></i> Limpar Cache
                            </button>
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </div>
    
    <!-- Painel de Debug -->
    <div id="debugPanel">
        <h4>Debug <span id="closeDebug" style="float:right; cursor:pointer;">×</span></h4>
        <div id="debugContent"></div>
        <button id="clearDebug">Limpar</button>
    </div>

    <script>
// Manipulador de erros global
window.addEventListener('error', function(event) {
    console.error('Erro global capturado:', event.error);
    hideLoader();
    showError(`Erro durante o processamento: ${event.error ? event.error.message : 'Erro desconhecido'}`);
    logDebug(`ERRO: ${event.error ? event.error.message : 'Erro desconhecido'}`);
    event.preventDefault();
});

// Log de debug
function logDebug(message) {
    const debugContent = document.getElementById('debugContent');
    if (debugContent) {
        const time = new Date().toLocaleTimeString();
        const logEntry = document.createElement('div');
        logEntry.innerHTML = `<small>[${time}]</small> ${message}`;
        debugContent.appendChild(logEntry);
        debugContent.scrollTop = debugContent.scrollHeight;
    }
    console.log(`[DEBUG] ${message}`);
}

// Inicializar panel de debug
document.getElementById('closeDebug')?.addEventListener('click', function() {
    document.getElementById('debugPanel').classList.remove('active');
});

document.getElementById('clearDebug')?.addEventListener('click', function() {
    document.getElementById('debugContent').innerHTML = '';
});

// Variáveis globais
let allData = [];
let currentPage = 1;
let itemsPerPage = 10;
let filteredData = [];
let charts = {};
let colorPalettes = {
    default: ['#4361ee', '#3a0ca3', '#4895ef', '#4cc9f0', '#f72585', '#7209b7', '#b5179e'],
    pastel: ['#ffadad', '#ffd6a5', '#fdffb6', '#caffbf', '#9bf6ff', '#a0c4ff', '#bdb2ff', '#ffc6ff'],
    bright: ['#f94144', '#f3722c', '#f8961e', '#f9c74f', '#90be6d', '#43aa8b', '#577590'],
    monochrome: ['#0466c8', '#0353a4', '#023e7d', '#002855', '#001845', '#001233', '#33415c', '#5c677d']
};

// Timeout para o loader (evita ficar preso em carregamento)
let loaderTimeout;

// Elementos DOM
const fileInput = document.getElementById('fileInput');
const loader = document.getElementById('loader');
const errorMessage = document.getElementById('errorMessage');
const successMessage = document.getElementById('successMessage');
const infoMessage = document.getElementById('infoMessage');

// Seções
const mainDashboard = document.getElementById('mainDashboard');
const relatoriosSection = document.getElementById('relatoriosSection');
const analisesSection = document.getElementById('analisesSection');
const configuracoesSection = document.getElementById('configuracoesSection');
const emptyState = document.getElementById('emptyState');
const dashboardContent = document.getElementById('dashboardContent');

// Inicializar a página
document.addEventListener('DOMContentLoaded', function() {
    logDebug('Inicializando dashboard SUAD...');
    
    try {
        // Verificar bibliotecas
        const bibliotecas = [
            { nome: "XLSX", obj: window.XLSX },
            { nome: "Chart", obj: window.Chart },
            { nome: "Papa", obj: window.Papa },
            { nome: "Lodash", obj: window._ }
        ];
        
        bibliotecas.forEach(bib => {
            if (!bib.obj) {
                logDebug(`AVISO: Biblioteca ${bib.nome} não encontrada.`);
                showError(`A biblioteca ${bib.nome} não foi carregada corretamente. O dashboard pode não funcionar como esperado.`);
            } else {
                logDebug(`Biblioteca ${bib.nome} carregada com sucesso.`);
            }
        });
        
        // Inicializar tooltips e popovers
        initTooltipsAndPopovers();
        
        // Eventos de filtros
        document.getElementById('periodoFilter').addEventListener('change', applyFilters);
        document.getElementById('departamentoFilter').addEventListener('change', applyFilters);
        document.getElementById('statusFilter').addEventListener('change', applyFilters);
        document.getElementById('searchInput').addEventListener('input', debounce(applyFilters, 300));
        
        // Eventos de navegação
        document.querySelectorAll('.menu-item').forEach(item => {
            item.addEventListener('click', function() {
                const section = this.getAttribute('data-section');
                changeSection(section);
            });
        });
        
        // Eventos de tabs
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const tabId = this.getAttribute('data-tab');
                changeTab(tabId);
            });
        });
        
        // Evento de carregamento de arquivo
        fileInput.addEventListener('change', handleFileUpload);
        
        // Evento de geração de relatório
        document.getElementById('generateReportBtn').addEventListener('click', generateReport);
        
        // Evento de exportação de relatório
        document.getElementById('exportReportBtn').addEventListener('click', exportReport);
        
        // Evento de salvar configurações
        document.getElementById('saveConfigBtn').addEventListener('click', saveConfigurations);
        
        // Evento de carregar dados de exemplo
        document.getElementById('loadSampleBtn').addEventListener('click', loadSampleData);
        
        // Toggle sidebar
        document.getElementById('toggleSidebar').addEventListener('click', toggleSidebar);
        
        // Ferramentas de diagnóstico
        document.getElementById('btnDiagnosticar')?.addEventListener('click', diagnosticarProblemas);
        document.getElementById('btnReiniciar')?.addEventListener('click', reiniciarDashboard);
        document.getElementById('btnLimparCache')?.addEventListener('click', limparCache);
        
        // Carregar configurações
        loadConfigurations();
        
        // Inicializar gráficos vazios
        initializeCharts();
        
        // Verificar se há dados salvos localmente
        const savedData = localStorage.getItem('suadDashboardData');
        if (savedData) {
            try {
                logDebug('Carregando dados do armazenamento local...');
                allData = JSON.parse(savedData);
                processData();
                showSuccess('Dados carregados do armazenamento local.');
            } catch (error) {
                console.error('Erro ao carregar dados do armazenamento local:', error);
                logDebug(`Erro ao carregar dados do localStorage: ${error.message}`);
            }
        }
        
        logDebug('Inicialização concluída com sucesso.');
    } catch (error) {
        console.error('Erro durante a inicialização:', error);
        logDebug(`ERRO NA INICIALIZAÇÃO: ${error.message}`);
        showError(`Erro ao inicializar o dashboard: ${error.message}`);
    }
});

// Funções de utilidade
function debounce(func, wait) {
    let timeout;
    return function() {
        const context = this;
        const args = arguments;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
    };
}

function showLoader() {
    loader.classList.add('active');
    
    // Configurar timeout de segurança (30 segundos)
    clearTimeout(loaderTimeout);
    loaderTimeout = setTimeout(() => {
        if (loader.classList.contains('active')) {
            hideLoader();
            showError("Tempo limite excedido. O carregamento demorou muito tempo.");
            logDebug("AVISO: Timeout do loader acionado");
        }
    }, 30000);
}

function hideLoader() {
    loader.classList.remove('active');
    clearTimeout(loaderTimeout);
}

function showError(message) {
    errorMessage.textContent = message;
    errorMessage.classList.add('active');
    setTimeout(() => {
        errorMessage.classList.remove('active');
    }, 5000);
    logDebug(`ERRO: ${message}`);
}

function showSuccess(message) {
    successMessage.textContent = message;
    successMessage.classList.add('active');
    setTimeout(() => {
        successMessage.classList.remove('active');
    }, 3000);
    logDebug(`SUCESSO: ${message}`);
}

function showInfo(message) {
    infoMessage.textContent = message;
    infoMessage.classList.add('active');
    setTimeout(() => {
        infoMessage.classList.remove('active');
    }, 3000);
    logDebug(`INFO: ${message}`);
}

function toggleSidebar() {
    document.getElementById('dashboard').classList.toggle('sidebar-collapsed');
}

function initTooltipsAndPopovers() {
    // Implementação simples de tooltips nativos
    document.querySelectorAll('[data-tooltip]').forEach(el => {
        el.setAttribute('title', el.getAttribute('data-tooltip'));
    });
}

// Funções de diagnóstico
function diagnosticarProblemas() {
    logDebug("Iniciando diagnóstico do dashboard...");
    document.getElementById('debugPanel').classList.add('active');
    
    // Verificar bibliotecas
    const bibliotecas = {
        "XLSX": typeof XLSX !== 'undefined',
        "Chart": typeof Chart !== 'undefined',
        "Papa": typeof Papa !== 'undefined',
        "lodash": typeof _ !== 'undefined'
    };
    
    logDebug("Verificação de bibliotecas:");
    for (const [biblioteca, status] of Object.entries(bibliotecas)) {
        logDebug(`- ${biblioteca}: ${status ? 'OK' : 'NÃO ENCONTRADA'}`);
    }
    
    // Verificar elementos cruciais
    const elementos = {
        "loader": !!document.getElementById('loader'),
        "fileInput": !!document.getElementById('fileInput'),
        "loadSampleBtn": !!document.getElementById('loadSampleBtn'),
        "dashboardContent": !!document.getElementById('dashboardContent'),
        "emptyState": !!document.getElementById('emptyState')
    };
    
    logDebug("Verificação de elementos HTML:");
    for (const [elemento, status] of Object.entries(elementos)) {
        logDebug(`- ${elemento}: ${status ? 'OK' : 'NÃO ENCONTRADO'}`);
    }
    
    // Verificar localStorage
    try {
        localStorage.setItem('test', 'test');
        localStorage.removeItem('test');
        logDebug("localStorage: Funcionando");
    } catch (e) {
        logDebug(`localStorage: ERRO - ${e.message}`);
    }
    
    // Verificar dados
    logDebug(`Status dos dados:`);
    logDebug(`- allData: ${Array.isArray(allData) ? allData.length + ' registros' : 'Inválido'}`);
    logDebug(`- filteredData: ${Array.isArray(filteredData) ? filteredData.length + ' registros' : 'Inválido'}`);
    
    // Verificar gráficos
    logDebug(`Status dos gráficos:`);
    for (const [chartName, chart] of Object.entries(charts)) {
        logDebug(`- ${chartName}: ${chart ? 'Inicializado' : 'Não inicializado'}`);
    }
    
    // Mostrar mensagem ao usuário
    showSuccess("Diagnóstico concluído. Verifique o painel de debug para detalhes.");
}

function reiniciarDashboard() {
    logDebug("Reiniciando dashboard...");
    
    try {
        // Limpar dados
        allData = [];
        filteredData = [];
        currentPage = 1;
        
        // Limpar localStorage (opcional)
        if (confirm("Deseja limpar também os dados salvos localmente?")) {
            localStorage.removeItem('suadDashboardData');
            logDebug("Dados do localStorage removidos");
        }
        
        // Limpar gráficos
        for (const chartKey in charts) {
            if (charts[chartKey]) {
                try {
                    charts[chartKey].destroy();
                } catch (e) {
                    logDebug(`Erro ao destruir gráfico ${chartKey}: ${e.message}`);
                }
            }
        }
        charts = {};
        
        // Reinicializar gráficos
        initializeCharts();
        
        // Mostrar estado vazio
        emptyState.style.display = 'flex';
        dashboardContent.style.display = 'none';
        
        // Limpar tabela
        const tableBody = document.getElementById('tableBody');
        if (tableBody) tableBody.innerHTML = '';
        
        // Limpar contadores
        document.getElementById('totalRegistros').textContent = '0';
        document.getElementById('mediaValores').textContent = 'R$ 0,00';
        document.getElementById('statusCount').textContent = '0 / 0';
        document.getElementById('ultimaAtualizacao').textContent = '--/--/----';
        
        // Limpar filtros
        document.getElementById('departamentoFilter').innerHTML = '<option value="todos">Todos</option>';
        document.getElementById('statusFilter').innerHTML = '<option value="todos">Todos</option>';
        document.getElementById('searchInput').value = '';
        document.getElementById('periodoFilter').value = 'todos';
        
        showSuccess("Dashboard reiniciado com sucesso!");
        logDebug("Dashboard reiniciado com sucesso");
    } catch (error) {
        console.error('Erro ao reiniciar dashboard:', error);
        showError(`Erro ao reiniciar dashboard: ${error.message}`);
        logDebug(`ERRO ao reiniciar dashboard: ${error.message}`);
    }
}

function limparCache() {
    try {
        logDebug("Limpando cache do dashboard...");
        localStorage.removeItem('suadDashboardData');
        localStorage.removeItem('suadDashboardConfig');
        
        showSuccess("Cache limpo com sucesso! Recarregue a página para aplicar as mudanças.");
        logDebug("Cache limpo com sucesso");
        
        // Oferecer recarga da página
        if (confirm("É recomendado recarregar a página após limpar o cache. Deseja recarregar agora?")) {
            location.reload();
        }
    } catch (error) {
        console.error('Erro ao limpar cache:', error);
        showError(`Erro ao limpar cache: ${error.message}`);
        logDebug(`ERRO ao limpar cache: ${error.message}`);
    }
}

// Funções principais
function handleFileUpload(event) {
    const file = event.target.files[0];
    if (!file) {
        showInfo('Nenhum arquivo selecionado');
        return;
    }
    
    logDebug(`Iniciando upload de arquivo: ${file.name} (${file.size} bytes)`);
    
    // Verificar extensão
    const fileExtension = file.name.split('.').pop().toLowerCase();
    if (fileExtension !== 'xlsx' && fileExtension !== 'xls' && fileExtension !== 'csv') {
        showError('Por favor, carregue apenas arquivos Excel (.xlsx, .xls) ou CSV (.csv)');
        logDebug(`Extensão inválida: ${fileExtension}`);
        return;
    }
    
    // Verificar tamanho do arquivo (limitado a 10MB)
    if (file.size > 10 * 1024 * 1024) {
        showError('O arquivo é muito grande. O tamanho máximo é 10MB.');
        logDebug(`Arquivo muito grande: ${(file.size / (1024 * 1024)).toFixed(2)}MB`);
        return;
    }
    
    // Mostrar loader
    showLoader();
    
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            let data;
            
            if (fileExtension === 'csv') {
                // Processar CSV
                logDebug("Processando arquivo CSV...");
                const csvContent = e.target.result;
                const parsedCsv = Papa.parse(csvContent, {
                    header: true,
                    dynamicTyping: true,
                    skipEmptyLines: true
                });
                
                if (parsedCsv.errors && parsedCsv.errors.length > 0) {
                    throw new Error(`Erro ao analisar CSV: ${parsedCsv.errors[0].message}`);
                }
                
                data = parsedCsv.data;
                logDebug(`CSV processado: ${data.length} registros encontrados`);
            } else {
                // Processar Excel
                logDebug("Processando arquivo Excel...");
                const arrayBuffer = e.target.result;
                const data = new Uint8Array(arrayBuffer);
                
                // Verificar assinatura do arquivo (deve ser um arquivo ZIP válido para XLSX/XLS)
                if (data.length < 4 || data[0] !== 0x50 || data[1] !== 0x4B) {
                    throw new Error("O arquivo Excel está corrompido ou em formato inválido");
                }
                
                const workbook = XLSX.read(data, {
                    type: 'array', 
                    cellDates: true,
                    cellStyles: true,
                    WTF: true // Mostrar mais informações de erro
                });
                
                // Pegar a primeira planilha
                if (!workbook.SheetNames || workbook.SheetNames.length === 0) {
                    throw new Error("O arquivo Excel não contém planilhas");
                }
                
                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                if (!firstSheet || !firstSheet['!ref']) {
                    throw new Error("A planilha está vazia ou com formato inválido");
                }
                
                // Converter para JSON
                data = XLSX.utils.sheet_to_json(firstSheet, {
                    raw: false,
                    dateNF: 'yyyy-mm-dd'
                });
                
                logDebug(`Excel processado: ${data.length} registros encontrados`);
            }
            
            if (!data || !Array.isArray(data)) {
                throw new Error('Formato de dados inválido. Verifique o arquivo.');
            }
            
            if (data.length === 0) {
                throw new Error('O arquivo não contém dados válidos.');
            }
            
            // Verificar estrutura dos dados
            if (typeof data[0] !== 'object' || Array.isArray(data[0])) {
                throw new Error('Estrutura de dados inválida. Verifique o formato da planilha.');
            }
            
            // Salvar dados
            allData = data;
            
            // Salvar no localStorage para uso futuro
            try {
                localStorage.setItem('suadDashboardData', JSON.stringify(allData));
                logDebug("Dados salvos no localStorage");
            } catch (e) {
                console.warn('Não foi possível salvar os dados no armazenamento local:', e);
                logDebug(`Erro ao salvar no localStorage: ${e.message}`);
            }
            
            // Processar dados e atualizar dashboard
            processData();
            showSuccess('Planilha carregada com sucesso!');
        } catch (error) {
            console.error('Erro ao processar arquivo:', error);
            showError(`Erro ao processar o arquivo: ${error.message}`);
            logDebug(`ERRO ao processar arquivo: ${error.message}`);
            emptyState.style.display = 'flex';
            dashboardContent.style.display = 'none';
        } finally {
            // Esconder loader
            hideLoader();
        }
    };
    
    reader.onerror = function() {
        showError('Erro ao ler o arquivo.');
        hideLoader();
        logDebug("ERRO na leitura do arquivo");
    };
    
    try {
        if (fileExtension === 'csv') {
            reader.readAsText(file);
        } else {
            reader.readAsArrayBuffer(file);
        }
    } catch (error) {
        showError(`Erro ao ler o arquivo: ${error.message}`);
        hideLoader();
        logDebug(`ERRO ao ler arquivo: ${error.message}`);
    }
}

function processData() {
    logDebug("Processando dados...");
    
    if (!allData || allData.length === 0) {
        logDebug("Sem dados para processar");
        emptyState.style.display = 'flex';
        dashboardContent.style.display = 'none';
        return;
    }
    
    try {
        emptyState.style.display = 'none';
        dashboardContent.style.display = 'block';
        
        // Inicializar filteredData com todos os dados
        filteredData = [...allData];
        
        // Normalizar nomes de colunas se necessário
        normalizeData();
        
        // Preencher os selects de filtro
        populateFilterOptions();
        
        // Atualizar contadores
        updateCounters();
        
        // Renderizar tabela
        renderTable();
        
        // Atualizar gráficos
        updateCharts();
        
        // Atualizar estatísticas
        updateStatistics();
        
        // Atualizar relatórios e análises se necessário
        if (relatoriosSection.style.display !== 'none') {
            generateReport();
        }
        
        if (analisesSection.style.display !== 'none') {
            updateAnalysis();
        }
        
        logDebug("Processamento de dados concluído com sucesso");
    } catch (error) {
        console.error("Erro ao processar dados:", error);
        showError(`Erro ao processar dados: ${error.message}`);
        logDebug(`ERRO ao processar dados: ${error.message}`);
        emptyState.style.display = 'flex';
        dashboardContent.style.display = 'none';
    }
}

function normalizeData() {
    logDebug("Normalizando dados...");
    
    // Verificar se os dados precisam ser normalizados
    if (allData.length === 0) return;
    
    try {
        // Detectar colunas importantes e normalizá-las para facilitar o acesso
        const sampleItem = allData[0];
        const keys = Object.keys(sampleItem);
        
        logDebug(`Colunas encontradas: ${keys.join(', ')}`);
        
        // Mapeamento de nomes de colunas comuns
        const columnMappings = {
            data: keys.find(k => /data|date|dt/i.test(k)),
            departamento: keys.find(k => /depart|setor|dept|area/i.test(k)),
            status: keys.find(k => /status|situacao|state/i.test(k)),
            valor: keys.find(k => /valor|value|amount|quant|preco|price|total/i.test(k)),
            id: keys.find(k => /id|codigo|code/i.test(k))
        };
        
        logDebug(`Mapeamento de colunas: ${JSON.stringify(columnMappings)}`);
        
        // Normalizar valores de data
        if (columnMappings.data) {
            allData.forEach(item => {
                const dateValue = item[columnMappings.data];
                
                if (!(dateValue instanceof Date) && dateValue) {
                    // Tentar converter para data
                    try {
                        if (typeof dateValue === 'number') {
                            // Provavelmente um número serial do Excel
                            item[columnMappings.data] = new Date(Math.round((dateValue - 25569) * 86400 * 1000));
                        } else if (typeof dateValue === 'string') {
                            // Tenta converter string de data
                            const dateParts = dateValue.split(/[\/\-\.]/);
                            if (dateParts.length === 3) {
                                let day, month, year;
                                
                                // Detectar formato baseado no tamanho das partes
                                if (dateParts[0].length === 4) {
                                    // YYYY-MM-DD
                                    year = parseInt(dateParts[0]);
                                    month = parseInt(dateParts[1]) - 1;
                                    day = parseInt(dateParts[2]);
                                } else if (dateParts[2].length === 4) {
                                    // DD-MM-YYYY ou MM-DD-YYYY
                                    year = parseInt(dateParts[2]);
                                    // Heurística simples: se primeiro número > 12, assume DD-MM-YYYY
                                    if (parseInt(dateParts[0]) > 12) {
                                        day = parseInt(dateParts[0]);
                                        month = parseInt(dateParts[1]) - 1;
                                    } else {
                                        month = parseInt(dateParts[0]) - 1;
                                        day = parseInt(dateParts[1]);
                                    }
                                }
                                
                                if (day && month !== undefined && year) {
                                    item[columnMappings.data] = new Date(year, month, day);
                                }
                            } else {
                                // Última tentativa com construtor Date padrão
                                item[columnMappings.data] = new Date(dateValue);
                            }
                        }
                    } catch (e) {
                        console.warn('Erro ao converter data:', e);
                        logDebug(`Erro ao converter data: ${e.message}`);
                    }
                }
            });
        }
        
        // Normalizar valores numéricos
        if (columnMappings.valor) {
            allData.forEach(item => {
                const value = item[columnMappings.valor];
                
                if (typeof value === 'string') {
                    // Remover caracteres não-numéricos exceto ponto e vírgula
                    const cleanValue = value.replace(/[^\d.,\-]/g, '').replace(',', '.');
                    const numValue = parseFloat(cleanValue);
                    
                    if (!isNaN(numValue)) {
                        item[columnMappings.valor] = numValue;
                    }
                }
            });
        }
        
        logDebug("Normalização de dados concluída");
    } catch (error) {
        console.error("Erro ao normalizar dados:", error);
        logDebug(`ERRO na normalização de dados: ${error.message}`);
        // Não lançar o erro para continuar o processamento
    }
}

function populateFilterOptions() {
    logDebug("Populando opções de filtro...");
    
    try {
        // Departamento
        const departamentos = [...new Set(allData.map(item => {
            // Detectar automaticamente a coluna de departamento
            const deptKey = Object.keys(item).find(key => 
                key.toLowerCase().includes('depart') || 
                key.toLowerCase().includes('setor') ||
                key.toLowerCase().includes('dept')
            );
            return deptKey ? item[deptKey] : null;
        }).filter(Boolean))];
        
        const departamentoSelect = document.getElementById('departamentoFilter');
        departamentoSelect.innerHTML = '<option value="todos">Todos</option>';
        departamentos.forEach(dept => {
            if (dept) {
                departamentoSelect.innerHTML += `<option value="${dept}">${dept}</option>`;
            }
        });
        
        // Status
        const statusList = [...new Set(allData.map(item => {
            // Detectar automaticamente a coluna de status
            const statusKey = Object.keys(item).find(key => 
                key.toLowerCase().includes('status') || 
                key.toLowerCase().includes('situacao')
            );
            return statusKey ? item[statusKey] : null;
        }).filter(Boolean))];
        
        const statusSelect = document.getElementById('statusFilter');
        statusSelect.innerHTML = '<option value="todos">Todos</option>';
        statusList.forEach(status => {
            if (status) {
                statusSelect.innerHTML += `<option value="${status}">${status}</option>`;
            }
        });
        
        logDebug(`Encontrados ${departamentos.length} departamentos e ${statusList.length} status`);
    } catch (error) {
        console.error("Erro ao popular filtros:", error);
        logDebug(`ERRO ao popular filtros: ${error.message}`);
    }
}

function applyFilters() {
    logDebug("Aplicando filtros...");
    
    try {
        const periodo = document.getElementById('periodoFilter').value;
        const departamento = document.getElementById('departamentoFilter').value;
        const status = document.getElementById('statusFilter').value;
        const searchText = document.getElementById('searchInput').value.toLowerCase();
        
        // Filtrar os dados
        filteredData = allData.filter(item => {
            // Filtro de departamento
            const deptKey = Object.keys(item).find(key => 
                key.toLowerCase().includes('depart') || 
                key.toLowerCase().includes('setor') ||
                key.toLowerCase().includes('dept')
            );
            const deptMatch = departamento === 'todos' || 
                            (deptKey && String(item[deptKey]).toLowerCase() === departamento.toLowerCase());
            
            // Filtro de status
            const statusKey = Object.keys(item).find(key => 
                key.toLowerCase().includes('status') || 
                key.toLowerCase().includes('situacao')
            );
            const statusMatch = status === 'todos' || 
                            (statusKey && String(item[statusKey]).toLowerCase() === status.toLowerCase());
            
            // Filtro de período
            let periodoMatch = true;
            if (periodo !== 'todos') {
                const dateKey = Object.keys(item).find(key => 
                    key.toLowerCase().includes('data') || 
                    item[key] instanceof Date
                );
                
                if (dateKey) {
                    const itemDate = item[dateKey] instanceof Date ? 
                                    item[dateKey] : 
                                    new Date(item[dateKey]);
                    
                    if (itemDate instanceof Date && !isNaN(itemDate)) {
                        const today = new Date();
                        const firstDayOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
                        const lastDayOfLastMonth = new Date(today.getFullYear(), today.getMonth(), 0);
                        const firstDayOfLastMonth = new Date(today.getFullYear(), today.getMonth() - 1, 1);
                        const threeMonthsAgo = new Date(today.getFullYear(), today.getMonth() - 3, today.getDate());
                        const yearStart = new Date(today.getFullYear(), 0, 1);
                        
                        switch (periodo) {
                            case 'atual':
                                periodoMatch = itemDate >= firstDayOfMonth;
                                break;
                            case 'anterior':
                                periodoMatch = itemDate >= firstDayOfLastMonth && itemDate <= lastDayOfLastMonth;
                                break;
                            case 'trimestre':
                                periodoMatch = itemDate >= threeMonthsAgo;
                                break;
                            case 'anual':
                                periodoMatch = itemDate >= yearStart;
                                break;
                        }
                    } else {
                        periodoMatch = false;
                    }
                }
            }
            
            // Filtro de busca
            let searchMatch = true;
            if (searchText) {
                searchMatch = Object.entries(item).some(([key, value]) => 
                    String(value).toLowerCase().includes(searchText)
                );
            }
            
            return deptMatch && statusMatch && periodoMatch && searchMatch;
        });
        
        // Resetar paginação
        currentPage = 1;
        
        // Atualizar visualizações
        updateCounters();
        renderTable();
        updateCharts();
        updateStatistics();
        
        logDebug(`Filtros aplicados: ${filteredData.length} registros resultantes`);
    } catch (error) {
        console.error("Erro ao aplicar filtros:", error);
        showError(`Erro ao aplicar filtros: ${error.message}`);
        logDebug(`ERRO ao aplicar filtros: ${error.message}`);
    }
}

function updateCounters() {
    try {
        // Total de registros
        document.getElementById('totalRegistros').textContent = filteredData.length.toLocaleString('pt-BR');
        
        // Média de valores
        const valorKey = Object.keys(filteredData[0] || {}).find(key => 
            key.toLowerCase().includes('valor') || 
            key.toLowerCase().includes('quant') ||
            key.toLowerCase().includes('total') ||
            key.toLowerCase().includes('preco')
        );
        
        if (valorKey) {
            const valores = filteredData.map(item => {
                const val = item[valorKey];
                // Converter string para número se necessário
                if (typeof val === 'string') {
                    return parseFloat(val.replace(/[^\d.,]/g, '').replace(',', '.')) || 0;
                }
                return typeof val === 'number' ? val : 0;
            });
            
            const soma = valores.reduce((acc, val) => acc + val, 0);
            const media = valores.length > 0 ? soma / valores.length : 0;
            
            const formatter = new Intl.NumberFormat('pt-BR', {
                style: 'currency',
                currency: 'BRL'
            });
            
            document.getElementById('mediaValores').textContent = formatter.format(media);
        }
        
        // Status count
        const statusKey = Object.keys(filteredData[0] || {}).find(key => 
            key.toLowerCase().includes('status') || 
            key.toLowerCase().includes('situacao')
        );
        
        if (statusKey) {
            const statusCounts = {};
            filteredData.forEach(item => {
                const status = item[statusKey];
                statusCounts[status] = (statusCounts[status] || 0) + 1;
            });
            
            // Tentar identificar status concluídos e pendentes
            let completosCount = 0;
            let pendentesCount = 0;
            
            Object.entries(statusCounts).forEach(([key, value]) => {
                const lowerKey = String(key).toLowerCase();
                if (lowerKey.includes('comple') || 
                    lowerKey.includes('conclu') ||
                    lowerKey.includes('finaliz') ||
                    lowerKey.includes('ok') ||
                    lowerKey.includes('feito')) {
                    completosCount += value;
                } else if (lowerKey.includes('pend') || 
                        lowerKey.includes('aberto') ||
                        lowerKey.includes('em and') ||
                        lowerKey.includes('process') ||
                        lowerKey.includes('aguard')) {
                    pendentesCount += value;
                }
            });
            
            document.getElementById('statusCount').textContent = `${completosCount} / ${pendentesCount}`;
        }
        
        // Última atualização
        const now = new Date();
        const dateStr = now.toLocaleDateString('pt-BR', {
            day: '2-digit',
            month: '2-digit',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
        document.getElementById('ultimaAtualizacao').textContent = dateStr;
    } catch (error) {
        console.error("Erro ao atualizar contadores:", error);
        logDebug(`ERRO ao atualizar contadores: ${error.message}`);
    }
}

function renderTable() {
    try {
        const tableBody = document.getElementById('tableBody');
        const tableHeaders = document.getElementById('tableHeaders');
        const pagination = document.getElementById('pagination');
        
        // Limpar tabela
        tableBody.innerHTML = '';
        
        // Se não houver dados
        if (!filteredData || filteredData.length === 0) {
            tableBody.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 30px;">Nenhum dado encontrado</td></tr>';
            pagination.innerHTML = '';
            return;
        }
        
        // Ajustar cabeçalhos da tabela baseado nas colunas disponíveis
        const sampleItem = filteredData[0];
        const columns = Object.keys(sampleItem);
        
        tableHeaders.innerHTML = '';
        columns.forEach(col => {
            tableHeaders.innerHTML += `<th>${col}</th>`;
        });
        
        // Calcular paginação
        const totalPages = Math.ceil(filteredData.length / itemsPerPage);
        const start = (currentPage - 1) * itemsPerPage;
        const end = Math.min(start + itemsPerPage, filteredData.length);
        const pageData = filteredData.slice(start, end);
        
        // Preencher dados
        pageData.forEach(item => {
            const row = document.createElement('tr');
            
            columns.forEach(col => {
                const td = document.createElement('td');
                let cellValue = item[col];
                
                // Formatar data se necessário
                if (cellValue instanceof Date) {
                    cellValue = cellValue.toLocaleDateString('pt-BR');
                }
                
                // Adicionar classe de badge para status
                if (col.toLowerCase().includes('status') || col.toLowerCase().includes('situacao')) {
                    const statusText = String(cellValue).toLowerCase();
                    let badgeClass = '';
                    
                    if (statusText.includes('comple') || statusText.includes('conclu') || 
                        statusText.includes('finaliz') || statusText.includes('ok') ||
                        statusText.includes('feito')) {
                        badgeClass = 'badge badge-success';
                    } else if (statusText.includes('pend') || statusText.includes('aberto') || 
                            statusText.includes('process') || statusText.includes('andamento')) {
                        badgeClass = 'badge badge-warning';
                    } else if (statusText.includes('cancel') || statusText.includes('erro') || 
                            statusText.includes('falha')) {
                        badgeClass = 'badge badge-danger';
                    }
                    
                    if (badgeClass) {
                        td.innerHTML = `<span class="${badgeClass}">${cellValue}</span>`;
                    } else {
                        td.textContent = cellValue;
                    }
                } 
                // Formatar valor monetário
                else if (col.toLowerCase().includes('valor') || col.toLowerCase().includes('preco')) {
                    let numValue = cellValue;
                    if (typeof cellValue === 'string') {
                        numValue = parseFloat(cellValue.replace(/[^\d.,]/g, '').replace(',', '.'));
                    }
                    
                    if (!isNaN(numValue)) {
                        const formatter = new Intl.NumberFormat('pt-BR', {
                            style: 'currency',
                            currency: 'BRL'
                        });
                        td.textContent = formatter.format(numValue);
                    } else {
                        td.textContent = cellValue;
                    }
                } else {
                    td.textContent = cellValue;
                }
                
                row.appendChild(td);
            });
            
            tableBody.appendChild(row);
        });
        
        // Renderizar paginação
        pagination.innerHTML = '';
        
        if (totalPages <= 1) {
            return;
        }
        
        // Botão anterior
        const prevBtn = document.createElement('button');
        prevBtn.className = 'page-btn';
        prevBtn.innerHTML = '<i class="fas fa-chevron-left"></i>';
        prevBtn.disabled = currentPage === 1;
        prevBtn.addEventListener('click', () => {
            if (currentPage > 1) {
                currentPage--;
                renderTable();
            }
        });
        pagination.appendChild(prevBtn);
        
        // Botões de página
        const maxButtons = 5;
        const startPage = Math.max(1, currentPage - Math.floor(maxButtons / 2));
        const endPage = Math.min(totalPages, startPage + maxButtons - 1);
        
        // Primeiro botão se estiver longe
        if (startPage > 1) {
            const firstBtn = document.createElement('button');
            firstBtn.className = 'page-btn';
            firstBtn.textContent = '1';
            firstBtn.addEventListener('click', () => {
                currentPage = 1;
                renderTable();
            });
            pagination.appendChild(firstBtn);
            
            if (startPage > 2) {
                const ellipsis = document.createElement('span');
                ellipsis.textContent = '...';
                ellipsis.style.margin = '0 5px';
                pagination.appendChild(ellipsis);
            }
        }
        
        // Botões centrais
        for (let i = startPage; i <= endPage; i++) {
            const pageBtn = document.createElement('button');
            pageBtn.className = `page-btn ${i === currentPage ? 'active' : ''}`;
            pageBtn.textContent = i;
            pageBtn.addEventListener('click', () => {
                currentPage = i;
                renderTable();
            });
            pagination.appendChild(pageBtn);
        }
        
        // Último botão se estiver longe
        if (endPage < totalPages) {
            if (endPage < totalPages - 1) {
                const ellipsis = document.createElement('span');
                ellipsis.textContent = '...';
                ellipsis.style.margin = '0 5px';
                pagination.appendChild(ellipsis);
            }
            
            const lastBtn = document.createElement('button');
            lastBtn.className = 'page-btn';
            lastBtn.textContent = totalPages;
            lastBtn.addEventListener('click', () => {
                currentPage = totalPages;
                renderTable();
            });
            pagination.appendChild(lastBtn);
        }
        
        // Botão próximo
        const nextBtn = document.createElement('button');
        nextBtn.className = 'page-btn';
        nextBtn.innerHTML = '<i class="fas fa-chevron-right"></i>';
        nextBtn.disabled = currentPage === totalPages;
        nextBtn.addEventListener('click', () => {
            if (currentPage < totalPages) {
                currentPage++;
                renderTable();
            }
        });
        pagination.appendChild(nextBtn);
    } catch (error) {
        console.error("Erro ao renderizar tabela:", error);
        showError(`Erro ao renderizar tabela: ${error.message}`);
        logDebug(`ERRO ao renderizar tabela: ${error.message}`);
    }
}

function initializeCharts() {
    logDebug("Inicializando gráficos...");
    
    try {
        // Verificar se Chart está disponível
        if (typeof Chart === 'undefined') {
            throw new Error("Biblioteca Chart.js não encontrada");
        }
        
        // Registrar paletas de cores no Chart.js
        Chart.defaults.plugins.colors = {
            enabled: true
        };
        
        // Disable animations for better performance
        Chart.defaults.animation = false;
        
        // Set default font
        Chart.defaults.font.family = "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif";
        Chart.defaults.font.size = 12;
        
        // Definir paleta de cores padrão
        Chart.defaults.color = '#333';
        
        // Função para criar gráfico com tratamento de erro
        function createChart(ctx, config, chartName) {
            try {
                if (!ctx) {
                    throw new Error(`Elemento canvas para ${chartName} não encontrado`);
                }
                return new Chart(ctx, config);
            } catch (e) {
                logDebug(`ERRO ao criar gráfico ${chartName}: ${e.message}`);
                return null;
            }
        }
        
        // Gráfico principal (colunas)
        const mainChartConfig = {
            type: 'bar',
            data: {
                labels: [],
                datasets: [{
                    label: 'Valores',
                    data: [],
                    backgroundColor: 'rgba(67, 97, 238, 0.5)',
                    borderColor: 'rgba(67, 97, 238, 1)',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        }
                    },
                    x: {
                        grid: {
                            display: false
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    title: {
                        display: true,
                        text: 'Distribuição por Departamento',
                        font: {
                            size: 16
                        }
                    }
                }
            }
        };
        
        const mainChartCtx = document.getElementById('mainChart')?.getContext('2d');
        charts.mainChart = createChart(mainChartCtx, mainChartConfig, 'mainChart');
        
        // Gráfico secundário (linha)
        const secondaryChartConfig = {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Tendência Temporal',
                    data: [],
                    borderColor: 'rgba(114, 9, 183, 1)',
                    backgroundColor: 'rgba(114, 9, 183, 0.2)',
                    tension: 0.4,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        }
                    },
                    x: {
                        grid: {
                            display: false
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    title: {
                        display: true,
                        text: 'Evolução Temporal',
                        font: {
                            size: 16
                        }
                    }
                }
            }
        };
        
        const secondaryChartCtx = document.getElementById('secondaryChart')?.getContext('2d');
        charts.secondaryChart = createChart(secondaryChartCtx, secondaryChartConfig, 'secondaryChart');
        
        // Gráfico por departamento (pizza)
        const deptChartConfig = {
            type: 'pie',
            data: {
                labels: [],
                datasets: [{
                    data: [],
                    backgroundColor: colorPalettes.default,
                    borderColor: '#fff',
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right'
                    },
                    title: {
                        display: true,
                        text: 'Distribuição por Departamento',
                        font: {
                            size: 16
                        }
                    }
                }
            }
        };
        
        const deptChartCtx = document.getElementById('departmentChart')?.getContext('2d');
        charts.departmentChart = createChart(deptChartCtx, deptChartConfig, 'departmentChart');
        
        // Gráfico de tendência
        const trendChartConfig = {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Valores',
                    data: [],
                    borderColor: 'rgba(76, 201, 240, 1)',
                    backgroundColor: 'rgba(76, 201, 240, 0.2)',
                    tension: 0.3,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        }
                    },
                    x: {
                        grid: {
                            display: false
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    title: {
                        display: true,
                        text: 'Tendência por Período',
                        font: {
                            size: 16
                        }
                    }
                }
            }
        };
        
        const trendChartCtx = document.getElementById('trendChart')?.getContext('2d');
        charts.trendChart = createChart(trendChartCtx, trendChartConfig, 'trendChart');
        
        // Gráficos da seção de análises
        const trendAnalysisChartConfig = {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Dados Reais',
                    data: [],
                    borderColor: 'rgba(76, 201, 240, 1)',
                    backgroundColor: 'rgba(76, 201, 240, 0.2)',
                    tension: 0.3,
                    fill: false
                }, {
                    label: 'Linha de Tendência',
                    data: [],
                    borderColor: 'rgba(247, 37, 133, 1)',
                    backgroundColor: 'rgba(247, 37, 133, 0.1)',
                    borderDash: [5, 5],
                    tension: 0,
                    fill: false
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        }
                    },
                    x: {
                        grid: {
                            display: false
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    title: {
                        display: true,
                        text: 'Análise de Tendência',
                        font: {
                            size: 16
                        }
                    }
                }
            }
        };
        
        const trendAnalysisChartCtx = document.getElementById('trendAnalysisChart')?.getContext('2d');
        charts.trendAnalysisChart = createChart(trendAnalysisChartCtx, trendAnalysisChartConfig, 'trendAnalysisChart');
        
        // Gráfico de previsão
        const forecastChartConfig = {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Histórico',
                    data: [],
                    borderColor: 'rgba(76, 201, 240, 1)',
                    backgroundColor: 'rgba(0, 0, 0, 0)'
                }, {
                    label: 'Previsão',
                    data: [],
                    borderColor: 'rgba(247, 37, 133, 1)',
                    backgroundColor: 'rgba(247, 37, 133, 0.2)',
                    borderDash: [5, 5],
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        }
                    },
                    x: {
                        grid: {
                            display: false
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    title: {
                        display: true,
                        text: 'Previsão para os Próximos 3 Meses',
                        font: {
                            size: 16
                        }
                    }
                }
            }
        };
        
        const forecastChartCtx = document.getElementById('forecastChart')?.getContext('2d');
        charts.forecastChart = createChart(forecastChartCtx, forecastChartConfig, 'forecastChart');
        
        // Gráfico de correlação
        const correlationChartConfig = {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Correlação',
                    data: [],
                    backgroundColor: 'rgba(114, 9, 183, 0.7)',
                    pointRadius: 6,
                    pointHoverRadius: 8
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Variável X'
                        },
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Variável Y'
                        },
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    title: {
                        display: true,
                        text: 'Análise de Correlação',
                        font: {
                            size: 16
                        }
                    }
                }
            }
        };
        
        const correlationChartCtx = document.getElementById('correlationChart')?.getContext('2d');
        charts.correlationChart = createChart(correlationChartCtx, correlationChartConfig, 'correlationChart');
        
        logDebug("Gráficos inicializados com sucesso");
    } catch (error) {
        console.error("Erro ao inicializar gráficos:", error);
        showError(`Erro ao inicializar gráficos: ${error.message}`);
        logDebug(`ERRO ao inicializar gráficos: ${error.message}`);
    }
}

function updateCharts() {
    if (!filteredData || filteredData.length === 0) {
        logDebug("Sem dados para atualizar gráficos");
        return;
    }
    
    try {
        logDebug("Atualizando gráficos...");
        
        // Verificar se os gráficos estão inicializados
        if (!charts.mainChart || !charts.secondaryChart || !charts.departmentChart || !charts.trendChart) {
            logDebug("Gráficos não inicializados. Reiniciando...");
            initializeCharts();
        }
        
        // Obter a paleta de cores atual
        const colorPalette = document.getElementById('colorPalette')?.value || 'default';
        const colors = colorPalettes[colorPalette] || colorPalettes.default;
        
        // Detectar colunas para usar nos gráficos
        const dateKey = Object.keys(filteredData[0]).find(key => 
            key.toLowerCase().includes('data')
        );
        
        const valueKey = Object.keys(filteredData[0]).find(key => 
            key.toLowerCase().includes('valor') || 
            key.toLowerCase().includes('quant') ||
            key.toLowerCase().includes('total') ||
            key.toLowerCase().includes('preco')
        );
        
        const deptKey = Object.keys(filteredData[0]).find(key => 
            key.toLowerCase().includes('depart') || 
            key.toLowerCase().includes('setor') ||
            key.toLowerCase().includes('dept')
        );
        
        // Atualizar gráfico principal (por departamento ou categoria)
        if (deptKey && valueKey && charts.mainChart) {
            // Agrupar por departamento
            const deptData = {};
            filteredData.forEach(item => {
                const dept = item[deptKey];
                const value = typeof item[valueKey] === 'string' 
                            ? parseFloat(item[valueKey].replace(/[^\d.,]/g, '').replace(',', '.')) 
                            : item[valueKey] || 0;
                deptData[dept] = (deptData[dept] || 0) + value;
            });
            
            // Ordenar por valor
            const sortedDeptEntries = Object.entries(deptData).sort((a, b) => b[1] - a[1]);
            const labels = sortedDeptEntries.map(entry => entry[0]);
            const data = sortedDeptEntries.map(entry => entry[1]);
            
            // Limitar a 10 departamentos para melhor visualização
            const maxItems = 10;
            const displayLabels = labels.slice(0, maxItems);
            const displayData = data.slice(0, maxItems);
            
            // Atualizar gráfico principal
            charts.mainChart.data.labels = displayLabels;
            charts.mainChart.data.datasets[0].data = displayData;
            charts.mainChart.data.datasets[0].backgroundColor = colors.map((color, index) => 
                color.includes('rgba') ? color : `${color}80`
            );
            charts.mainChart.data.datasets[0].borderColor = colors;
            charts.mainChart.options.plugins.title.text = `Distribuição por ${deptKey}`;
            charts.mainChart.update();
            
            // Atualizar gráfico de pizza no departamento
            if (charts.departmentChart) {
                charts.departmentChart.data.labels = displayLabels;
                charts.departmentChart.data.datasets[0].data = displayData;
                charts.departmentChart.data.datasets[0].backgroundColor = colors;
                charts.departmentChart.options.plugins.title.text = `Distribuição por ${deptKey}`;
                charts.departmentChart.update();
            }
        }
        
        // Atualizar gráfico secundário (tendência temporal)
        if (dateKey && valueKey && charts.secondaryChart) {
            // Organizar dados por data
            const timeData = {};
            
            filteredData.forEach(item => {
                let date = item[dateKey];
                
                // Converter para data se for string
                if (typeof date === 'string') {
                    date = new Date(date);
                }
                
                if (date instanceof Date && !isNaN(date)) {
                    // Formatar como ano-mês para agrupamento
                    const dateStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    
                    const value = typeof item[valueKey] === 'string' 
                                ? parseFloat(item[valueKey].replace(/[^\d.,]/g, '').replace(',', '.')) 
                                : (item[valueKey] || 0);
                    
                    timeData[dateStr] = (timeData[dateStr] || 0) + value;
                }
            });
            
            // Ordenar por data
            const sortedDates = Object.keys(timeData).sort();
            
            // Formatar labels para exibição
            const labels = sortedDates.map(date => {
                const [year, month] = date.split('-');
                const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
                return `${monthNames[parseInt(month) - 1]}/${year}`;
            });
            
            const data = sortedDates.map(date => timeData[date]);
            
            // Atualizar gráfico secundário
            charts.secondaryChart.data.labels = labels;
            charts.secondaryChart.data.datasets[0].data = data;
            charts.secondaryChart.data.datasets[0].borderColor = colors[1];
            charts.secondaryChart.data.datasets[0].backgroundColor = `${colors[1]}20`;
            charts.secondaryChart.options.plugins.title.text = `Evolução Temporal (${valueKey})`;
            charts.secondaryChart.update();
            
            // Atualizar gráfico de tendência na aba de estatísticas
            if (charts.trendChart) {
                charts.trendChart.data.labels = labels;
                charts.trendChart.data.datasets[0].data = data;
                charts.trendChart.data.datasets[0].borderColor = colors[2];
                charts.trendChart.data.datasets[0].backgroundColor = `${colors[2]}20`;
                charts.trendChart.options.plugins.title.text = `Tendência por Período (${valueKey})`;
                charts.trendChart.update();
            }
            
            // Atualizar gráficos de análise de tendência
            if (charts.trendAnalysisChart) {
                charts.trendAnalysisChart.data.labels = labels;
                charts.trendAnalysisChart.data.datasets[0].data = data;
                charts.trendAnalysisChart.data.datasets[0].borderColor = colors[2];
                
                // Calcular linha de tendência simples
                if (data.length > 1) {
                    const trend = calculateTrendLine(data);
                    const trendData = Array.from({length: data.length}, (_, i) => trend.slope * i + trend.intercept);
                    charts.trendAnalysisChart.data.datasets[1].data = trendData;
                    charts.trendAnalysisChart.data.datasets[1].borderColor = colors[4];
                }
                charts.trendAnalysisChart.update();
            }
            
            // Gráfico de previsão
            if (charts.forecastChart) {
                charts.forecastChart.data.labels = [...labels];
                charts.forecastChart.data.datasets[0].data = data;
                charts.forecastChart.data.datasets[0].borderColor = colors[2];
                
                // Calcular previsão simples
                if (data.length > 2) {
                    // Usar linha de tendência para previsão
                    const trend = calculateTrendLine(data);
                    
                    // Adicionar 3 meses de previsão
                    const forecast = [];
                    const n = data.length;
                    
                    for (let i = 1; i <= 3; i++) {
                        const nextValue = trend.slope * (n + i - 1) + trend.intercept;
                        forecast.push(nextValue > 0 ? nextValue : 0); // Evitar valores negativos
                    }
                    
                    // Adicionar novos meses para previsão
                    const lastDate = sortedDates[sortedDates.length - 1];
                    const [lastYear, lastMonth] = lastDate.split('-').map(n => parseInt(n));
                    
                    const forecastLabels = [];
                    for (let i = 1; i <= 3; i++) {
                        let nextMonth = lastMonth + i;
                        let nextYear = lastYear;
                        
                        if (nextMonth > 12) {
                            nextMonth -= 12;
                            nextYear += 1;
                        }
                        
                        const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
                        forecastLabels.push(`${monthNames[nextMonth - 1]}/${nextYear}`);
                    }
                    
                    // Atualizar gráfico de previsão
                    charts.forecastChart.data.labels = [...labels, ...forecastLabels];
                    
                    // Ajustar os dados para visualização
                    charts.forecastChart.data.datasets[0].data = [...data, ...Array(3).fill(null)];
                    charts.forecastChart.data.datasets[1].data = [...Array(data.length).fill(null), ...forecast];
                    charts.forecastChart.data.datasets[1].borderColor = colors[4];
                    charts.forecastChart.data.datasets[1].backgroundColor = `${colors[4]}20`;
                    
                    charts.forecastChart.update();
                }
            }
        }
        
        // Atualizar gráfico de correlação
        if (filteredData.length > 0 && charts.correlationChart) {
            // Identificar duas variáveis numéricas para correlação
            const numericKeys = Object.keys(filteredData[0]).filter(key => {
                // Verificar se a coluna tem valores numéricos
                const numericValues = filteredData.map(item => {
                    if (typeof item[key] === 'number') return item[key];
                    if (typeof item[key] === 'string') {
                        return parseFloat(item[key].replace(/[^\d.,\-]/g, '').replace(',', '.'));
                    }
                    return NaN;
                }).filter(v => !isNaN(v));
                
                return numericValues.length > filteredData.length / 2;
            });
            
            if (numericKeys.length >= 2) {
                const xKey = numericKeys[0];
                const yKey = numericKeys[1];
                
                const correlationData = filteredData.map(item => {
                    let x = typeof item[xKey] === 'string' 
                            ? parseFloat(item[xKey].replace(/[^\d.,\-]/g, '').replace(',', '.')) 
                            : item[xKey];
                    
                    let y = typeof item[yKey] === 'string' 
                            ? parseFloat(item[yKey].replace(/[^\d.,\-]/g, '').replace(',', '.')) 
                            : item[yKey];
                    
                    if (isNaN(x) || isNaN(y)) return null;
                    return {x, y};
                }).filter(Boolean);
                
                // Atualizar gráfico de correlação
                charts.correlationChart.data.datasets[0].data = correlationData;
                charts.correlationChart.options.scales.x.title.text = xKey;
                charts.correlationChart.options.scales.y.title.text = yKey;
                charts.correlationChart.data.datasets[0].backgroundColor = colors[5];
                
                // Calcular e exibir coeficiente de correlação
                if (correlationData.length > 1) {
                    const correlation = calculateCorrelation(correlationData);
                    const interpretation = interpretCorrelation(correlation);
                    
                    // Adicionar linha de regressão se houver correlação significativa
                    if (Math.abs(correlation) > 0.3) {
                        const regression = calculateRegressionLine(correlationData);
                        
                        // Ordenar pontos para x
                        const xValues = correlationData.map(point => point.x).sort((a, b) => a - b);
                        const minX = xValues[0];
                        const maxX = xValues[xValues.length - 1];
                        
                        // Calcular pontos da linha
                        const startY = regression.slope * minX + regression.intercept;
                        const endY = regression.slope * maxX + regression.intercept;
                        
                        // Adicionar dataset de linha de regressão
                        if (charts.correlationChart.data.datasets.length === 1) {
                            charts.correlationChart.data.datasets.push({
                                type: 'line',
                                label: 'Linha de Regressão',
                                data: [
                                    { x: minX, y: startY },
                                    { x: maxX, y: endY }
                                ],
                                borderColor: colors[4],
                                borderWidth: 2,
                                pointRadius: 0,
                                fill: false
                            });
                        } else {
                            charts.correlationChart.data.datasets[1].data = [
                                { x: minX, y: startY },
                                { x: maxX, y: endY }
                            ];
                            charts.correlationChart.data.datasets[1].borderColor = colors[4];
                        }
                    } else if (charts.correlationChart.data.datasets.length > 1) {
                        // Remover linha de regressão se correlação fraca
                        charts.correlationChart.data.datasets.pop();
                    }
                    
                    // Atualizar texto de correlação
                    document.getElementById('correlationSummary').innerHTML = `
                        <div class="card" style="margin-bottom: 15px;">
                            <h3 style="margin-bottom: 10px;">Análise de Correlação</h3>
                            <p><strong>Variáveis:</strong> ${xKey} vs ${yKey}</p>
                            <p><strong>Coeficiente de Correlação:</strong> ${correlation.toFixed(2)}</p>
                            <p><strong>Interpretação:</strong> ${interpretation}</p>
                            ${Math.abs(correlation) > 0.5 ? 
                                `<p><strong>Equação da Reta:</strong> y = ${regression.slope.toFixed(2)}x + ${regression.intercept.toFixed(2)}</p>` : ''}
                            <p style="margin-top: 10px;">${getCorrelationExplanation(correlation, xKey, yKey)}</p>
                        </div>
                    `;
                }
                
                charts.correlationChart.update();
            }
        }
        
        logDebug("Gráficos atualizados com sucesso");
    } catch (error) {
        console.error("Erro ao atualizar gráficos:", error);
        showError(`Erro ao atualizar gráficos: ${error.message}`);
        logDebug(`ERRO ao atualizar gráficos: ${error.message}`);
    }
}

function updateStatistics() {
    if (!filteredData || filteredData.length === 0) return;
    
    try {
        logDebug("Atualizando estatísticas...");
        
        // Identificar colunas numéricas
        const numericColumns = Object.keys(filteredData[0]).filter(key => {
            const numericValues = filteredData.map(item => {
                if (typeof item[key] === 'number') return item[key];
                if (typeof item[key] === 'string') {
                    return parseFloat(item[key].replace(/[^\d.,\-]/g, '').replace(',', '.'));
                }
                return NaN;
            }).filter(v => !isNaN(v));
            
            return numericValues.length > filteredData.length / 2;
        });
        
        // Calcular estatísticas para colunas numéricas
        const statistics = numericColumns.map(col => {
            const values = filteredData.map(item => {
                if (typeof item[col] === 'number') return item[col];
                if (typeof item[col] === 'string') {
                    return parseFloat(item[col].replace(/[^\d.,\-]/g, '').replace(',', '.'));
                }
                return NaN;
            }).filter(v => !isNaN(v));
            
            if (values.length === 0) return null;
            
            // Calcular estatísticas básicas
            const sum = values.reduce((acc, val) => acc + val, 0);
            const mean = sum / values.length;
            
            // Ordenar para mediana e percentis
            const sorted = [...values].sort((a, b) => a - b);
            const median = sorted.length % 2 === 0 
                          ? (sorted[sorted.length / 2 - 1] + sorted[sorted.length / 2]) / 2 
                          : sorted[Math.floor(sorted.length / 2)];
            
            const min = sorted[0];
            const max = sorted[sorted.length - 1];
            
            // Desvio padrão
            const squaredDiffs = values.map(v => Math.pow(v - mean, 2));
            const variance = squaredDiffs.reduce((acc, val) => acc + val, 0) / values.length;
            const stdDev = Math.sqrt(variance);
            
            // Coeficiente de variação
            const cv = (stdDev / mean) * 100;
            
            // Quartis
            const q1Index = Math.floor(sorted.length * 0.25);
            const q3Index = Math.floor(sorted.length * 0.75);
            const q1 = sorted[q1Index];
            const q3 = sorted[q3Index];
            
            return {
                column: col,
                count: values.length,
                min,
                max,
                sum,
                mean,
                median,
                q1,
                q3,
                stdDev,
                variance,
                cv,
                isMonetary: col.toLowerCase().includes('valor') || col.toLowerCase().includes('preco')
            };
        }).filter(Boolean);
        
        // Exibir estatísticas
        const statisticsSummary = document.getElementById('statisticsSummary');
        statisticsSummary.innerHTML = '';
        
        statistics.forEach(stat => {
            const formatter = new Intl.NumberFormat('pt-BR', {
                style: stat.isMonetary ? 'currency' : 'decimal',
                currency: 'BRL',
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            });
            
            const format = (val) => {
                return formatter.format(val);
            };
            
            const percentFormatter = new Intl.NumberFormat('pt-BR', {
                style: 'percent',
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            });
            
            const statDiv = document.createElement('div');
            statDiv.className = 'card';
            statDiv.style.marginBottom = '20px';
            statDiv.innerHTML = `
                <h3 style="margin-bottom: 15px;">${stat.column}</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                    <div>
                        <p><strong>Contagem:</strong> ${stat.count.toLocaleString('pt-BR')}</p>
                        <p><strong>Soma:</strong> ${format(stat.sum)}</p>
                        <p><strong>Média:</strong> ${format(stat.mean)}</p>
                        <p><strong>Mediana:</strong> ${format(stat.median)}</p>
                    </div>
                    <div>
                        <p><strong>Mínimo:</strong> ${format(stat.min)}</p>
                        <p><strong>1º Quartil:</strong> ${format(stat.q1)}</p>
                        <p><strong>3º Quartil:</strong> ${format(stat.q3)}</p>
                        <p><strong>Máximo:</strong> ${format(stat.max)}</p>
                    </div>
                    <div>
                        <p><strong>Desvio Padrão:</strong> ${format(stat.stdDev)}</p>
                        <p><strong>Variância:</strong> ${format(stat.variance)}</p>
                        <p><strong>Amplitude:</strong> ${format(stat.max - stat.min)}</p>
                        <p><strong>Coef. Variação:</strong> ${percentFormatter.format(stat.cv / 100)}</p>
                    </div>
                </div>
                <div style="margin-top: 15px;">
                    <canvas id="histogram-${stat.column.replace(/\s+/g, '-').toLowerCase()}" height="150"></canvas>
                </div>
            `;
            
            statisticsSummary.appendChild(statDiv);
            
            // Criar histograma
            setTimeout(() => {
                createHistogram(stat);
            }, 50);
        });
        
        logDebug("Estatísticas atualizadas com sucesso");
    } catch (error) {
        console.error("Erro ao atualizar estatísticas:", error);
        logDebug(`ERRO ao atualizar estatísticas: ${error.message}`);
    }
}

function createHistogram(stat) {
    try {
        const canvasId = `histogram-${stat.column.replace(/\s+/g, '-').toLowerCase()}`;
        const canvas = document.getElementById(canvasId);
        
        if (!canvas) return;
        
        // Coletar valores para o histograma
        const values = filteredData.map(item => {
            if (typeof item[stat.column] === 'number') return item[stat.column];
            if (typeof item[stat.column] === 'string') {
                return parseFloat(item[stat.column].replace(/[^\d.,\-]/g, '').replace(',', '.'));
            }
            return NaN;
        }).filter(v => !isNaN(v));
        
        if (values.length === 0) return;
        
        // Calcular número de bins (Regra de Sturges)
        const numBins = Math.ceil(Math.log2(values.length)) + 1;
        
        // Calcular limites dos bins
        const min = Math.min(...values);
        const max = Math.max(...values);
        const binWidth = (max - min) / numBins;
        
        // Criar bins
        const bins = Array(numBins).fill(0);
        const binLabels = [];
        
        for (let i = 0; i < numBins; i++) {
            const lowerBound = min + i * binWidth;
            const upperBound = lowerBound + binWidth;
            binLabels.push(formatValue(lowerBound, stat.isMonetary) + ' - ' + formatValue(upperBound, stat.isMonetary));
        }
        
        // Contar ocorrências em cada bin
        values.forEach(value => {
            if (value === max) {
                bins[numBins - 1]++;
            } else {
                const binIndex = Math.floor((value - min) / binWidth);
                bins[binIndex]++;
            }
        });
        
        // Criar histograma
        new Chart(canvas.getContext('2d'), {
            type: 'bar',
            data: {
                labels: binLabels,
                datasets: [{
                    label: 'Frequência',
                    data: bins,
                    backgroundColor: 'rgba(67, 97, 238, 0.5)',
                    borderColor: 'rgba(67, 97, 238, 1)',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Frequência'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: stat.column
                        },
                        ticks: {
                            maxRotation: 45,
                            minRotation: 45
                        }
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: `Distribuição de ${stat.column}`,
                        font: {
                            size: 14
                        }
                    },
                    legend: {
                        display: false
                    }
                }
            }
        });
    } catch (error) {
        console.error("Erro ao criar histograma:", error);
        logDebug(`ERRO ao criar histograma: ${error.message}`);
    }
}

function formatValue(value, isMonetary) {
    const formatter = new Intl.NumberFormat('pt-BR', {
        style: isMonetary ? 'currency' : 'decimal',
        currency: 'BRL',
        maximumFractionDigits: 0
    });
    
    return formatter.format(value);
}

function updateAnalysis() {
    // Esta função já está coberta pela atualização dos gráficos
    // É chamada quando a aba de análises é exibida
    logDebug("Atualizando análises...");
}

function generateReport() {
    if (!filteredData || filteredData.length === 0) {
        showError('Não há dados disponíveis para gerar o relatório.');
        return;
    }
    
    logDebug("Gerando relatório...");
    
    try {
        const reportType = document.getElementById('reportType').value;
        const reportFormat = document.getElementById('reportFormat').value;
        const reportBody = document.getElementById('reportBody');
        const reportTitle = document.getElementById('reportTitle');
        
        // Mostrar loader
        showLoader();
        
        // Gerar título
        switch (reportType) {
            case 'mensal':
                reportTitle.textContent = 'Relatório Mensal';
                break;
            case 'departamento':
                reportTitle.textContent = 'Relatório por Departamento';
                break;
            case 'status':
                reportTitle.textContent = 'Relatório por Status';
                break;
            case 'completo':
                reportTitle.textContent = 'Relatório Completo';
                break;
        }
        
        // Início do HTML do relatório
        let reportHTML = '';
        
        // Identificar colunas-chave
        const dateKey = Object.keys(filteredData[0]).find(key => 
            key.toLowerCase().includes('data')
        );
        
        const valueKey = Object.keys(filteredData[0]).find(key => 
            key.toLowerCase().includes('valor') || 
            key.toLowerCase().includes('quant') ||
            key.toLowerCase().includes('total') ||
            key.toLowerCase().includes('preco')
        );
        
        const deptKey = Object.keys(filteredData[0]).find(key => 
            key.toLowerCase().includes('depart') || 
            key.toLowerCase().includes('setor') ||
            key.toLowerCase().includes('dept')
        );
        
        const statusKey = Object.keys(filteredData[0]).find(key => 
            key.toLowerCase().includes('status') || 
            key.toLowerCase().includes('situacao')
        );
        
        // Formatter para valores monetários
        const formatter = new Intl.NumberFormat('pt-BR', {
            style: 'currency',
            currency: 'BRL'
        });
        
        switch (reportType) {
            case 'mensal':
                if (dateKey && valueKey) {
                    // Agrupar por mês
                    const monthlyData = {};
                    
                    filteredData.forEach(item => {
                        let date = item[dateKey];
                        if (typeof date === 'string') {
                            date = new Date(date);
                        }
                        
                        if (date instanceof Date && !isNaN(date)) {
                            const monthStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                            const value = typeof item[valueKey] === 'string' 
                                        ? parseFloat(item[valueKey].replace(/[^\d.,]/g, '').replace(',', '.')) 
                                        : (item[valueKey] || 0);
                            
                            monthlyData[monthStr] = {
                                total: (monthlyData[monthStr]?.total || 0) + value,
                                count: (monthlyData[monthStr]?.count || 0) + 1
                            };
                        }
                    });
                    
                    // Ordenar por data
                    const sortedMonths = Object.keys(monthlyData).sort();
                    
                    // Adicionar informações do relatório
                    reportHTML += `
                        <div class="card" style="margin-bottom: 20px;">
                            <h3>Informações do Relatório</h3>
                            <p><strong>Tipo:</strong> Relatório Mensal</p>
                            <p><strong>Período:</strong> ${sortedMonths.length > 0 ? 
                                `${formatMonthYear(sortedMonths[0])} a ${formatMonthYear(sortedMonths[sortedMonths.length-1])}` : 
                                'Todos os períodos'}
                            </p>
                            <p><strong>Total de Registros:</strong> ${filteredData.length}</p>
                            <p><strong>Data de Geração:</strong> ${new Date().toLocaleDateString('pt-BR')} ${new Date().toLocaleTimeString('pt-BR')}</p>
                        </div>
                    `;
                    
                    // Criar tabela de relatório
                    if (reportFormat === 'tabela' || reportFormat === 'ambos') {
                        reportHTML += `
                            <div class="card" style="margin-bottom: 20px;">
                                <h3>Resumo Mensal</h3>
                                <div style="overflow-x: auto;">
                                    <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                                        <thead>
                                            <tr>
                                                <th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: left;">Mês</th>
                                                <th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: right;">Total</th>
                                                <th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: right;">Quantidade</th>
                                                <th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: right;">Média</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                        `;
                        
                        // Calcular totais gerais
                        let grandTotal = 0;
                        let grandCount = 0;
                        
                        sortedMonths.forEach(month => {
                            const data = monthlyData[month];
                            grandTotal += data.total;
                            grandCount += data.count;
                            
                            reportHTML += `
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd;">${formatMonthYear(month)}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatter.format(data.total)}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${data.count}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatter.format(data.total / data.count)}</td>
                                </tr>
                            `;
                        });
                        
                        // Adicionar linha de total
                        reportHTML += `
                                <tr style="font-weight: bold; background: #f9f9f9;">
                                    <td style="padding: 10px; border: 1px solid #ddd;">TOTAL</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatter.format(grandTotal)}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${grandCount}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatter.format(grandTotal / grandCount)}</td>
                                </tr>
                            </tbody>
                        </table>
                        </div>
                        </div>
                        `;
                    }
                    
                    // Criar gráfico
                    if (reportFormat === 'grafico' || reportFormat === 'ambos') {
                        reportHTML += `
                            <div class="card" style="margin-bottom: 20px;">
                                <h3>Gráfico Mensal</h3>
                                <div style="height: 400px; margin-top: 20px;">
                                    <canvas id="reportMonthlyChart"></canvas>
                                </div>
                            </div>
                        `;
                    }
                } else {
                    reportHTML = '<div class="card"><p>Não foi possível identificar colunas de data ou valor para gerar o relatório mensal.</p></div>';
                }
                break;
                
            case 'departamento':
                if (deptKey && valueKey) {
                    // Agrupar por departamento
                    const deptData = {};
                    
                    filteredData.forEach(item => {
                        const dept = item[deptKey];
                        const value = typeof item[valueKey] === 'string' 
                                    ? parseFloat(item[valueKey].replace(/[^\d.,]/g, '').replace(',', '.')) 
                                    : (item[valueKey] || 0);
                        
                        deptData[dept] = deptData[dept] || { total: 0, count: 0 };
                        deptData[dept].total += value;
                        deptData[dept].count += 1;
                    });
                    
                    // Ordenar por valor total (decrescente)
                    const sortedDepts = Object.keys(deptData).sort((a, b) => 
                        deptData[b].total - deptData[a].total
                    );
                    
                    // Adicionar informações do relatório
                    reportHTML += `
                        <div class="card" style="margin-bottom: 20px;">
                            <h3>Informações do Relatório</h3>
                            <p><strong>Tipo:</strong> Relatório por Departamento</p>
                            <p><strong>Total de Departamentos:</strong> ${sortedDepts.length}</p>
                            <p><strong>Total de Registros:</strong> ${filteredData.length}</p>
                            <p><strong>Data de Geração:</strong> ${new Date().toLocaleDateString('pt-BR')} ${new Date().toLocaleTimeString('pt-BR')}</p>
                        </div>
                    `;
                    
                    // Criar tabela de relatório
                    if (reportFormat === 'tabela' || reportFormat === 'ambos') {
                        reportHTML += `
                            <div class="card" style="margin-bottom: 20px;">
                                <h3>Resumo por Departamento</h3>
                                <div style="overflow-x: auto;">
                                    <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                                        <thead>
                                            <tr>
                                                <th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: left;">Departamento</th>
                                                <th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: right;">Total</th>
                                                <th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: right;">Quantidade</th>
                                                <th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: right;">Média</th>
                                                <th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: right;">% do Total</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                        `;
                        
                        // Calcular total geral
                        const grandTotal = sortedDepts.reduce((sum, dept) => sum + deptData[dept].total, 0);
                        const grandCount = sortedDepts.reduce((sum, dept) => sum + deptData[dept].count, 0);
                        
                        sortedDepts.forEach(dept => {
                            const data = deptData[dept];
                            const percentage = (data.total / grandTotal) * 100;
                            
                            reportHTML += `
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd;">${dept}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatter.format(data.total)}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${data.count}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatter.format(data.total / data.count)}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${percentage.toFixed(2)}%</td>
                                </tr>
                            `;
                        });
                        
                        // Adicionar linha de total
                        reportHTML += `
                                <tr style="font-weight: bold; background: #f9f9f9;">
                                    <td style="padding: 10px; border: 1px solid #ddd;">TOTAL</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatter.format(grandTotal)}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${grandCount}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatter.format(grandTotal / grandCount)}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">100.00%</td>
                                </tr>
                            </tbody>
                        </table>
                        </div>
                        </div>
                        `;
                    }
                    
                    // Criar gráfico
                    if (reportFormat === 'grafico' || reportFormat === 'ambos') {
                        reportHTML += `
                            <div class="card" style="margin-bottom: 20px;">
                                <h3>Gráfico por Departamento</h3>
                                <div class="report-charts" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px; margin-top: 20px;">
                                    <div style="height: 400px;">
                                        <canvas id="reportDeptBarChart"></canvas>
                                    </div>
                                    <div style="height: 400px;">
                                        <canvas id="reportDeptPieChart"></canvas>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                } else {
                    reportHTML = '<div class="card"><p>Não foi possível identificar colunas de departamento ou valor para gerar o relatório.</p></div>';
                }
                break;
                
            case 'status':
                if (statusKey) {
                    // Agrupar por status
                    const statusData = {};
                    
                    filteredData.forEach(item => {
                        const status = item[statusKey];
                        statusData[status] = statusData[status] || { count: 0 };
                        statusData[status].count += 1;
                        
                        // Se tiver valor, também somar
                        if (valueKey) {
                            const value = typeof item[valueKey] === 'string' 
                                        ? parseFloat(item[valueKey].replace(/[^\d.,]/g, '').replace(',', '.')) 
                                        : (item[valueKey] || 0);
                            
                            statusData[status].total = (statusData[status].total || 0) + value;
                        }
                    });
                    
                    // Ordenar por contagem (decrescente)
                    const sortedStatus = Object.keys(statusData).sort((a, b) => 
                        statusData[b].count - statusData[a].count
                    );
                    
                    // Adicionar informações do relatório
                    reportHTML += `
                        <div class="card" style="margin-bottom: 20px;">
                            <h3>Informações do Relatório</h3>
                            <p><strong>Tipo:</strong> Relatório por Status</p>
                            <p><strong>Total de Status:</strong> ${sortedStatus.length}</p>
                            <p><strong>Total de Registros:</strong> ${filteredData.length}</p>
                            <p><strong>Data de Geração:</strong> ${new Date().toLocaleDateString('pt-BR')} ${new Date().toLocaleTimeString('pt-BR')}</p>
                        </div>
                    `;
                    
                    // Criar tabela de relatório
                    if (reportFormat === 'tabela' || reportFormat === 'ambos') {
                        reportHTML += `
                            <div class="card" style="margin-bottom: 20px;">
                                <h3>Resumo por Status</h3>
                                <div style="overflow-x: auto;">
                                    <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                                        <thead>
                                            <tr>
                                                <th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: left;">Status</th>
                                                <th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: right;">Quantidade</th>
                                                <th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: right;">% do Total</th>
                                                ${valueKey ? `<th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: right;">Valor Total</th>` : ''}
                                            </tr>
                                        </thead>
                                        <tbody>
                        `;
                        
                        // Calcular total geral
                        const totalCount = filteredData.length;
                        const totalValue = valueKey ? 
                            sortedStatus.reduce((sum, status) => sum + (statusData[status].total || 0), 0) : 0;
                        
                        sortedStatus.forEach(status => {
                            const data = statusData[status];
                            const percentage = (data.count / totalCount) * 100;
                            
                            let statusDisplay = status;
                            // Adicionar badge para status
                            const statusText = String(status).toLowerCase();
                            let badgeClass = '';
                            
                            if (statusText.includes('comple') || statusText.includes('conclu') || 
                                statusText.includes('finaliz') || statusText.includes('ok') ||
                                statusText.includes('feito')) {
                                badgeClass = 'badge badge-success';
                            } else if (statusText.includes('pend') || statusText.includes('aberto') || 
                                     statusText.includes('process') || statusText.includes('andamento')) {
                                badgeClass = 'badge badge-warning';
                            } else if (statusText.includes('cancel') || statusText.includes('erro') || 
                                     statusText.includes('falha')) {
                                badgeClass = 'badge badge-danger';
                            }
                            
                            if (badgeClass) {
                                statusDisplay = `<span class="${badgeClass}">${status}</span>`;
                            }
                            
                            reportHTML += `
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd;">${statusDisplay}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${data.count}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${percentage.toFixed(2)}%</td>
                                    ${valueKey ? `<td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatter.format(data.total || 0)}</td>` : ''}
                                </tr>
                            `;
                        });
                        
                        // Adicionar linha de total
                        reportHTML += `
                                <tr style="font-weight: bold; background: #f9f9f9;">
                                    <td style="padding: 10px; border: 1px solid #ddd;">TOTAL</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${totalCount}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">100.00%</td>
                                    ${valueKey ? `<td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatter.format(totalValue)}</td>` : ''}
                                </tr>
                            </tbody>
                        </table>
                        </div>
                        </div>
                        `;
                    }
                    
                    // Criar gráfico
                    if (reportFormat === 'grafico' || reportFormat === 'ambos') {
                        reportHTML += `
                            <div class="card" style="margin-bottom: 20px;">
                                <h3>Gráfico por Status</h3>
                                <div style="height: 400px; margin-top: 20px;">
                                    <canvas id="reportStatusChart"></canvas>
                                </div>
                            </div>
                        `;
                    }
                } else {
                    reportHTML = '<div class="card"><p>Não foi possível identificar uma coluna de status para gerar o relatório.</p></div>';
                }
                break;
                
            case 'completo':
                // Relatório completo com resumo geral
                reportHTML += `
                    <div class="card" style="margin-bottom: 20px;">
                        <h3>Informações do Relatório</h3>
                        <p><strong>Tipo:</strong> Relatório Completo</p>
                        <p><strong>Total de Registros:</strong> ${filteredData.length}</p>
                        <p><strong>Data de Geração:</strong> ${new Date().toLocaleDateString('pt-BR')} ${new Date().toLocaleTimeString('pt-BR')}</p>
                    </div>
                    
                    <div class="card" style="margin-bottom: 20px;">
                        <h3>Resumo Geral</h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0;">
                `;
                
                // Informações de contagens
                reportHTML += `
                    <div style="background: #f5f7fa; padding: 15px; border-radius: 5px; box-shadow: var(--shadow);">
                        <h4>Quantidade Total</h4>
                        <p style="font-size: 24px; font-weight: bold;">${filteredData.length.toLocaleString('pt-BR')}</p>
                    </div>
                `;
                
                // Informações de valores
                if (valueKey) {
                    const valores = filteredData.map(item => {
                        const val = item[valueKey];
                        if (typeof val === 'string') {
                            return parseFloat(val.replace(/[^\d.,]/g, '').replace(',', '.')) || 0;
                        }
                        return typeof val === 'number' ? val : 0;
                    });
                    
                    const sum = valores.reduce((acc, val) => acc + val, 0);
                    const avg = valores.length > 0 ? sum / valores.length : 0;
                    
                    reportHTML += `
                        <div style="background: #f5f7fa; padding: 15px; border-radius: 5px; box-shadow: var(--shadow);">
                            <h4>Valor Total</h4>
                            <p style="font-size: 24px; font-weight: bold;">${formatter.format(sum)}</p>
                        </div>
                        <div style="background: #f5f7fa; padding: 15px; border-radius: 5px; box-shadow: var(--shadow);">
                            <h4>Valor Médio</h4>
                            <p style="font-size: 24px; font-weight: bold;">${formatter.format(avg)}</p>
                        </div>
                    `;
                }
                
                // Informações de datas
                if (dateKey) {
                    const dates = filteredData.map(item => {
                        let date = item[dateKey];
                        if (typeof date === 'string') {
                            date = new Date(date);
                        }
                        return date instanceof Date && !isNaN(date) ? date : null;
                    }).filter(Boolean);
                    
                    if (dates.length > 0) {
                        // Ordenar datas
                        dates.sort((a, b) => b - a);
                        const latestDate = dates[0];
                        const oldestDate = dates[dates.length - 1];
                        
                        reportHTML += `
                            <div style="background: #f5f7fa; padding: 15px; border-radius: 5px; box-shadow: var(--shadow);">
                                <h4>Período</h4>
                                <p style="font-size: 18px; font-weight: bold;">${oldestDate.toLocaleDateString('pt-BR')} a ${latestDate.toLocaleDateString('pt-BR')}</p>
                            </div>
                        `;
                    }
                }
                
                // Informações de status
                if (statusKey) {
                    const statusCounts = {};
                    filteredData.forEach(item => {
                        const status = item[statusKey];
                        statusCounts[status] = (statusCounts[status] || 0) + 1;
                    });
                    
                    let completosCount = 0;
                    let pendentesCount = 0;
                    
                    Object.entries(statusCounts).forEach(([key, value]) => {
                        const lowerKey = String(key).toLowerCase();
                        if (lowerKey.includes('comple') || 
                            lowerKey.includes('conclu') ||
                            lowerKey.includes('finaliz') ||
                            lowerKey.includes('ok') ||
                            lowerKey.includes('feito')) {
                            completosCount += value;
                        } else if (lowerKey.includes('pend') || 
                                lowerKey.includes('aberto') ||
                                lowerKey.includes('em and') ||
                                lowerKey.includes('process') ||
                                lowerKey.includes('aguard')) {
                            pendentesCount += value;
                        }
                    });
                    
                    reportHTML += `
                        <div style="background: #f5f7fa; padding: 15px; border-radius: 5px; box-shadow: var(--shadow);">
                            <h4>Status</h4>
                            <p style="font-size: 18px; font-weight: bold;">
                                <span class="badge badge-success">${completosCount} Completos</span>
                                <span class="badge badge-warning" style="margin-left: 10px;">${pendentesCount} Pendentes</span>
                            </p>
                        </div>
                    `;
                }
                
                // Fechar div de resumo
                reportHTML += `
                        </div>
                    </div>
                `;
                
                // Adicionar tabelas resumidas para cada tipo de relatório
                if (reportFormat === 'tabela' || reportFormat === 'ambos') {
                    // Resumo por departamento
                    if (deptKey && valueKey) {
                        const deptData = {};
                        
                        filteredData.forEach(item => {
                            const dept = item[deptKey];
                            const value = typeof item[valueKey] === 'string' 
                                        ? parseFloat(item[valueKey].replace(/[^\d.,]/g, '').replace(',', '.')) 
                                        : (item[valueKey] || 0);
                            
// Continuação da função generateReport - Relatório completo - Resumo por departamento

deptData[dept] = deptData[dept] || { total: 0, count: 0 };
                            deptData[dept].total += value;
                            deptData[dept].count += 1;
                        });
                        
                        // Ordenar por valor total (decrescente)
                        const sortedDepts = Object.keys(deptData).sort((a, b) => 
                            deptData[b].total - deptData[a].total
                        );
                        
                        // Mostrar apenas os top 5 departamentos
                        const topDepts = sortedDepts.slice(0, 5);
                        
                        reportHTML += `
                            <div class="card" style="margin-bottom: 20px;">
                                <h3>Top 5 Departamentos</h3>
                                <div style="overflow-x: auto;">
                                    <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                                        <thead>
                                            <tr>
                                                <th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: left;">Departamento</th>
                                                <th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: right;">Total</th>
                                                <th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: right;">Quantidade</th>
                                                <th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: right;">Média</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                        `;
                        
                        topDepts.forEach(dept => {
                            const data = deptData[dept];
                            
                            reportHTML += `
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd;">${dept}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatter.format(data.total)}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${data.count}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatter.format(data.total / data.count)}</td>
                                </tr>
                            `;
                        });
                        
                        reportHTML += `
                                </tbody>
                            </table>
                            </div>
                        </div>
                        `;
                    }
                    
                    // Resumo por status
                    if (statusKey) {
                        const statusData = {};
                        
                        filteredData.forEach(item => {
                            const status = item[statusKey];
                            statusData[status] = statusData[status] || { count: 0 };
                            statusData[status].count += 1;
                            
                            if (valueKey) {
                                const value = typeof item[valueKey] === 'string' 
                                            ? parseFloat(item[valueKey].replace(/[^\d.,]/g, '').replace(',', '.')) 
                                            : (item[valueKey] || 0);
                                
                                statusData[status].total = (statusData[status].total || 0) + value;
                            }
                        });
                        
                        // Ordenar por contagem (decrescente)
                        const sortedStatus = Object.keys(statusData).sort((a, b) => 
                            statusData[b].count - statusData[a].count
                        );
                        
                        reportHTML += `
                            <div class="card" style="margin-bottom: 20px;">
                                <h3>Resumo por Status</h3>
                                <div style="overflow-x: auto;">
                                    <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                                        <thead>
                                            <tr>
                                                <th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: left;">Status</th>
                                                <th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: right;">Quantidade</th>
                                                <th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: right;">% do Total</th>
                                                ${valueKey ? `<th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: right;">Valor Total</th>` : ''}
                                            </tr>
                                        </thead>
                                        <tbody>
                        `;
                        
                        // Calcular total geral
                        const totalCount = filteredData.length;
                        const totalValue = valueKey ? 
                            sortedStatus.reduce((sum, status) => sum + (statusData[status].total || 0), 0) : 0;
                        
                        sortedStatus.forEach(status => {
                            const data = statusData[status];
                            const percentage = (data.count / totalCount) * 100;
                            
                            let statusDisplay = status;
                            // Adicionar badge para status
                            const statusText = String(status).toLowerCase();
                            let badgeClass = '';
                            
                            if (statusText.includes('comple') || statusText.includes('conclu') || 
                                statusText.includes('finaliz') || statusText.includes('ok') ||
                                statusText.includes('feito')) {
                                badgeClass = 'badge badge-success';
                            } else if (statusText.includes('pend') || statusText.includes('aberto') || 
                                     statusText.includes('process') || statusText.includes('andamento')) {
                                badgeClass = 'badge badge-warning';
                            } else if (statusText.includes('cancel') || statusText.includes('erro') || 
                                     statusText.includes('falha')) {
                                badgeClass = 'badge badge-danger';
                            }
                            
                            if (badgeClass) {
                                statusDisplay = `<span class="${badgeClass}">${status}</span>`;
                            }
                            
                            reportHTML += `
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd;">${statusDisplay}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${data.count}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${percentage.toFixed(2)}%</td>
                                    ${valueKey ? `<td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatter.format(data.total || 0)}</td>` : ''}
                                </tr>
                            `;
                        });
                        
                        reportHTML += `
                                </tbody>
                            </table>
                            </div>
                        </div>
                        `;
                    }
                    
                    // Resumo mensal
                    if (dateKey && valueKey) {
                        // Agrupar por mês
                        const monthlyData = {};
                        
                        filteredData.forEach(item => {
                            let date = item[dateKey];
                            if (typeof date === 'string') {
                                date = new Date(date);
                            }
                            
                            if (date instanceof Date && !isNaN(date)) {
                                const monthStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                                const value = typeof item[valueKey] === 'string' 
                                            ? parseFloat(item[valueKey].replace(/[^\d.,]/g, '').replace(',', '.')) 
                                            : (item[valueKey] || 0);
                                
                                monthlyData[monthStr] = {
                                    total: (monthlyData[monthStr]?.total || 0) + value,
                                    count: (monthlyData[monthStr]?.count || 0) + 1
                                };
                            }
                        });
                        
                        // Ordenar por data
                        const sortedMonths = Object.keys(monthlyData).sort();
                        
                        // Mostrar apenas os últimos 6 meses
                        const recentMonths = sortedMonths.slice(-6);
                        
                        reportHTML += `
                            <div class="card" style="margin-bottom: 20px;">
                                <h3>Evolução Mensal Recente</h3>
                                <div style="overflow-x: auto;">
                                    <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                                        <thead>
                                            <tr>
                                                <th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: left;">Mês</th>
                                                <th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: right;">Total</th>
                                                <th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: right;">Quantidade</th>
                                                <th style="padding: 10px; background: #f5f5f5; border: 1px solid #ddd; text-align: right;">Média</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                        `;
                        
                        recentMonths.forEach(month => {
                            const data = monthlyData[month];
                            
                            reportHTML += `
                                <tr>
                                    <td style="padding: 10px; border: 1px solid #ddd;">${formatMonthYear(month)}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatter.format(data.total)}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${data.count}</td>
                                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatter.format(data.total / data.count)}</td>
                                </tr>
                            `;
                        });
                        
                        reportHTML += `
                                </tbody>
                            </table>
                            </div>
                        </div>
                        `;
                    }
                }
                
                // Adicionar gráficos para o relatório completo
                if (reportFormat === 'grafico' || reportFormat === 'ambos') {
                    reportHTML += `
                        <div class="card" style="margin-bottom: 20px;">
                            <h3>Gráficos de Análise</h3>
                            <div class="report-charts" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px; margin-top: 20px;">
                                <div style="height: 400px;">
                                    <canvas id="reportCompleteDeptChart"></canvas>
                                </div>
                                <div style="height: 400px;">
                                    <canvas id="reportCompleteTimeChart"></canvas>
                                </div>
                                <div style="height: 400px;">
                                    <canvas id="reportCompleteStatusChart"></canvas>
                                </div>
                            </div>
                        </div>
                    `;
                }
                
                break;
        }
        
        // Renderizar o relatório
        reportBody.innerHTML = reportHTML;
        
        // Renderizar gráficos se necessário
        if (reportFormat === 'grafico' || reportFormat === 'ambos') {
            setTimeout(() => {
                renderReportCharts(reportType);
            }, 100);
        }
        
        logDebug("Relatório gerado com sucesso");
    } catch (error) {
        console.error('Erro ao gerar relatório:', error);
        showError(`Erro ao gerar relatório: ${error.message}`);
        logDebug(`ERRO ao gerar relatório: ${error.message}`);
    } finally {
        hideLoader();
    }
}

function renderReportCharts(reportType) {
    try {
        logDebug("Renderizando gráficos do relatório...");
        
        // Obter a paleta de cores atual
        const colorPalette = document.getElementById('colorPalette')?.value || 'default';
        const colors = colorPalettes[colorPalette] || colorPalettes.default;
        
        // Detectar colunas para usar nos gráficos
        const dateKey = Object.keys(filteredData[0]).find(key => 
            key.toLowerCase().includes('data')
        );
        
        const valueKey = Object.keys(filteredData[0]).find(key => 
            key.toLowerCase().includes('valor') || 
            key.toLowerCase().includes('quant') ||
            key.toLowerCase().includes('total') ||
            key.toLowerCase().includes('preco')
        );
        
        const deptKey = Object.keys(filteredData[0]).find(key => 
            key.toLowerCase().includes('depart') || 
            key.toLowerCase().includes('setor') ||
            key.toLowerCase().includes('dept')
        );
        
        const statusKey = Object.keys(filteredData[0]).find(key => 
            key.toLowerCase().includes('status') || 
            key.toLowerCase().includes('situacao')
        );
        
        switch (reportType) {
            case 'mensal':
                if (dateKey && valueKey) {
                    const monthlyData = {};
                    
                    filteredData.forEach(item => {
                        let date = item[dateKey];
                        if (typeof date === 'string') {
                            date = new Date(date);
                        }
                        
                        if (date instanceof Date && !isNaN(date)) {
                            const monthStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                            const value = typeof item[valueKey] === 'string' 
                                        ? parseFloat(item[valueKey].replace(/[^\d.,]/g, '').replace(',', '.')) 
                                        : (item[valueKey] || 0);
                            
                            monthlyData[monthStr] = {
                                total: (monthlyData[monthStr]?.total || 0) + value,
                                count: (monthlyData[monthStr]?.count || 0) + 1
                            };
                        }
                    });
                    
                    // Ordenar por data
                    const sortedMonths = Object.keys(monthlyData).sort();
                    
                    // Formatar para exibição
                    const labels = sortedMonths.map(month => formatMonthYear(month));
                    const data = sortedMonths.map(month => monthlyData[month].total);
                    
                    // Gráfico
                    const ctx = document.getElementById('reportMonthlyChart')?.getContext('2d');
                    if (ctx) {
                        new Chart(ctx, {
                            type: 'bar',
                            data: {
                                labels: labels,
                                datasets: [{
                                    label: `Total Mensal (${valueKey})`,
                                    data: data,
                                    backgroundColor: colors.map(color => color.includes('rgba') ? color : `${color}80`),
                                    borderColor: colors,
                                    borderWidth: 1
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        grid: {
                                            color: 'rgba(0, 0, 0, 0.05)'
                                        }
                                    },
                                    x: {
                                        grid: {
                                            display: false
                                        }
                                    }
                                },
                                plugins: {
                                    legend: {
                                        position: 'top'
                                    },
                                    title: {
                                        display: true,
                                        text: 'Evolução Mensal',
                                        font: {
                                            size: 16
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
                break;
                
            case 'departamento':
                if (deptKey && valueKey) {
                    const deptData = {};
                    
                    filteredData.forEach(item => {
                        const dept = item[deptKey];
                        const value = typeof item[valueKey] === 'string' 
                                    ? parseFloat(item[valueKey].replace(/[^\d.,]/g, '').replace(',', '.')) 
                                    : (item[valueKey] || 0);
                        
                        deptData[dept] = (deptData[dept] || 0) + value;
                    });
                    
                    // Ordenar por valor (decrescente)
                    const sortedDeptEntries = Object.entries(deptData).sort((a, b) => b[1] - a[1]);
                    
                    // Limitar a 10 departamentos
                    const topEntries = sortedDeptEntries.slice(0, 10);
                    const labels = topEntries.map(entry => entry[0]);
                    const data = topEntries.map(entry => entry[1]);
                    
                    // Gráfico de barras
                    const barCtx = document.getElementById('reportDeptBarChart')?.getContext('2d');
                    if (barCtx) {
                        new Chart(barCtx, {
                            type: 'bar',
                            data: {
                                labels: labels,
                                datasets: [{
                                    label: `Total por Departamento (${valueKey})`,
                                    data: data,
                                    backgroundColor: colors.map(color => color.includes('rgba') ? color : `${color}80`),
                                    borderColor: colors,
                                    borderWidth: 1
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        grid: {
                                            color: 'rgba(0, 0, 0, 0.05)'
                                        }
                                    },
                                    x: {
                                        grid: {
                                            display: false
                                        }
                                    }
                                },
                                plugins: {
                                    legend: {
                                        display: false
                                    },
                                    title: {
                                        display: true,
                                        text: 'Top 10 Departamentos',
                                        font: {
                                            size: 16
                                        }
                                    }
                                }
                            }
                        });
                    }
                    
                    // Gráfico de pizza
                    const pieCtx = document.getElementById('reportDeptPieChart')?.getContext('2d');
                    if (pieCtx) {
                        new Chart(pieCtx, {
                            type: 'pie',
                            data: {
                                labels: labels,
                                datasets: [{
                                    data: data,
                                    backgroundColor: colors,
                                    borderColor: '#fff',
                                    borderWidth: 2
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: {
                                    legend: {
                                        position: 'right'
                                    },
                                    title: {
                                        display: true,
                                        text: 'Distribuição por Departamento',
                                        font: {
                                            size: 16
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
                break;
                
            case 'status':
                if (statusKey) {
                    const statusData = {};
                    
                    filteredData.forEach(item => {
                        const status = item[statusKey];
                        statusData[status] = (statusData[status] || 0) + 1;
                    });
                    
                    // Ordenar por contagem (decrescente)
                    const sortedStatusEntries = Object.entries(statusData).sort((a, b) => b[1] - a[1]);
                    const labels = sortedStatusEntries.map(entry => entry[0]);
                    const data = sortedStatusEntries.map(entry => entry[1]);
                    
                    // Gráfico
                    const ctx = document.getElementById('reportStatusChart')?.getContext('2d');
                    if (ctx) {
                        new Chart(ctx, {
                            type: 'doughnut',
                            data: {
                                labels: labels,
                                datasets: [{
                                    data: data,
                                    backgroundColor: colors,
                                    borderColor: '#fff',
                                    borderWidth: 2
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: {
                                    legend: {
                                        position: 'right'
                                    },
                                    title: {
                                        display: true,
                                        text: 'Distribuição por Status',
                                        font: {
                                            size: 16
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
                break;
                
            case 'completo':
                // Gráfico de departamentos
                if (deptKey && valueKey) {
                    const deptData = {};
                    
                    filteredData.forEach(item => {
                        const dept = item[deptKey];
                        const value = typeof item[valueKey] === 'string' 
                                    ? parseFloat(item[valueKey].replace(/[^\d.,]/g, '').replace(',', '.')) 
                                    : (item[valueKey] || 0);
                        
                        deptData[dept] = (deptData[dept] || 0) + value;
                    });
                    
                    // Ordenar por valor (decrescente)
                    const sortedDeptEntries = Object.entries(deptData).sort((a, b) => b[1] - a[1]);
                    
                    // Limitar a 5 departamentos
                    const topEntries = sortedDeptEntries.slice(0, 5);
                    const labels = topEntries.map(entry => entry[0]);
                    const data = topEntries.map(entry => entry[1]);
                    
                    // Gráfico
                    const ctx = document.getElementById('reportCompleteDeptChart')?.getContext('2d');
                    if (ctx) {
                        new Chart(ctx, {
                            type: 'pie',
                            data: {
                                labels: labels,
                                datasets: [{
                                    data: data,
                                    backgroundColor: colors,
                                    borderColor: '#fff',
                                    borderWidth: 2
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: {
                                    legend: {
                                        position: 'right'
                                    },
                                    title: {
                                        display: true,
                                        text: 'Top 5 Departamentos',
                                        font: {
                                            size: 16
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
                
                // Gráfico de evolução temporal
                if (dateKey && valueKey) {
                    const timeData = {};
                    
                    filteredData.forEach(item => {
                        let date = item[dateKey];
                        if (typeof date === 'string') {
                            date = new Date(date);
                        }
                        
                        if (date instanceof Date && !isNaN(date)) {
                            const monthStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                            const value = typeof item[valueKey] === 'string' 
                                        ? parseFloat(item[valueKey].replace(/[^\d.,]/g, '').replace(',', '.')) 
                                        : (item[valueKey] || 0);
                            
                            timeData[monthStr] = (timeData[monthStr] || 0) + value;
                        }
                    });
                    
                    // Ordenar por data
                    const sortedDates = Object.keys(timeData).sort();
                    
                    // Formatar para exibição
                    const labels = sortedDates.map(date => formatMonthYear(date));
                    const data = sortedDates.map(date => timeData[date]);
                    
                    // Gráfico
                    const ctx = document.getElementById('reportCompleteTimeChart')?.getContext('2d');
                    if (ctx) {
                        new Chart(ctx, {
                            type: 'line',
                            data: {
                                labels: labels,
                                datasets: [{
                                    label: `Evolução Mensal (${valueKey})`,
                                    data: data,
                                    borderColor: colors[1],
                                    backgroundColor: `${colors[1]}20`,
                                    tension: 0.4,
                                    fill: true
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        grid: {
                                            color: 'rgba(0, 0, 0, 0.05)'
                                        }
                                    },
                                    x: {
                                        grid: {
                                            display: false
                                        }
                                    }
                                },
                                plugins: {
                                    legend: {
                                        display: false
                                    },
                                    title: {
                                        display: true,
                                        text: 'Evolução Temporal',
                                        font: {
                                            size: 16
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
                
                // Gráfico de status
                if (statusKey) {
                    const statusData = {};
                    
                    filteredData.forEach(item => {
                        const status = item[statusKey];
                        statusData[status] = (statusData[status] || 0) + 1;
                    });
                    
                    // Ordenar por contagem (decrescente)
                    const sortedStatusEntries = Object.entries(statusData).sort((a, b) => b[1] - a[1]);
                    const labels = sortedStatusEntries.map(entry => entry[0]);
                    const data = sortedStatusEntries.map(entry => entry[1]);
                    
                    // Gráfico
                    const ctx = document.getElementById('reportCompleteStatusChart')?.getContext('2d');
                    if (ctx) {
                        new Chart(ctx, {
                            type: 'doughnut',
                            data: {
                                labels: labels,
                                datasets: [{
                                    data: data,
                                    backgroundColor: colors,
                                    borderColor: '#fff',
                                    borderWidth: 2
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: {
                                    legend: {
                                        position: 'right'
                                    },
                                    title: {
                                        display: true,
                                        text: 'Distribuição por Status',
                                        font: {
                                            size: 16
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
                break;
        }
        
        logDebug("Gráficos do relatório renderizados com sucesso");
    } catch (error) {
        console.error("Erro ao renderizar gráficos do relatório:", error);
        showError(`Erro ao renderizar gráficos: ${error.message}`);
        logDebug(`ERRO ao renderizar gráficos do relatório: ${error.message}`);
    }
}

function exportReport() {
    if (!filteredData || filteredData.length === 0) {
        showError('Não há dados disponíveis para exportar.');
        return;
    }
    
    logDebug("Exportando relatório...");
    
    try {
        const reportType = document.getElementById('reportType').value;
        const reportTitle = document.getElementById('reportTitle').textContent;
        const reportBody = document.getElementById('reportBody');
        
        // Clonar o conteúdo para não alterar o original
        const contentToExport = reportBody.cloneNode(true);
        
        // Adicionar cabeçalho e título ao HTML
        const html = `
            <html>
            <head>
                <title>${reportTitle}</title>
                <style>
                    body {
                        font-family: Arial, sans-serif;
                        line-height: 1.6;
                        color: #333;
                        max-width: 1200px;
                        margin: 0 auto;
                        padding: 20px;
                    }
                    .card {
                        background: #fff;
                        border-radius: 5px;
                        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
                        margin-bottom: 20px;
                        padding: 20px;
                    }
                    h1, h2, h3 {
                        margin-top: 0;
                    }
                    table {
                        width: 100%;
                        border-collapse: collapse;
                        margin: 20px 0;
                    }
                    th, td {
                        padding: 10px;
                        border: 1px solid #ddd;
                    }
                    th {
                        background: #f5f5f5;
                        text-align: left;
                    }
                    tr:hover {
                        background: #f9f9f9;
                    }
                    .badge {
                        padding: 5px 10px;
                        border-radius: 20px;
                        font-size: 12px;
                        font-weight: 600;
                    }
                    .badge-success {
                        background: #d5f5e3;
                        color: #27ae60;
                    }
                    .badge-warning {
                        background: #fef9e7;
                        color: #f39c12;
                    }
                    .badge-danger {
                        background: #fadbd8;
                        color: #e74c3c;
                    }
                    .page-header {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        padding-bottom: 20px;
                        border-bottom: 1px solid #eee;
                        margin-bottom: 20px;
                    }
                    .page-footer {
                        margin-top: 30px;
                        padding-top: 20px;
                        border-top: 1px solid #eee;
                        text-align: center;
                        font-size: 12px;
                        color: #777;
                    }
                </style>
            </head>
            <body>
                <div class="page-header">
                    <h1>${reportTitle}</h1>
                    <div>Exportado em: ${new Date().toLocaleDateString('pt-BR')} ${new Date().toLocaleTimeString('pt-BR')}</div>
                </div>
                
                ${contentToExport.innerHTML}
                
                <div class="page-footer">
                    Relatório gerado pelo SUAD Dashboard - © ${new Date().getFullYear()}
                </div>
            </body>
            </html>
        `;
        
        // Remover canvas de gráficos (não são exportados corretamente)
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = html;
        const canvases = tempDiv.querySelectorAll('canvas');
        canvases.forEach(canvas => {
            const parent = canvas.parentNode;
            const message = document.createElement('p');
            message.innerText = 'Gráfico não disponível na versão exportada.';
            message.style.textAlign = 'center';
            message.style.padding = '50px 0';
            message.style.color = '#777';
            parent.replaceChild(message, canvas);
        });
        
        // Criar blob e download
        const blob = new Blob([tempDiv.innerHTML], { type: 'text/html' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `${reportType}_${new Date().toISOString().split('T')[0]}.html`;
        a.click();
        
        showSuccess('Relatório exportado com sucesso!');
        logDebug("Relatório exportado com sucesso");
    } catch (error) {
        console.error('Erro ao exportar relatório:', error);
        showError(`Erro ao exportar relatório: ${error.message}`);
        logDebug(`ERRO ao exportar relatório: ${error.message}`);
    }
}

function saveConfigurations() {
    try {
        logDebug("Salvando configurações...");
        
        const config = {
            theme: document.getElementById('themeSelect').value,
            itemsPerPage: parseInt(document.getElementById('itemsPerPage').value),
            dateFormat: document.getElementById('dateFormat').value,
            defaultChartType: document.getElementById('defaultChartType').value,
            colorPalette: document.getElementById('colorPalette').value,
            animations: document.getElementById('animations').value
        };
        
        localStorage.setItem('suadDashboardConfig', JSON.stringify(config));
        
        // Aplicar configurações
        applyConfigurations(config);
        
        showSuccess('Configurações salvas com sucesso!');
        logDebug("Configurações salvas com sucesso");
    } catch (error) {
        console.error('Erro ao salvar configurações:', error);
        showError(`Erro ao salvar configurações: ${error.message}`);
        logDebug(`ERRO ao salvar configurações: ${error.message}`);
    }
}

function loadConfigurations() {
    try {
        logDebug("Carregando configurações...");
        
        const savedConfig = localStorage.getItem('suadDashboardConfig');
        
        if (savedConfig) {
            const config = JSON.parse(savedConfig);
            
            // Preencher formulário de configurações
            if (config.theme) document.getElementById('themeSelect').value = config.theme;
            if (config.itemsPerPage) document.getElementById('itemsPerPage').value = config.itemsPerPage;
            if (config.dateFormat) document.getElementById('dateFormat').value = config.dateFormat;
            if (config.defaultChartType) document.getElementById('defaultChartType').value = config.defaultChartType;
            if (config.colorPalette) document.getElementById('colorPalette').value = config.colorPalette;
            if (config.animations) document.getElementById('animations').value = config.animations;
            
            // Aplicar configurações
            applyConfigurations(config);
            
            logDebug("Configurações carregadas com sucesso");
        }
    } catch (error) {
        console.error('Erro ao carregar configurações:', error);
        logDebug(`ERRO ao carregar configurações: ${error.message}`);
    }
}

function applyConfigurations(config) {
    try {
        // Aplicar tema
        document.body.className = ''; // Remover classes existentes
        if (config.theme && config.theme !== 'light') {
            document.body.classList.add(`${config.theme}-theme`);
        }
        
        // Aplicar itens por página
        if (config.itemsPerPage) {
            itemsPerPage = config.itemsPerPage;
            
            // Re-renderizar tabela se tiver dados
            if (filteredData.length > 0) {
                currentPage = 1; // Resetar para primeira página
                renderTable();
            }
        }
        
        // Aplicar animações nos gráficos
        if (config.animations) {
            Chart.defaults.animation = config.animations === 'enabled';
            
            // Atualizar gráficos existentes
            Object.values(charts).forEach(chart => {
                if (chart && chart.options) {
                    chart.options.animation = config.animations === 'enabled';
                    try {
                        chart.update();
                    } catch (e) {
                        logDebug(`Erro ao atualizar gráfico durante configuração: ${e.message}`);
                    }
                }
            });
        }
        
        // Aplicar paleta de cores
        if (config.colorPalette && colorPalettes[config.colorPalette]) {
            // Atualizar gráficos se tiver dados
            if (filteredData.length > 0) {
                updateCharts();
            }
        }
        
        logDebug("Configurações aplicadas com sucesso");
    } catch (error) {
        console.error('Erro ao aplicar configurações:', error);
        logDebug(`ERRO ao aplicar configurações: ${error.message}`);
    }
}

function loadSampleData() {
    // Exibir o loader
    showLoader();
    
    try {
        // Desabilitar temporariamente o botão para evitar cliques múltiplos
        const loadSampleBtn = document.getElementById('loadSampleBtn');
        if (loadSampleBtn) {
            loadSampleBtn.disabled = true;
            loadSampleBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Carregando...';
        }
        
        // Definir um timeout de segurança para garantir que o loader não fique preso
        const safetyTimeout = setTimeout(() => {
            hideLoader();
            if (loadSampleBtn) {
                loadSampleBtn.disabled = false;
                loadSampleBtn.innerHTML = '<i class="fas fa-magic"></i>Carregar Dados de Exemplo';
            }
            showError("Tempo limite excedido ao carregar dados de exemplo.");
        }, 10000); // 10 segundos de timeout máximo
        
        // Dados de exemplo
        const sampleData = [
            {
                ID: 1,
                Data: new Date(2023, 0, 15),
                Departamento: "Financeiro",
                Valor: 45000,
                Status: "Completo",
                Responsável: "Carlos Silva",
                Projeto: "Balanço Anual"
            },
            // ...restante dos dados de exemplo...
            {
                ID: 24,
                Data: new Date(2024, 2, 30),
                Departamento: "Desenvolvimento",
                Valor: 82000,
                Status: "Pendente",
                Responsável: "Roberto Alves",
                Projeto: "Novo Aplicativo"
            }
        ];
        
        // Simular um pequeno atraso e então processar os dados
        setTimeout(() => {
            try {
                // Limpar o timeout de segurança
                clearTimeout(safetyTimeout);
                
                // Adicionar dados de exemplo
                allData = sampleData;
                
                // Salvar no localStorage - com tratamento de erro
                try {
                    localStorage.setItem('suadDashboardData', JSON.stringify(allData));
                } catch (e) {
                    console.warn('Não foi possível salvar os dados no armazenamento local:', e);
                    // Continuar mesmo sem salvar no localStorage
                }
                
                // Processar dados com tratamento de erro
                try {
                    processData();
                } catch (e) {
                    console.error('Erro ao processar dados:', e);
                    showError(`Erro ao processar dados: ${e.message}`);
                    
                    // Garantir que o estado vazio seja mostrado em caso de erro
                    emptyState.style.display = 'flex';
                    dashboardContent.style.display = 'none';
                }
                
                // Mostrar mensagem de sucesso
                showSuccess('Dados de exemplo carregados com sucesso!');
            } catch (innerError) {
                console.error('Erro durante o processamento:', innerError);
                showError(`Erro inesperado: ${innerError.message}`);
            } finally {
                // Garantir que o loader seja escondido
                hideLoader();
                
                // Restaurar o botão
                if (loadSampleBtn) {
                    loadSampleBtn.disabled = false;
                    loadSampleBtn.innerHTML = '<i class="fas fa-magic"></i>Carregar Dados de Exemplo';
                }
            }
        }, 500);
    } catch (outerError) {
        // Tratamento de erros externos
        console.error('Erro ao iniciar carregamento de dados de exemplo:', outerError);
        showError(`Erro ao iniciar carregamento: ${outerError.message}`);
        hideLoader();
        
        // Restaurar o botão em caso de erro
        const loadSampleBtn = document.getElementById('loadSampleBtn');
        if (loadSampleBtn) {
            loadSampleBtn.disabled = false;
            loadSampleBtn.innerHTML = '<i class="fas fa-magic"></i>Carregar Dados de Exemplo';
        }
    }
}

// Funções utilitárias para cálculos estatísticos e gráficos
function calculateTrendLine(data) {
    const n = data.length;
    if (n < 2) return { slope: 0, intercept: data[0] || 0 };
    
    try {
        // Calcular médias
        let sumX = 0;
        let sumY = 0;
        for (let i = 0; i < n; i++) {
            sumX += i;
            sumY += data[i];
        }
        const meanX = sumX / n;
        const meanY = sumY / n;
        
        // Calcular coeficientes
        let numerator = 0;
        let denominator = 0;
        for (let i = 0; i < n; i++) {
            numerator += (i - meanX) * (data[i] - meanY);
            denominator += Math.pow(i - meanX, 2);
        }
        
        const slope = denominator !== 0 ? numerator / denominator : 0;
        const intercept = meanY - slope * meanX;
        
        return { slope, intercept };
    } catch (error) {
        console.error("Erro ao calcular linha de tendência:", error);
        logDebug(`ERRO ao calcular linha de tendência: ${error.message}`);
        return { slope: 0, intercept: 0 };
    }
}

function calculateCorrelation(data) {
    if (data.length < 2) return 0;
    
    try {
        // Calcular médias
        let sumX = 0;
        let sumY = 0;
        for (let i = 0; i < data.length; i++) {
            sumX += data[i].x;
            sumY += data[i].y;
        }
        const meanX = sumX / data.length;
        const meanY = sumY / data.length;
        
        // Calcular coeficiente de correlação
        let numerator = 0;
        let denominatorX = 0;
        let denominatorY = 0;
        
        for (let i = 0; i < data.length; i++) {
            const diffX = data[i].x - meanX;
            const diffY = data[i].y - meanY;
            numerator += diffX * diffY;
            denominatorX += Math.pow(diffX, 2);
            denominatorY += Math.pow(diffY, 2);
        }
        
        const denominator = Math.sqrt(denominatorX * denominatorY);
        return denominator !== 0 ? numerator / denominator : 0;
    } catch (error) {
        console.error("Erro ao calcular correlação:", error);
        logDebug(`ERRO ao calcular correlação: ${error.message}`);
        return 0;
    }
}

function calculateRegressionLine(data) {
    if (data.length < 2) return { slope: 0, intercept: data[0]?.y || 0 };
    
    try {
        // Calcular médias
        let sumX = 0;
        let sumY = 0;
        for (let i = 0; i < data.length; i++) {
            sumX += data[i].x;
            sumY += data[i].y;
        }
        const meanX = sumX / data.length;
        const meanY = sumY / data.length;
        
        // Calcular coeficientes
        let numerator = 0;
        let denominator = 0;
        for (let i = 0; i < data.length; i++) {
            numerator += (data[i].x - meanX) * (data[i].y - meanY);
            denominator += Math.pow(data[i].x - meanX, 2);
        }
        
        const slope = denominator !== 0 ? numerator / denominator : 0;
        const intercept = meanY - slope * meanX;
        
        return { slope, intercept };
    } catch (error) {
        console.error("Erro ao calcular linha de regressão:", error);
        logDebug(`ERRO ao calcular linha de regressão: ${error.message}`);
        return { slope: 0, intercept: 0 };
    }
}

function interpretCorrelation(correlation) {
    const absCorr = Math.abs(correlation);
    
    if (absCorr > 0.9) {
        return "Correlação muito forte";
    } else if (absCorr > 0.7) {
        return "Correlação forte";
    } else if (absCorr > 0.5) {
        return "Correlação moderada";
    } else if (absCorr > 0.3) {
        return "Correlação fraca";
    } else {
        return "Correlação muito fraca ou inexistente";
    }
}

function getCorrelationExplanation(correlation, xKey, yKey) {
    const absCorr = Math.abs(correlation);
    const direction = correlation > 0 ? "positiva" : "negativa";
    
    if (absCorr > 0.7) {
        return `Existe uma correlação ${direction} forte entre ${xKey} e ${yKey}, o que indica que quando um valor aumenta, o outro ${correlation > 0 ? 'também tende a aumentar' : 'tende a diminuir'}.`;
    } else if (absCorr > 0.3) {
        return `Existe uma correlação ${direction} moderada entre ${xKey} e ${yKey}, o que sugere alguma relação, mas outros fatores também são importantes.`;
    } else {
        return `A correlação entre ${xKey} e ${yKey} é fraca, indicando que não há uma relação significativa entre essas variáveis.`;
    }
}

function formatMonthYear(monthStr) {
    try {
        const [year, month] = monthStr.split('-');
        const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
        return `${monthNames[parseInt(month) - 1]}/${year}`;
    } catch (error) {
        logDebug(`Erro ao formatar mês/ano: ${error.message}`);
        return monthStr; // Retornar a string original em caso de erro
    }
}

function changeSection(section) {
    logDebug(`Alterando para seção: ${section}`);
    
    try {
        // Atualizar menu ativo
        document.querySelectorAll('.menu-item').forEach(item => {
            item.classList.remove('active');
            if (item.getAttribute('data-section') === section) {
                item.classList.add('active');
            }
        });
        
        // Detectar seções disponíveis
        const sections = {
            'dashboard': mainDashboard,
            'relatorios': relatoriosSection,
            'analises': analisesSection,
            'configuracoes': configuracoesSection
        };
        
        // Esconder todas as seções
        Object.values(sections).forEach(sect => {
            if (sect) sect.style.display = 'none';
        });
        
        // Mostrar a seção selecionada
        const sectionToShow = section === 'dashboard' ? mainDashboard : sections[section];
        if (sectionToShow) {
            sectionToShow.style.display = 'block';
            
            // Ações especiais por seção
            if (section === 'relatorios' && filteredData.length > 0) {
                // Gerar relatório automaticamente
                generateReport();
            } else if (section === 'analises' && filteredData.length > 0) {
                // Atualizar gráficos de análise
                setTimeout(() => {
                    updateCharts();
                }, 100);
            }
        } else {
            // Fallback para o dashboard principal
            mainDashboard.style.display = 'block';
            logDebug(`Seção ${section} não encontrada, exibindo dashboard principal`);
        }
    } catch (error) {
        console.error(`Erro ao mudar para seção ${section}:`, error);
        showError(`Erro ao mudar de seção: ${error.message}`);
        logDebug(`ERRO ao mudar para seção ${section}: ${error.message}`);
        
        // Fallback para o dashboard principal em caso de erro
        mainDashboard.style.display = 'block';
    }
}

function changeTab(tabId) {
    try {
        logDebug(`Alterando para tab: ${tabId}`);
        
        // Atualizar tab ativo
        document.querySelectorAll('.tab').forEach(tab => {
            tab.classList.remove('active');
            if (tab.getAttribute('data-tab') === tabId) {
                tab.classList.add('active');
            }
        });
        
        // Esconder todos os painéis de tab
        document.querySelectorAll('.tab-pane').forEach(pane => {
            pane.classList.remove('active');
        });
        
        // Mostrar o painel selecionado
        const tabPane = document.getElementById(tabId);
        if (tabPane) {
            tabPane.classList.add('active');
            
            // Atualizar gráficos se necessário
            setTimeout(() => {
                Object.values(charts).forEach(chart => {
                    if (chart && chart.canvas && chart.canvas.offsetParent !== null) {
                        try {
                            chart.resize();
                            chart.update();
                        } catch (e) {
                            logDebug(`Erro ao redimensionar gráfico: ${e.message}`);
                        }
                    }
                });
            }, 100);
        } else {
            logDebug(`Tab ${tabId} não encontrada`);
        }
    } catch (error) {
        console.error(`Erro ao mudar para tab ${tabId}:`, error);
        logDebug(`ERRO ao mudar para tab ${tabId}: ${error.message}`);
    }
}

// Inicializar os controles do Debug Panel
document.getElementById('debugPanel')?.classList.add('active');
setTimeout(() => {
    document.getElementById('debugPanel')?.classList.remove('active');
}, 3000);
    </script>
    <script>
        // Adicionar botão de emergência
        window.addEventListener('load', function() {
            setTimeout(function() {
                const emergencyButton = document.createElement('button');
                emergencyButton.textContent = "Parar Carregamento";
                emergencyButton.style.position = "fixed";
                emergencyButton.style.bottom = "10px";
                emergencyButton.style.right = "10px";
                emergencyButton.style.zIndex = "9999";
                emergencyButton.style.padding = "10px";
                emergencyButton.style.backgroundColor = "red";
                emergencyButton.style.color = "white";
                emergencyButton.style.border = "none";
                emergencyButton.style.borderRadius = "5px";
                emergencyButton.style.cursor = "pointer";
                
                emergencyButton.onclick = function() {
                    // Forçar esconder o loader
                    const loader = document.getElementById('loader');
                    if (loader) loader.classList.remove('active');
                    
                    // Mostrar estado vazio
                    const emptyState = document.getElementById('emptyState');
                    const dashboardContent = document.getElementById('dashboardContent');
                    
                    if (emptyState) emptyState.style.display = 'flex';
                    if (dashboardContent) dashboardContent.style.display = 'none';
                    
                    alert("Carregamento interrompido manualmente!");
                };
                
                document.body.appendChild(emergencyButton);
            }, 5000); // Adicionar após 5 segundos
        });
        </script>
        <script>
            // Adicione este código no final do seu arquivo HTML, antes do </body>
            (function() {
                // Criar botão de emergência com estilo mais visível
                const emergencyButton = document.createElement('button');
                emergencyButton.textContent = "PARAR CARREGAMENTO";
                emergencyButton.style.position = "fixed";
                emergencyButton.style.bottom = "20px";
                emergencyButton.style.right = "20px";
                emergencyButton.style.zIndex = "99999"; // Z-index muito alto
                emergencyButton.style.padding = "15px 20px";
                emergencyButton.style.backgroundColor = "#ff0000";
                emergencyButton.style.color = "white";
                emergencyButton.style.border = "none";
                emergencyButton.style.borderRadius = "5px";
                emergencyButton.style.cursor = "pointer";
                emergencyButton.style.fontWeight = "bold";
                emergencyButton.style.fontSize = "16px";
                emergencyButton.style.boxShadow = "0 0 10px rgba(0,0,0,0.5)";
                
                // Função de emergência - força a parada de tudo
                emergencyButton.onclick = function() {
                    // Método 1: Forçar remoção direta do loader via DOM
                    const loader = document.getElementById('loader');
                    if (loader) {
                        loader.style.display = 'none';
                        loader.classList.remove('active');
                        loader.parentNode.removeChild(loader); // Remover completamente
                    }
                    
                    // Método 2: Redefinir CSS globalmente
                    const styleElement = document.createElement('style');
                    styleElement.textContent = `
                        #loader, .loader { 
                            display: none !important; 
                            opacity: 0 !important; 
                            visibility: hidden !important;
                            pointer-events: none !important;
                        }
                        
                        .empty-state {
                            display: flex !important;
                        }
                        
                        #dashboardContent {
                            display: none !important;
                        }
                    `;
                    document.head.appendChild(styleElement);
                    
                    // Método 3: Redefinir elementos específicos de UI
                    const emptyState = document.getElementById('emptyState');
                    const dashboardContent = document.getElementById('dashboardContent');
                    
                    if (emptyState) emptyState.style.display = 'flex';
                    if (dashboardContent) dashboardContent.style.display = 'none';
                    
                    // Método 4: Cancelar todos os timeouts pendentes (última alternativa)
                    const highestTimeoutId = setTimeout(";");
                    for (let i = 0; i < highestTimeoutId; i++) {
                        clearTimeout(i);
                    }
                    
                    // Fornecer feedback ao usuário
                    alert("CARREGAMENTO INTERROMPIDO FORÇADAMENTE!\n\nAtualize a página (F5) para reiniciar o dashboard completamente.");
                    
                    // Adicionar um botão de recarregar página no emptyState
                    if (emptyState) {
                        const reloadButton = document.createElement('button');
                        reloadButton.className = 'btn btn-warning';
                        reloadButton.style.marginTop = '15px';
                        reloadButton.innerHTML = '<i class="fas fa-sync"></i> Recarregar Página';
                        reloadButton.onclick = function() {
                            location.reload();
                        };
                        emptyState.appendChild(reloadButton);
                    }
                };
                
                // Adicionar o botão ao corpo do documento
                document.body.appendChild(emergencyButton);
                
                // Adicionar também uma detecção automática de travamento
                setTimeout(function() {
                    const loader = document.getElementById('loader');
                    if (loader && loader.classList.contains('active')) {
                        // Possível travamento detectado
                        const confirmReset = confirm("O processamento parece estar demorando muito tempo. Deseja interromper?");
                        if (confirmReset) {
                            emergencyButton.click();
                        }
                    }
                }, 30000); // Verificar após 30 segundos
            })();
// Função para processar a planilha SUAD e adaptar para o formato do dashboard
// Processador Contábil Avançado para Planilha SUAD
// Função especializada para processar planilhas SUAD com análise contábil detalhada

async function processarPlanilhaSUADContabil(file) {
    try {
        showLoader();
        logDebug(`Iniciando processamento contábil da planilha SUAD: ${file.name}`);
        
        // Verificações básicas do arquivo
        if (!file) {
            throw new Error('Nenhum arquivo selecionado');
        }
        
        if (file.size > 20 * 1024 * 1024) {
            throw new Error('O arquivo é muito grande. O tamanho máximo é 20MB.');
        }
        
        // Ler o arquivo como ArrayBuffer
        const arrayBuffer = await readFileAsArrayBuffer(file);
        
        // Processar a planilha com a biblioteca XLSX
        const workbook = XLSX.read(arrayBuffer, {
            type: 'array',
            cellDates: true,
            cellNF: true,
            cellStyles: true,
            cellFormula: true, // Analisa fórmulas para entender cálculos
            WTF: true          // Captura mais detalhes para diagnóstico
        });
        
        // Verificar se o workbook foi carregado corretamente
        if (!workbook || !workbook.SheetNames || workbook.SheetNames.length === 0) {
            throw new Error('A planilha não pôde ser lida ou não contém dados válidos.');
        }
        
        logDebug(`Planilha contábil carregada com sucesso. Abas disponíveis: ${workbook.SheetNames.join(', ')}`);
        
        // Processar TODAS as abas disponíveis, dando prioridade a abas que têm termos contábeis
        const terminologiaContabil = [
            'planejado', 'executado', 'orçamento', 'despesa', 'receita', 'financeiro',
            'empenho', 'liquidação', 'pagamento', 'dotação', 'suplementação',
            'restos a pagar', 'rpnp', 'rpp', 'execução', 'ploa', 'loa', 'ppa'
        ];
        
        // Classificar abas por relevância contábil (pontuação baseada em termos contábeis)
        const abasPontuadas = workbook.SheetNames.map(aba => {
            const abaLower = aba.toLowerCase();
            // Pontuar com base em ocorrências de termos contábeis
            const pontuacao = terminologiaContabil.reduce((soma, termo) => {
                return soma + (abaLower.includes(termo) ? 1 : 0);
            }, 0);
            return { nome: aba, pontuacao };
        }).sort((a, b) => b.pontuacao - a.pontuacao); // Ordenar por pontuação
        
        // Criar lista de abas para processar (todas, mas ordenadas por relevância)
        const abasParaProcessar = abasPontuadas.map(aba => aba.nome);
        
        logDebug(`Processando ${abasParaProcessar.length} abas em ordem de relevância contábil`);
        
        // Array para armazenar todos os dados processados
        const todosDados = [];
        // Objeto para armazenar metadados de cada aba (para análise posterior)
        const metadadosAbas = {};
        
        // Processar cada planilha de acordo com sua ordem de relevância
        for (const nomeAba of abasParaProcessar) {
            try {
                const sheet = workbook.Sheets[nomeAba];
                
                // Verificar se a planilha tem conteúdo
                if (!sheet || !sheet['!ref']) {
                    logDebug(`Planilha ${nomeAba} está vazia ou tem formato inválido. Pulando...`);
                    continue;
                }
                
                // Analisar estrutura da planilha para identificar seu tipo/formato
                const tipoAba = identificarTipoAba(sheet, nomeAba);
                
                // Encontrar a linha de cabeçalho usando estratégias contábeis
                const linhaCabecalho = encontrarLinhaCabecalhoContabil(sheet, workbook, nomeAba);
                
                if (linhaCabecalho < 0) {
                    logDebug(`Não foi possível identificar a linha de cabeçalho na planilha ${nomeAba}. Pulando...`);
                    continue;
                }
                
                // Converter planilha para JSON usando a linha de cabeçalho identificada
                const dados = XLSX.utils.sheet_to_json(sheet, {
                    range: linhaCabecalho,
                    raw: false,
                    dateNF: 'yyyy-mm-dd',
                    defval: null // Usa null para células vazias
                });
                
                if (!dados || dados.length === 0) {
                    logDebug(`Planilha ${nomeAba} não contém dados após a linha de cabeçalho. Pulando...`);
                    continue;
                }
                
                logDebug(`Processando ${dados.length} registros da planilha ${nomeAba} (tipo: ${tipoAba})`);
                
                // Extrair metadados contábeis da aba
                const metadados = extrairMetadadosContabeis(dados, sheet, nomeAba);
                metadadosAbas[nomeAba] = {
                    tipo: tipoAba,
                    registros: dados.length,
                    ...metadados
                };
                
                // Normalizar dados para o formato contábil
                const dadosNormalizados = normalizarDadosContabeis(dados, nomeAba, tipoAba);
                
                // Adicionar fonte de dados para rastreabilidade
                const dadosComFonte = dadosNormalizados.map(registro => ({
                    ...registro,
                    Fonte_Aba: nomeAba,
                    Tipo_Aba: tipoAba
                }));
                
                // Adicionar dados normalizados ao conjunto total
                todosDados.push(...dadosComFonte);
                
                logDebug(`Planilha ${nomeAba} processada com sucesso: ${dadosComFonte.length} registros normalizados`);
            } catch (error) {
                logDebug(`Erro ao processar planilha ${nomeAba}: ${error.message}`);
                // Continuar para a próxima planilha
            }
        }
        
        if (todosDados.length === 0) {
            throw new Error('Não foi possível extrair dados das planilhas. Verifique o formato e tente novamente.');
        }
        
        logDebug(`Total de registros processados: ${todosDados.length}`);
        
        // Consolidar dados por tipo (planejado vs executado)
        const dadosConsolidados = consolidarDadosContabeis(todosDados, metadadosAbas);
        
        // Calcular indicadores contábeis e financeiros
        const dadosEnriquecidos = calcularIndicadoresFinanceiros(dadosConsolidados, metadadosAbas);
        
        // Salvar os dados processados e metadados no localStorage
        try {
            localStorage.setItem('suadDashboardData', JSON.stringify(dadosEnriquecidos));
            localStorage.setItem('suadDashboardMetadata', JSON.stringify({
                abas: metadadosAbas,
                processamento: {
                    data: new Date().toISOString(),
                    arquivo: file.name,
                    registros: dadosEnriquecidos.length
                }
            }));
            logDebug(`Dados contábeis e metadados salvos no localStorage com sucesso.`);
        } catch (e) {
            logDebug(`Aviso: Não foi possível salvar todos os metadados. Continuando apenas com dados principais.`);
            try {
                localStorage.setItem('suadDashboardData', JSON.stringify(dadosEnriquecidos));
            } catch (e2) {
                throw new Error(`Erro ao salvar dados: ${e2.message}. Tente novamente com um conjunto menor de dados.`);
            }
        }
        
        // Retornar os dados processados
        return dadosEnriquecidos;
    } catch (error) {
        logDebug(`ERRO no processamento contábil da planilha SUAD: ${error.message}`);
        throw error;
    } finally {
        hideLoader();
    }
}

// Função para identificar o tipo de aba baseado em seu conteúdo e estrutura
function identificarTipoAba(sheet, nomeAba) {
    // Nome da aba em minúsculo para comparações
    const abaLower = nomeAba.toLowerCase();
    
    // Verificar termos no nome da aba
    if (abaLower.includes('planejado') || abaLower.includes('orçamento') || abaLower.includes('dotação')) {
        return 'PLANEJADO';
    } else if (abaLower.includes('executado') || abaLower.includes('execução') || abaLower.includes('despesa') || abaLower.includes('empenho')) {
        return 'EXECUTADO';
    } else if (abaLower.includes('receita') || abaLower.includes('arrecadação')) {
        return 'RECEITA';
    } else if (abaLower.includes('rp') || abaLower.includes('restos')) {
        return 'RESTOS_A_PAGAR';
    }
    
    // Converter uma amostra para análise de conteúdo
    const jsonAmostra = XLSX.utils.sheet_to_json(sheet, {
        header: 1,
        raw: false,
        range: { s: {r: 0, c: 0}, e: {r: 20, c: 20} } // Primeiras 20 linhas e colunas
    });
    
    // Contar ocorrências de termos específicos
    let contadores = {
        planejado: 0,
        executado: 0,
        receita: 0,
        restosAPagar: 0
    };
    
    // Analisar células para buscar termos contábeis
    for (const linha of jsonAmostra) {
        if (!linha) continue;
        
        for (const celula of linha) {
            if (!celula || typeof celula !== 'string') continue;
            
            const valor = celula.toLowerCase();
            
            if (valor.includes('planejado') || valor.includes('orçado') || valor.includes('previsão') || 
                valor.includes('dotação') || valor.includes('ploa')) {
                contadores.planejado++;
            }
            
            if (valor.includes('executado') || valor.includes('empenho') || valor.includes('liquidação') || 
                valor.includes('pagamento') || valor.includes('despesa realizada')) {
                contadores.executado++;
            }
            
            if (valor.includes('receita') || valor.includes('arrecadado') || valor.includes('arrecadação') || 
                valor.includes('ingresso')) {
                contadores.receita++;
            }
            
            if (valor.includes('restos a pagar') || valor.includes('rp ') || valor.includes('rpnp') || 
                valor.includes('rpp')) {
                contadores.restosAPagar++;
            }
        }
    }
    
    // Determinar tipo baseado na maior contagem
    const tipoMaximo = Object.entries(contadores).sort((a, b) => b[1] - a[1])[0];
    
    if (tipoMaximo[1] > 0) {
        switch (tipoMaximo[0]) {
            case 'planejado': return 'PLANEJADO';
            case 'executado': return 'EXECUTADO';
            case 'receita': return 'RECEITA';
            case 'restosAPagar': return 'RESTOS_A_PAGAR';
        }
    }
    
    // Se não conseguir identificar pelos termos, usar uma abordagem mais genérica
    return 'GENERICO';
}

// Função para encontrar a linha de cabeçalho usando termos contábeis
function encontrarLinhaCabecalhoContabil(sheet, workbook, nomeAba) {
    try {
        // Converter para formato JSON com cabeçalho numérico para análise
        const jsonData = XLSX.utils.sheet_to_json(sheet, {
            header: 1,
            raw: false,
            defval: null
        });
        
        // Termos contábeis comuns em cabeçalhos
        const termosContabeis = [
            'dotação', 'empenho', 'liquidação', 'pagamento', 'despesa', 'orçamento',
            'receita', 'arrecadação', 'previsão', 'exercício', 'valor', 'data',
            'código', 'programa', 'ação', 'fonte', 'natureza', 'restos', 'processo',
            'uag', 'unidade', 'modalidade', 'credor', 'fornecedor', 'elemento'
        ];
        
        // Procurar linha com mais termos contábeis nas primeiras 30 linhas
        let melhorLinha = -1;
        let maxTermosContabeis = 0;
        let maxCelulasNaoNulas = 0;
        
        for (let i = 0; i < Math.min(30, jsonData.length); i++) {
            if (!jsonData[i]) continue;
            
            const linha = jsonData[i];
            const contagem = linha.filter(cell => cell !== null && cell !== '').length;
            
            if (contagem > 3) { // Mínimo de 3 células preenchidas para ser considerado cabeçalho
                // Contar termos contábeis nesta linha
                let termosEncontrados = 0;
                
                linha.forEach(celula => {
                    if (celula && typeof celula === 'string') {
                        const celulaLower = celula.toLowerCase();
                        
                        termosContabeis.forEach(termo => {
                            if (celulaLower.includes(termo)) {
                                termosEncontrados++;
                            }
                        });
                    }
                });
                
                // Priorizar linhas com mais termos contábeis, depois com mais células
                if (termosEncontrados > maxTermosContabeis ||
                    (termosEncontrados === maxTermosContabeis && contagem > maxCelulasNaoNulas)) {
                    maxTermosContabeis = termosEncontrados;
                    maxCelulasNaoNulas = contagem;
                    melhorLinha = i;
                }
            }
        }
        
        // Se não encontrou nenhuma linha com termos contábeis, usar o método padrão
        if (melhorLinha < 0) {
            // Procurar a primeira linha que tenha pelo menos 3 células não vazias
            for (let i = 0; i < Math.min(30, jsonData.length); i++) {
                if (jsonData[i]) {
                    const contagem = jsonData[i].filter(cell => cell !== null && cell !== '').length;
                    if (contagem >= 3) {
                        melhorLinha = i;
                        break;
                    }
                }
            }
        }
        
        return melhorLinha;
    } catch (error) {
        logDebug(`Erro ao encontrar linha de cabeçalho: ${error.message}`);
        return -1;
    }
}

// Função para extrair metadados contábeis úteis da planilha
function extrairMetadadosContabeis(dados, sheet, nomeAba) {
    try {
        // Objeto para armazenar metadados
        const metadados = {
            exercicio: null,
            unidadeGestora: null,
            naturezasDespesa: new Set(),
            programas: new Set(),
            acoes: new Set(),
            fontes: new Set(),
            totais: {
                valorTotal: 0,
                quantidadeEmpenhos: 0,
                quantidadePagamentos: 0
            }
        };
        
        // Extrair exercício do nome da aba ou dos dados
        const matchExercicio = nomeAba.match(/\b20\d{2}\b/);
        if (matchExercicio) {
            metadados.exercicio = matchExercicio[0];
        }
        
        // Procurar nos campos dos dados
        dados.forEach(registro => {
            // Buscar exercício nos dados
            if (!metadados.exercicio) {
                for (const [chave, valor] of Object.entries(registro)) {
                    if (!valor) continue;
                    
                    // Procurar padrão de ano (20XX) em qualquer campo
                    if (typeof valor === 'string' && /exerc[íi]cio.*20\d{2}|20\d{2}$/i.test(valor)) {
                        const matchAno = valor.match(/\b(20\d{2})\b/);
                        if (matchAno) {
                            metadados.exercicio = matchAno[1];
                        }
                    }
                }
            }
            
            // Buscar unidade gestora
            if (!metadados.unidadeGestora) {
                for (const [chave, valor] of Object.entries(registro)) {
                    if (!valor) continue;
                    
                    if (typeof chave === 'string' && typeof valor === 'string') {
                        // Verificar se é um campo de unidade gestora
                        if (
                            chave.toLowerCase().includes('unidade') || 
                            chave.toLowerCase().includes('ug') || 
                            chave.toLowerCase().includes('uag') ||
                            chave.toLowerCase().includes('órgão')
                        ) {
                            metadados.unidadeGestora = valor;
                            break;
                        }
                    }
                }
            }
            
            // Coletar naturezas de despesa, programas, ações e fontes
            for (const [chave, valor] of Object.entries(registro)) {
                if (!valor) continue;
                
                const chaveLower = typeof chave === 'string' ? chave.toLowerCase() : '';
                
                // Naturezas de despesa (geralmente códigos no formato XX.XX.XX.XX)
                if (
                    (chaveLower.includes('natureza') || chaveLower.includes('despesa') || chaveLower.includes('nd')) &&
                    typeof valor === 'string' && /^\d{1,2}(\.\d{1,2}){1,3}$/.test(valor)
                ) {
                    metadados.naturezasDespesa.add(valor);
                }
                // Programas (geralmente códigos ou nomes específicos)
                else if (
                    chaveLower.includes('programa') &&
                    valor
                ) {
                    metadados.programas.add(String(valor));
                }
                // Ações orçamentárias
                else if (
                    (chaveLower.includes('ação') || chaveLower.includes('acao')) &&
                    valor
                ) {
                    metadados.acoes.add(String(valor));
                }
                // Fontes de recursos
                else if (
                    chaveLower.includes('fonte') &&
                    valor
                ) {
                    metadados.fontes.add(String(valor));
                }
            }
            
            // Contabilizar valores e quantidades
            let valorRegistro = 0;
            
            // Buscar campos que possam conter valores monetários
            for (const [chave, valor] of Object.entries(registro)) {
                if (!valor) continue;
                
                const chaveLower = typeof chave === 'string' ? chave.toLowerCase() : '';
                
                // Se é um campo de valor/empenho/pagamento
                if (
                    chaveLower.includes('valor') || 
                    chaveLower.includes('empenho') || 
                    chaveLower.includes('liquidado') || 
                    chaveLower.includes('pago')
                ) {
                    // Extrair valor numérico
                    let valorNumerico = 0;
                    
                    if (typeof valor === 'number') {
                        valorNumerico = valor;
                    } else if (typeof valor === 'string') {
                        // Limpar e converter para número
                        const valorLimpo = valor.replace(/[^\d.,\-]/g, '')
                            .replace(/\./g, '')
                            .replace(/,/g, '.');
                        
                        valorNumerico = parseFloat(valorLimpo);
                    }
                    
                    if (!isNaN(valorNumerico) && valorNumerico > 0) {
                        // Somar ao total
                        metadados.totais.valorTotal += valorNumerico;
                        valorRegistro = Math.max(valorRegistro, valorNumerico);
                        
                        // Contabilizar empenhos e pagamentos
                        if (chaveLower.includes('empenho')) {
                            metadados.totais.quantidadeEmpenhos++;
                        }
                        if (chaveLower.includes('pago')) {
                            metadados.totais.quantidadePagamentos++;
                        }
                    }
                }
            }
        });
        
        // Converter Sets para arrays para facilitar o armazenamento
        return {
            exercicio: metadados.exercicio,
            unidadeGestora: metadados.unidadeGestora,
            naturezasDespesa: Array.from(metadados.naturezasDespesa),
            programas: Array.from(metadados.programas),
            acoes: Array.from(metadados.acoes),
            fontes: Array.from(metadados.fontes),
            totais: metadados.totais
        };
    } catch (error) {
        logDebug(`Erro ao extrair metadados contábeis: ${error.message}`);
        return {
            exercicio: null,
            unidadeGestora: null,
            naturezasDespesa: [],
            programas: [],
            acoes: [],
            fontes: [],
            totais: { valorTotal: 0, quantidadeEmpenhos: 0, quantidadePagamentos: 0 }
        };
    }
}

// Função avançada para normalizar dados contábeis
function normalizarDadosContabeis(dados, nomeAba, tipoAba) {
    // Array para armazenar registros normalizados
    const registrosNormalizados = [];
    
    // Determinar o exercício financeiro a partir do nome da aba ou outro campo
    let exercicio = null;
    const matchExercicio = nomeAba.match(/\b20\d{2}\b/);
    if (matchExercicio) {
        exercicio = matchExercicio[0];
    }
    
    // Verificar campos conhecidos de cada registro
    dados.forEach((registro, index) => {
        // Objeto normalizado base
        const normalizado = {
            ID: index + 1,
            Tipo_Registro: tipoAba,
            Exercicio: exercicio
        };
        
        // Processar cada campo do registro original
        for (const [chaveOriginal, valorOriginal] of Object.entries(registro)) {
            // Ignorar valores nulos/vazios
            if (valorOriginal === null || valorOriginal === '') continue;
            
            const chaveOriginalLower = typeof chaveOriginal === 'string' ? chaveOriginal.toLowerCase() : '';
            
            // Extrair exercício se ainda não tiver sido encontrado
            if (!normalizado.Exercicio && typeof valorOriginal === 'string') {
                const matchAno = valorOriginal.match(/\b(20\d{2})\b/);
                if (matchAno && matchAno[1] >= 2000 && matchAno[1] <= 2050) {
                    normalizado.Exercicio = matchAno[1];
                }
            }
            
            // === Processar campos por categorias contábeis ===
            
            // DATAS (empenho, liquidação, pagamento)
            if (processarCamposData(normalizado, chaveOriginalLower, valorOriginal, chaveOriginal)) {
                continue;
            }
            
            // VALORES MONETÁRIOS
            if (processarCamposValor(normalizado, chaveOriginalLower, valorOriginal, chaveOriginal)) {
                continue;
            }
            
            // CLASSIFICAÇÕES ORÇAMENTÁRIAS
            if (processarClassificacoesOrcamentarias(normalizado, chaveOriginalLower, valorOriginal, chaveOriginal)) {
                continue;
            }
            
            // DOCUMENTOS e PROCESSOS
            if (processarDocumentos(normalizado, chaveOriginalLower, valorOriginal, chaveOriginal)) {
                continue;
            }
            
            // UNIDADES e SETORES
            if (processarUnidades(normalizado, chaveOriginalLower, valorOriginal, chaveOriginal)) {
                continue;
            }
            
            // Se chegou aqui, é um campo que não se encaixa nas categorias acima
            // Incluir com nome mais limpo se for uma das categorias de interesse
            const categoriasImportantes = ['observação', 'motivo', 'justificativa', 'credor', 'fornecedor', 'objeto', 'descrição'];
            
            for (const categoria of categoriasImportantes) {
                if (chaveOriginalLower.includes(categoria)) {
                    const nomeNormalizado = categoria.charAt(0).toUpperCase() + categoria.slice(1);
                    normalizado[nomeNormalizado] = valorOriginal;
                    break;
                }
            }
        }
        
        // Verificar se é um registro relevante (tem pelo menos um valor monetário)
        const temValor = Object.keys(normalizado).some(chave => 
            chave.startsWith('Valor_') && typeof normalizado[chave] === 'number' && normalizado[chave] > 0
        );
        
        // Manter registro se tiver pelo menos um valor ou for um registro de cabeçalho (metadados)
        if (temValor || Object.keys(normalizado).length > 5) {
            // Adicionar campos derivados/calculados
            
            // Verificar o tipo de despesa com base nos campos
            if (normalizado.Natureza_Despesa) {
                adicionarClassificacaoDespesa(normalizado);
            }
            
            // Adicionar status com base nos campos disponíveis
            adicionarStatusExecucao(normalizado);
            
            // Adicionar ao array final
            registrosNormalizados.push(normalizado);
        }
    });
    
    return registrosNormalizados;
}

// Funções auxiliares para o processamento de campos específicos

// Processar campos de data
function processarCamposData(normalizado, chaveOriginalLower, valorOriginal, chaveOriginal) {
    // Mapeamento de tipos de data em campos contábeis
    const tiposData = {
        'data_empenho': ['empenho', 'empenhado', 'emissão ne'],
        'data_liquidacao': ['liquidação', 'liquidado', 'liquidacao'],
        'data_pagamento': ['pagamento', 'pago', 'data op'],
        'data_lancamento': ['lançamento', 'lancamento', 'registro'],
        'data_vencimento': ['vencimento', 'vence']
    };
    
    // Verificar se a chave corresponde a algum tipo de data
    for (const [tipoData, termos] of Object.entries(tiposData)) {
        if (termos.some(termo => chaveOriginalLower.includes(termo) && chaveOriginalLower.includes('data'))) {
            try {
                // Processar o valor como data
                let dataProcessada = null;
                
                if (valorOriginal instanceof Date) {
                    dataProcessada = valorOriginal;
                } else if (typeof valorOriginal === 'string') {
                    // Limpar o valor
                    const valorLimpo = valorOriginal.replace(/\s+/g, ' ').trim();
                    
                    // Tentar vários formatos de data
                    if (/^\d{1,2}\/\d{1,2}\/\d{2,4}$/.test(valorLimpo)) {
                        // DD/MM/YYYY ou MM/DD/YYYY (assumir DD/MM/YYYY para Brasil)
                        const [dia, mes, ano] = valorLimpo.split('/');
                        dataProcessada = new Date(
                            parseInt(ano.length === 2 ? '20' + ano : ano), 
                            parseInt(mes) - 1, 
                            parseInt(dia)
                        );
                    } else if (/^\d{4}-\d{1,2}-\d{1,2}$/.test(valorLimpo)) {
                        // YYYY-MM-DD
                        dataProcessada = new Date(valorLimpo);
                    } else if (/^\d{1,2}-\d{1,2}-\d{4}$/.test(valorLimpo)) {
                        // DD-MM-YYYY
                        const [dia, mes, ano] = valorLimpo.split('-');
                        dataProcessada = new Date(parseInt(ano), parseInt(mes) - 1, parseInt(dia));
                    } else {
                        // Tentar construtor padrão
                        dataProcessada = new Date(valorLimpo);
                    }
                    
                    if (isNaN(dataProcessada.getTime())) {
                        // Se falhou, tente extrair um ano pelo menos
                        const matchAno = valorLimpo.match(/\b(20\d{2})\b/);
                        if (matchAno) {
                            dataProcessada = new Date(parseInt(matchAno[1]), 0, 1); // 1º de janeiro
                        } else {
                            dataProcessada = null;
                        }
                    }
                }
                
                // Se conseguiu processar, adicione ao objeto normalizado
                if (dataProcessada && !isNaN(dataProcessada.getTime())) {
                    const nomeNormalizado = tipoData.charAt(0).toUpperCase() + tipoData.slice(1);
                    normalizado[nomeNormalizado] = dataProcessada;
                    return true;
                }
            } catch (error) {
                // Se houve erro no processamento, continuar para o próximo campo
                console.error(`Erro ao processar data ${chaveOriginal}:`, error);
            }
        }
    }
    
    return false;
}

// Processar campos de valor monetário
function processarCamposValor(normalizado, chaveOriginalLower, valorOriginal, chaveOriginal) {
    // Mapeamento de tipos de valor em campos contábeis
    const tiposValor = {
        'valor_empenhado': ['empenho', 'empenhado', 'ne', 'valor ne'],
        'valor_liquidado': ['liquidação', 'liquidado', 'liquidacao', 'nl'],
        'valor_pago': ['pagamento', 'pago', 'op'],
        'valor_planejado': ['planejado', 'dotação', 'dotacao', 'orçado', 'orcado', 'previsto'],
        'valor_atualizado': ['atualizado', 'atual', 'disponível', 'disponivel'],
        'valor_inscrito': ['inscrito', 'restos a pagar', 'rp', 'rpnp'],
        'valor_cancelado': ['cancelado', 'cancelamento', 'anulado']
    };
    
    // Verificar se é campo de valor
    let tipoValorIdentificado = null;
    
    // Verificar por tipo específico de valor
    for (const [tipoValor, termos] of Object.entries(tiposValor)) {
        if (termos.some(termo => chaveOriginalLower.includes(termo)) && 
            (chaveOriginalLower.includes('valor') || 
             chaveOriginalLower.includes('total') ||
             chaveOriginalLower.includes('r$'))) {
            tipoValorIdentificado = tipoValor;
            break;
        }
    }
    
    // Se não identificou tipo específico, mas parece ser valor monetário
    if (!tipoValorIdentificado && 
        (chaveOriginalLower.includes('valor') || 
         chaveOriginalLower.includes('montante') || 
         chaveOriginalLower.includes('total') ||
         chaveOriginalLower.includes('r$'))) {
        tipoValorIdentificado = 'valor_generico';
    }
    
    if (tipoValorIdentificado) {
        try {
            // Processar como valor monetário
            let valorNumerico = null;
            
            if (typeof valorOriginal === 'number') {
                valorNumerico = valorOriginal;
            } else if (typeof valorOriginal === 'string') {
                // Limpar e converter para número
                const valorLimpo = valorOriginal
                    .replace(/[^\d.,\-]/g, '') // Remove tudo exceto números, pontos, vírgulas e sinal negativo
                    .replace(/\.(?=.*\.)/g, '') // Remove pontos de milhar (mantém último ponto)
                    .replace(/,/g, '.'); // Substitui vírgula por ponto para decimal
                
                valorNumerico = parseFloat(valorLimpo);
            }
            
            // Se conseguiu converter para número válido
            if (valorNumerico !== null && !isNaN(valorNumerico)) {
                // Normalizar nome do campo
                const nomeNormalizado = tipoValorIdentificado.charAt(0).toUpperCase() + 
                                       tipoValorIdentificado.slice(1);
                
                normalizado[nomeNormalizado] = valorNumerico;
                return true;
            }
        } catch (error) {
            // Se houve erro no processamento, continuar para o próximo campo
            console.error(`Erro ao processar valor ${chaveOriginal}:`, error);
        }
    }
    
    return false;
}

// Processar classificações orçamentárias
function processarClassificacoesOrcamentarias(normalizado, chaveOriginalLower, valorOriginal, chaveOriginal) {
    // Mapeamento de tipos de classificação orçamentária
    const tiposClassificacao = {
        'natureza_despesa': ['natureza', 'nd', 'elemento', 'rubrica', 'gnd'],
        'programa_trabalho': ['programa', 'pt', 'programa trabalho', 'ptres', 'funcional'],
        'fonte_recurso': ['fonte', 'fr', 'iduso'],
        'acao_orcamentaria': ['ação', 'acao', 'subação', 'subacao', 'iniciativa'],
        'unidade_orcamentaria': ['uo', 'unidade orçamentária', 'unidade orcamentaria'],
        'unidade_gestora': ['ug', 'unidade gestora', 'uag', 'uasg']
    };
    
    // Verificar se corresponde a alguma classificação orçamentária
    for (const [tipoClassificacao, termos] of Object.entries(tiposClassificacao)) {
        if (termos.some(termo => chaveOriginalLower.includes(termo))) {
            try {
                // Processar de acordo com o tipo de classificação
                let valorProcessado = valorOriginal;
                
                // Formatação específica para natureza de despesa
                if (tipoClassificacao === 'natureza_despesa' && typeof valorOriginal === 'string') {
                    // Verificar se são dígitos formatados
                    const matchDigitos = valorOriginal.match(/\d+/g);
                    if (matchDigitos && matchDigitos.length > 0) {
                        // Tentar formatar como XX.XX.XX.XX (padrão natureza da despesa)
                        const digitosConcatenados = matchDigitos.join('');
                        if (digitosConcatenados.length >= 6) {
                            // Formatar com pontos de acordo com a classificação padrão
                            valorProcessado = formatarNaturezaDespesa(digitosConcatenados);
                        }
                    }
                }
                
                // Normalizar nome do campo
                const nomeNormalizado = tipoClassificacao
                    .split('_')
                    .map(palavra => palavra.charAt(0).toUpperCase() + palavra.slice(1))
                    .join('_');
                
                normalizado[nomeNormalizado] = valorProcessado;
                return true;
            } catch (error) {
                // Se houve erro no processamento, continuar para o próximo campo
                console.error(`Erro ao processar classificação ${chaveOriginal}:`, error);
            }
        }
    }
    
    return false;
}

// Processar documentos e processos
function processarDocumentos(normalizado, chaveOriginalLower, valorOriginal, chaveOriginal) {
    // Mapeamento de tipos de documento
    const tiposDocumento = {
        'numero_empenho': ['ne', 'empenho', 'nota de empenho', 'numero empenho'],
        'numero_liquidacao': ['nl', 'liquidação', 'nota de liquidação', 'liquidacao'],
        'numero_pagamento': ['op', 'pagamento', 'ordem', 'ordem bancária', 'ob'],
        'processo': ['processo', 'sei', 'proc'],
        'contrato': ['contrato', 'convenio', 'convênio', 'termo'],
        'licitacao': ['licitação', 'licitacao', 'pregão', 'pregao', 'concorrência', 'tomada']
    };
    
    // Verificar se corresponde a algum tipo de documento
    for (const [tipoDocumento, termos] of Object.entries(tiposDocumento)) {
        if (termos.some(termo => chaveOriginalLower.includes(termo)) && 
            (chaveOriginalLower.includes('numero') || 
             chaveOriginalLower.includes('número') || 
             chaveOriginalLower.includes('nº') ||
             chaveOriginalLower.includes('no.') ||
             chaveOriginalLower.includes('código') ||
             chaveOriginalLower.includes('codigo'))) {
            
            try {
                // Normalizar nome do campo
                const nomeNormalizado = tipoDocumento
                    .split('_')
                    .map(palavra => palavra.charAt(0).toUpperCase() + palavra.slice(1))
                    .join('_');
                
                normalizado[nomeNormalizado] = String(valorOriginal).trim();
                return true;
            } catch (error) {
                // Se houve erro no processamento, continuar para o próximo campo
                console.error(`Erro ao processar documento ${chaveOriginal}:`, error);
            }
        }
    }
    
    return false;
}

// Processar unidades e setores
function processarUnidades(normalizado, chaveOriginalLower, valorOriginal, chaveOriginal) {
    // Mapeamento de tipos de unidade
    const tiposUnidade = {
        'unidade_gestora': ['ug', 'gestora', 'uag', 'uasg'],
        'unidade_orcamentaria': ['uo', 'orçamentária', 'orcamentaria'],
        'departamento': ['depart', 'setor', 'área', 'area', 'divisão'],
        'orgao': ['órgão', 'orgao', 'entidade'],
        'credor': ['credor', 'fornecedor', 'favorecido', 'beneficiário', 'empresa']
    };
    
    // Verificar se corresponde a algum tipo de unidade
    for (const [tipoUnidade, termos] of Object.entries(tiposUnidade)) {
        if (termos.some(termo => chaveOriginalLower.includes(termo))) {
            try {
                // Normalizar nome do campo
                const nomeNormalizado = tipoUnidade.charAt(0).toUpperCase() + tipoUnidade.slice(1);
                
                normalizado[nomeNormalizado] = valorOriginal;
                return true;
            } catch (error) {
                // Se houve erro no processamento, continuar para o próximo campo
                console.error(`Erro ao processar unidade ${chaveOriginal}:`, error);
            }
        }
    }
    
    return false;
}

// Função para formatar natureza da despesa com pontos
function formatarNaturezaDespesa(digitos) {
    // Remove todos os caracteres não numéricos
    const apenasDigitos = digitos.replace(/\D/g, '');
    
    // Formata de acordo com o tamanho
    if (apenasDigitos.length === 8) {
        // XX.XX.XX.XX (categoria, grupo, modalidade, elemento)
        return `${apenasDigitos.substring(0, 2)}.${apenasDigitos.substring(2, 4)}.${apenasDigitos.substring(4, 6)}.${apenasDigitos.substring(6)}`;
    } else if (apenasDigitos.length === 6) {
        // XX.XX.XX (categoria, grupo, modalidade)
        return `${apenasDigitos.substring(0, 2)}.${apenasDigitos.substring(2, 4)}.${apenasDigitos.substring(4)}`;
    } else {
        // Retorna como está
        return apenasDigitos;
    }
}

// Função para adicionar classificação da despesa baseada na natureza
function adicionarClassificacaoDespesa(normalizado) {
    if (!normalizado.Natureza_Despesa) return;
    
    try {
        // Extrair partes da natureza da despesa
        const partes = normalizado.Natureza_Despesa.toString().split('.');
        
        if (partes.length >= 1) {
            // Categoria Econômica (1º nível)
            const categoria = partes[0]?.substring(0, 1);
            switch (categoria) {
                case '3': normalizado.Categoria_Economica = 'Despesas Correntes'; break;
                case '4': normalizado.Categoria_Economica = 'Despesas de Capital'; break;
                default: normalizado.Categoria_Economica = 'Outra';
            }
            
            // Grupo de Natureza (2º nível)
            if (partes[0]?.length >= 2) {
                const grupo = partes[0].substring(1, 2);
                switch (categoria + grupo) {
                    case '31': normalizado.Grupo_Despesa = 'Pessoal e Encargos Sociais'; break;
                    case '32': normalizado.Grupo_Despesa = 'Juros e Encargos da Dívida'; break;
                    case '33': normalizado.Grupo_Despesa = 'Outras Despesas Correntes'; break;
                    case '34': normalizado.Grupo_Despesa = 'Transferências Correntes'; break;
                    case '41': normalizado.Grupo_Despesa = 'Investimentos'; break;
                    case '42': normalizado.Grupo_Despesa = 'Inversões Financeiras'; break;
                    case '43': normalizado.Grupo_Despesa = 'Amortização da Dívida'; break;
                    case '44': normalizado.Grupo_Despesa = 'Transferências de Capital'; break;
                    case '45': normalizado.Grupo_Despesa = 'Reserva de Contingência'; break;
                    case '46': normalizado.Grupo_Despesa = 'Reserva do RPPS'; break;
                    default: normalizado.Grupo_Despesa = 'Outro';
                }
            }
        }
        
        // Modalidade de Aplicação (se tiver)
        if (partes.length >= 2) {
            const modalidade = partes[1];
            switch (modalidade) {
                case '50': normalizado.Modalidade_Aplicacao = 'Transferências a Instituições Privadas sem Fins Lucrativos'; break;
                case '80': normalizado.Modalidade_Aplicacao = 'Transferências ao Exterior'; break;
                case '90': normalizado.Modalidade_Aplicacao = 'Aplicações Diretas'; break;
                case '91': normalizado.Modalidade_Aplicacao = 'Aplicação Direta Decorrente de Operação entre Órgãos'; break;
                case '30': normalizado.Modalidade_Aplicacao = 'Transferências a Estados e DF'; break;
                case '40': normalizado.Modalidade_Aplicacao = 'Transferências a Municípios'; break;
                case '41': normalizado.Modalidade_Aplicacao = 'Transferências a Municípios - Fundo a Fundo'; break;
                case '71': normalizado.Modalidade_Aplicacao = 'Transferências a Consórcios Públicos'; break;
                default: normalizado.Modalidade_Aplicacao = modalidade;
            }
        }
        
        // Elemento de Despesa (se tiver)
        if (partes.length >= 3) {
            const elemento = partes[2];
            // Mapear alguns elementos comuns
            switch (elemento) {
                case '39': normalizado.Elemento_Despesa = 'Outros Serviços de Terceiros - PJ'; break;
                case '30': normalizado.Elemento_Despesa = 'Material de Consumo'; break;
                case '51': normalizado.Elemento_Despesa = 'Obras e Instalações'; break;
                case '52': normalizado.Elemento_Despesa = 'Equipamentos e Material Permanente'; break;
                case '11': normalizado.Elemento_Despesa = 'Vencimentos e Vantagens Fixas'; break;
                case '13': normalizado.Elemento_Despesa = 'Obrigações Patronais'; break;
                case '14': normalizado.Elemento_Despesa = 'Diárias'; break;
                case '36': normalizado.Elemento_Despesa = 'Outros Serviços de Terceiros - PF'; break;
                case '41': normalizado.Elemento_Despesa = 'Contribuições'; break;
                case '48': normalizado.Elemento_Despesa = 'Outros Auxílios Financeiros a PF'; break;
                case '92': normalizado.Elemento_Despesa = 'Despesas de Exercícios Anteriores'; break;
                case '93': normalizado.Elemento_Despesa = 'Indenizações e Restituições'; break;
                default: normalizado.Elemento_Despesa = elemento;
            }
        }
    } catch (error) {
        console.error('Erro ao classificar natureza de despesa:', error);
    }
}

// Função para adicionar status de execução com base nos campos disponíveis
function adicionarStatusExecucao(normalizado) {
    try {
        // Verificar presença de valores para determinar status
        const temEmpenho = normalizado.Valor_Empenhado > 0 || normalizado.Numero_Empenho;
        const temLiquidacao = normalizado.Valor_Liquidado > 0 || normalizado.Data_Liquidacao;
        const temPagamento = normalizado.Valor_Pago > 0 || normalizado.Data_Pagamento;
        
        // Determinar status baseado nos valores e datas
        if (temPagamento) {
            normalizado.Status_Execucao = 'Pago';
        } else if (temLiquidacao) {
            normalizado.Status_Execucao = 'Liquidado';
        } else if (temEmpenho) {
            normalizado.Status_Execucao = 'Empenhado';
        } else if (normalizado.Valor_Planejado > 0) {
            normalizado.Status_Execucao = 'Planejado';
        } else if (normalizado.Tipo_Registro === 'RESTOS_A_PAGAR') {
            normalizado.Status_Execucao = 'Inscrito em RP';
        } else {
            normalizado.Status_Execucao = 'Indefinido';
        }
        
        // Definir fase/estágio da despesa
        if (normalizado.Tipo_Registro === 'PLANEJADO') {
            normalizado.Fase_Despesa = 'Planejamento';
        } else if (normalizado.Tipo_Registro === 'EXECUTADO') {
            normalizado.Fase_Despesa = 'Execução';
        } else if (normalizado.Tipo_Registro === 'RESTOS_A_PAGAR') {
            normalizado.Fase_Despesa = 'Restos a Pagar';
        } else {
            normalizado.Fase_Despesa = 'Outra';
        }
    } catch (error) {
        console.error('Erro ao determinar status de execução:', error);
    }
}

// Função para consolidar os dados contábeis
function consolidarDadosContabeis(dados, metadadosAbas) {
    try {
        // Objeto para rastrear despesas unificadas por ID de despesa (empenho/ação/etc)
        const despesasConsolidadas = new Map();
        
        // Identificar possíveis chaves de identificação de despesa
        dados.forEach(registro => {
            // Criar identificador único para cada despesa baseado em número do empenho ou outra chave relevante
            let idDespesa = null;
            
            // Tentar diferentes estratégias para identificar a mesma despesa em múltiplas abas
            if (registro.Numero_Empenho) {
                // Usar número de empenho quando disponível
                idDespesa = `EMPENHO:${registro.Numero_Empenho}`;
            } else if (registro.Processo) {
                // Usar número de processo quando disponível
                idDespesa = `PROCESSO:${registro.Processo}`;
            } else if (registro.Acao_Orcamentaria && registro.Natureza_Despesa) {
                // Usar combinação de ação e natureza
                idDespesa = `ACAO_ND:${registro.Acao_Orcamentaria}_${registro.Natureza_Despesa}`;
            } else if (registro.Credor && registro.Valor_Empenhado) {
                // Usar combinação de credor e valor quando disponível
                idDespesa = `CREDOR_VALOR:${registro.Credor}_${registro.Valor_Empenhado}`;
            } else {
                // Usar ID gerado
                idDespesa = `ID:${registro.ID}_${registro.Tipo_Registro}`;
            }
            
            // Adicionar ou mesclar com registro existente
            if (despesasConsolidadas.has(idDespesa)) {
                // Mesclar com registro existente
                const registroExistente = despesasConsolidadas.get(idDespesa);
                
                // Mesclar dados sem sobrescrever informações existentes
                for (const [chave, valor] of Object.entries(registro)) {
                    // Não sobrescrever valores existentes, exceto valores monetários que podem ser complementados
                    if (chave.startsWith('Valor_') && !registroExistente[chave]) {
                        registroExistente[chave] = valor;
                    } 
                    // Complementar campos de data
                    else if (chave.startsWith('Data_') && !registroExistente[chave]) {
                        registroExistente[chave] = valor;
                    }
                    // Outros campos importantes que podem estar em abas diferentes
                    else if (!registroExistente[chave]) {
                        registroExistente[chave] = valor;
                    }
                }
                
                // Atualizar flag de dados consolidados
                registroExistente.Dado_Consolidado = true;
                registroExistente.Fontes_Dados = [...new Set([
                    ...(registroExistente.Fontes_Dados || []),
                    registro.Fonte_Aba
                ])];
            } else {
                // Criar novo registro
                const novoRegistro = {...registro};
                novoRegistro.ID_Despesa = idDespesa;
                novoRegistro.Fontes_Dados = [registro.Fonte_Aba];
                despesasConsolidadas.set(idDespesa, novoRegistro);
            }
        });
        
        // Converter Map para array
        return Array.from(despesasConsolidadas.values());
    } catch (error) {
        console.error('Erro ao consolidar dados contábeis:', error);
        return dados; // Retornar dados originais em caso de erro
    }
}

// Função para calcular indicadores financeiros adicionais
function calcularIndicadoresFinanceiros(dados, metadadosAbas) {
    try {
        // Verificar exercício predominante
        const exercicios = dados
            .map(d => d.Exercicio)
            .filter(Boolean);
            
        const exercicioMaisComum = exercicios.length > 0 ? 
            exercicios.sort((a, b) => 
                exercicios.filter(e => e === a).length - 
                exercicios.filter(e => e === b).length
            ).pop() : 
            new Date().getFullYear().toString();
            
        // Para cada registro, adicionar indicadores calculados
        dados.forEach(registro => {
            // Garantir que tenha exercício
            if (!registro.Exercicio) {
                registro.Exercicio = exercicioMaisComum;
            }
            
            // Calcular percentual de execução se tiver valor planejado e empenhado
            if (registro.Valor_Planejado > 0 && registro.Valor_Empenhado > 0) {
                registro.Percentual_Execucao = (registro.Valor_Empenhado / registro.Valor_Planejado) * 100;
            }
            
            // Calcular percentual de liquidação se tiver empenho e liquidação
            if (registro.Valor_Empenhado > 0 && registro.Valor_Liquidado > 0) {
                registro.Percentual_Liquidacao = (registro.Valor_Liquidado / registro.Valor_Empenhado) * 100;
            }
            
            // Calcular percentual de pagamento se tiver liquidação e pagamento
            if (registro.Valor_Liquidado > 0 && registro.Valor_Pago > 0) {
                registro.Percentual_Pagamento = (registro.Valor_Pago / registro.Valor_Liquidado) * 100;
            }
            
            // Calcular saldo a liquidar
            if (registro.Valor_Empenhado > 0) {
                const valorLiquidado = registro.Valor_Liquidado || 0;
                registro.Saldo_A_Liquidar = Math.max(0, registro.Valor_Empenhado - valorLiquidado);
            }
            
            // Calcular saldo a pagar
            if (registro.Valor_Liquidado > 0) {
                const valorPago = registro.Valor_Pago || 0;
                registro.Saldo_A_Pagar = Math.max(0, registro.Valor_Liquidado - valorPago);
            }
            
            // Calcular indicadores de tempo
            calcularIndicadoresTempo(registro);
            
            // Classificar por tempo de execução
            classificarTempoExecucao(registro);
        });
        
        return dados;
    } catch (error) {
        console.error('Erro ao calcular indicadores financeiros:', error);
        return dados; // Retornar dados originais em caso de erro
    }
}

// Função para calcular indicadores de tempo
function calcularIndicadoresTempo(registro) {
    try {
        // Calcular dias entre empenho e liquidação
        if (registro.Data_Empenho instanceof Date && registro.Data_Liquidacao instanceof Date) {
            const diffEmpenhoLiquidacao = Math.abs(registro.Data_Liquidacao - registro.Data_Empenho);
            registro.Dias_Empenho_Liquidacao = Math.ceil(diffEmpenhoLiquidacao / (1000 * 60 * 60 * 24));
        }
        
        // Calcular dias entre liquidação e pagamento
        if (registro.Data_Liquidacao instanceof Date && registro.Data_Pagamento instanceof Date) {
            const diffLiquidacaoPagamento = Math.abs(registro.Data_Pagamento - registro.Data_Liquidacao);
            registro.Dias_Liquidacao_Pagamento = Math.ceil(diffLiquidacaoPagamento / (1000 * 60 * 60 * 24));
        }
        
        // Calcular dias totais do processo
        if (registro.Data_Empenho instanceof Date && registro.Data_Pagamento instanceof Date) {
            const diffTotal = Math.abs(registro.Data_Pagamento - registro.Data_Empenho);
            registro.Dias_Total_Processo = Math.ceil(diffTotal / (1000 * 60 * 60 * 24));
        }
    } catch (error) {
        console.error('Erro ao calcular indicadores de tempo:', error);
    }
}

// Função para classificar o tempo de execução
function classificarTempoExecucao(registro) {
    try {
        // Classificar tempo de liquidação
        if (registro.Dias_Empenho_Liquidacao) {
            if (registro.Dias_Empenho_Liquidacao <= 15) {
                registro.Classificacao_Tempo_Liquidacao = 'Rápido';
            } else if (registro.Dias_Empenho_Liquidacao <= 45) {
                registro.Classificacao_Tempo_Liquidacao = 'Normal';
            } else {
                registro.Classificacao_Tempo_Liquidacao = 'Demorado';
            }
        }
        
        // Classificar tempo de pagamento
        if (registro.Dias_Liquidacao_Pagamento) {
            if (registro.Dias_Liquidacao_Pagamento <= 5) {
                registro.Classificacao_Tempo_Pagamento = 'Rápido';
            } else if (registro.Dias_Liquidacao_Pagamento <= 15) {
                registro.Classificacao_Tempo_Pagamento = 'Normal';
            } else {
                registro.Classificacao_Tempo_Pagamento = 'Demorado';
            }
        }
        
        // Classificar processo total
        if (registro.Dias_Total_Processo) {
            if (registro.Dias_Total_Processo <= 30) {
                registro.Classificacao_Tempo_Total = 'Rápido';
            } else if (registro.Dias_Total_Processo <= 60) {
                registro.Classificacao_Tempo_Total = 'Normal';
            } else {
                registro.Classificacao_Tempo_Total = 'Demorado';
            }
        }
    } catch (error) {
        console.error('Erro ao classificar tempo de execução:', error);
    }
}
// Relatórios Contábeis Especializados para o Dashboard SUAD
// Implementa relatórios específicos para análise de execução orçamentária e financeira

// Função principal para gerar relatórios contábeis
function gerarRelatorioContabil(tipo) {
    showLoader();
    logDebug(`Gerando relatório contábil especializado: ${tipo}`);
    
    try {
        // Verificar se temos dados para processar
        if (!filteredData || filteredData.length === 0) {
            throw new Error('Não há dados disponíveis para gerar o relatório contábil.');
        }
        
        // Recuperar metadados se disponíveis
        let metadados = {};
        try {
            const metadadosString = localStorage.getItem('suadDashboardMetadata');
            if (metadadosString) {
                metadados = JSON.parse(metadadosString);
            }
        } catch (e) {
            logDebug(`Aviso: Não foi possível carregar metadados: ${e.message}`);
        }
        
        // Determinar o exercício financeiro predominante nos dados
        const exercicios = filteredData
            .map(d => d.Exercicio)
            .filter(Boolean);
            
        const exercicioAtual = exercicios.length > 0 ? 
            exercicios.sort((a, b) => 
                exercicios.filter(e => e === a).length - 
                exercicios.filter(e => e === b).length
            ).pop() : 
            new Date().getFullYear().toString();
        
        // Executar o tipo de relatório solicitado
        let relatorioHTML = '';
        let tituloRelatorio = '';
        
        switch (tipo) {
            case 'execucao_orcamentaria':
                tituloRelatorio = `Relatório de Execução Orçamentária - Exercício ${exercicioAtual}`;
                relatorioHTML = gerarRelatorioExecucaoOrcamentaria(filteredData, metadados, exercicioAtual);
                break;
                
            case 'execucao_por_natureza':
                tituloRelatorio = `Execução por Natureza de Despesa - Exercício ${exercicioAtual}`;
                relatorioHTML = gerarRelatorioExecucaoPorNatureza(filteredData, metadados, exercicioAtual);
                break;
                
            case 'comparativo_planejado_executado':
                tituloRelatorio = `Comparativo Planejado x Executado - Exercício ${exercicioAtual}`;
                relatorioHTML = gerarRelatorioComparativoPlanejadoExecutado(filteredData, metadados, exercicioAtual);
                break;
                
            case 'financeiro_liquidacao':
                tituloRelatorio = `Relatório Financeiro de Liquidação - Exercício ${exercicioAtual}`;
                relatorioHTML = gerarRelatorioFinanceiroLiquidacao(filteredData, metadados, exercicioAtual);
                break;
                
            case 'pagamentos_realizados':
                tituloRelatorio = `Relatório de Pagamentos Realizados - Exercício ${exercicioAtual}`;
                relatorioHTML = gerarRelatorioPagamentosRealizados(filteredData, metadados, exercicioAtual);
                break;
                
            case 'restos_pagar':
                tituloRelatorio = `Relatório de Restos a Pagar - Exercício ${exercicioAtual}`;
                relatorioHTML = gerarRelatorioRestosAPagar(filteredData, metadados, exercicioAtual);
                break;
                
            case 'execucao_detalhada_credor':
                tituloRelatorio = `Execução Detalhada por Credor - Exercício ${exercicioAtual}`;
                relatorioHTML = gerarRelatorioExecucaoPorCredor(filteredData, metadados, exercicioAtual);
                break;
                
            case 'indicadores_desempenho':
                tituloRelatorio = `Indicadores de Desempenho Orçamentário - Exercício ${exercicioAtual}`;
                relatorioHTML = gerarRelatorioIndicadoresDesempenho(filteredData, metadados, exercicioAtual);
                break;
                
            default:
                throw new Error(`Tipo de relatório contábil não reconhecido: ${tipo}`);
        }
        
        // Atualizar interface
        const reportTitle = document.getElementById('reportTitle');
        const reportBody = document.getElementById('reportBody');
        
        if (reportTitle) reportTitle.textContent = tituloRelatorio;
        if (reportBody) reportBody.innerHTML = relatorioHTML;
        
        // Renderizar gráficos se existirem no relatório
        setTimeout(() => {
            renderizarGraficosContabeis(tipo);
        }, 100);
        
        showSuccess(`Relatório contábil ${tituloRelatorio} gerado com sucesso`);
        logDebug(`Relatório contábil ${tipo} gerado com sucesso`);
        
        return relatorioHTML;
    } catch (error) {
        console.error(`Erro ao gerar relatório contábil ${tipo}:`, error);
        showError(`Erro ao gerar relatório contábil: ${error.message}`);
        logDebug(`ERRO ao gerar relatório contábil ${tipo}: ${error.message}`);
        
        // Retornar mensagem de erro formatada como HTML
        return `
            <div class="card" style="margin-bottom: 20px;">
                <div class="card-header">
                    <div class="card-title">Erro ao Gerar Relatório</div>
                </div>
                <div style="padding: 15px; color: #e74c3c;">
                    <p>Ocorreu um erro ao gerar o relatório contábil:</p>
                    <p><strong>${error.message}</strong></p>
                    <p>Verifique os dados da planilha e tente novamente.</p>
                </div>
            </div>
        `;
    } finally {
        hideLoader();
    }
}

// === IMPLEMENTAÇÕES DE RELATÓRIOS ESPECÍFICOS ===

// 1. Relatório de Execução Orçamentária
function gerarRelatorioExecucaoOrcamentaria(dados, metadados, exercicio) {
    // Filtrar dados relevantes
    const dadosExercicio = dados.filter(d => !d.Exercicio || d.Exercicio.toString() === exercicio.toString());
    
    // Obter valores totais por fase do orçamento
    const valoresPorFase = calcularValoresPorFase(dadosExercicio);
    
    // Obter execução mensal (para gráficos)
    const execucaoMensal = calcularExecucaoMensal(dadosExercicio);
    
    // Calcular percentuais de execução
    const percentuais = calcularPercentuaisExecucao(valoresPorFase);
    
    // Gerar HTML do relatório
    let html = `
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Informações do Relatório</div>
            </div>
            <div style="padding: 15px;">
                <p><strong>Tipo:</strong> Relatório de Execução Orçamentária</p>
                <p><strong>Exercício:</strong> ${exercicio}</p>
                <p><strong>Data de Geração:</strong> ${new Date().toLocaleDateString('pt-BR')} ${new Date().toLocaleTimeString('pt-BR')}</p>
                <p><strong>Total de Registros:</strong> ${dadosExercicio.length}</p>
                ${metadados.processamento ? `<p><strong>Arquivo de Origem:</strong> ${metadados.processamento.arquivo || 'Não especificado'}</p>` : ''}
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Resumo da Execução Orçamentária</div>
            </div>
            <div style="padding: 15px;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <div class="summary-box" style="background-color: #f8f9fa; border-left: 4px solid #4361ee; padding: 15px;">
                        <h4>Dotação Inicial</h4>
                        <div style="font-size: 24px; font-weight: bold;">${formatarMoeda(valoresPorFase.dotacaoInicial)}</div>
                        <p>Orçamento aprovado para o exercício</p>
                    </div>
                    
                    <div class="summary-box" style="background-color: #f8f9fa; border-left: 4px solid #3a0ca3; padding: 15px;">
                        <h4>Dotação Atualizada</h4>
                        <div style="font-size: 24px; font-weight: bold;">${formatarMoeda(valoresPorFase.dotacaoAtualizada)}</div>
                        <p>Após alterações orçamentárias</p>
                    </div>
                    
                    <div class="summary-box" style="background-color: #f8f9fa; border-left: 4px solid #7209b7; padding: 15px;">
                        <h4>Valor Empenhado</h4>
                        <div style="font-size: 24px; font-weight: bold;">${formatarMoeda(valoresPorFase.valorEmpenhado)}</div>
                        <p>${percentuais.percentualEmpenhado}% da dotação atualizada</p>
                    </div>
                    
                    <div class="summary-box" style="background-color: #f8f9fa; border-left: 4px solid #f72585; padding: 15px;">
                        <h4>Valor Liquidado</h4>
                        <div style="font-size: 24px; font-weight: bold;">${formatarMoeda(valoresPorFase.valorLiquidado)}</div>
                        <p>${percentuais.percentualLiquidado}% do empenhado</p>
                    </div>
                    
                    <div class="summary-box" style="background-color: #f8f9fa; border-left: 4px solid #4cc9f0; padding: 15px;">
                        <h4>Valor Pago</h4>
                        <div style="font-size: 24px; font-weight: bold;">${formatarMoeda(valoresPorFase.valorPago)}</div>
                        <p>${percentuais.percentualPago}% do liquidado</p>
                    </div>
                </div>
                
                <div style="margin-top: 30px;">
                    <h4 style="margin-bottom: 15px;">Situação da Execução Orçamentária</h4>
                    <div style="background-color: #f8f9fa; padding: 20px; border-radius: 5px;">
                        <div style="margin-bottom: 15px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                <span><strong>Empenhado/Dotação:</strong></span>
                                <span>${percentuais.percentualEmpenhado}%</span>
                            </div>
                            <div class="progress" style="height: 20px; background-color: #e9ecef; border-radius: 5px; overflow: hidden;">
                                <div class="progress-bar" style="width: ${Math.min(100, percentuais.percentualEmpenhado)}%; height: 100%; background-color: #7209b7; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${percentuais.percentualEmpenhado}%</div>
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                <span><strong>Liquidado/Empenhado:</strong></span>
                                <span>${percentuais.percentualLiquidado}%</span>
                            </div>
                            <div class="progress" style="height: 20px; background-color: #e9ecef; border-radius: 5px; overflow: hidden;">
                                <div class="progress-bar" style="width: ${Math.min(100, percentuais.percentualLiquidado)}%; height: 100%; background-color: #f72585; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${percentuais.percentualLiquidado}%</div>
                            </div>
                        </div>
                        
                        <div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                <span><strong>Pago/Liquidado:</strong></span>
                                <span>${percentuais.percentualPago}%</span>
                            </div>
                            <div class="progress" style="height: 20px; background-color: #e9ecef; border-radius: 5px; overflow: hidden;">
                                <div class="progress-bar" style="width: ${Math.min(100, percentuais.percentualPago)}%; height: 100%; background-color: #4cc9f0; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${percentuais.percentualPago}%</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Evolução da Execução Orçamentária</div>
            </div>
            <div style="padding: 15px;">
                <div style="height: 350px;">
                    <canvas id="execucaoOrcamentariaChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Análise de Saldos</div>
            </div>
            <div style="padding: 15px;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <div class="summary-box" style="background-color: #f8f9fa; padding: 15px;">
                        <h4>Saldo Orçamentário</h4>
                        <div style="font-size: 24px; font-weight: bold; color: ${valoresPorFase.saldoOrcamentario >= 0 ? '#2ecc71' : '#e74c3c'};">
                            ${formatarMoeda(valoresPorFase.saldoOrcamentario)}
                        </div>
                        <p>Dotação não empenhada (${formatarPercentual(percentuais.percentualSaldoOrcamentario)})</p>
                    </div>
                    
                    <div class="summary-box" style="background-color: #f8f9fa; padding: 15px;">
                        <h4>A Liquidar</h4>
                        <div style="font-size: 24px; font-weight: bold; color: ${valoresPorFase.aLiquidar >= 0 ? '#f39c12' : '#e74c3c'};">
                            ${formatarMoeda(valoresPorFase.aLiquidar)}
                        </div>
                        <p>Empenhado e não liquidado (${formatarPercentual(percentuais.percentualALiquidar)})</p>
                    </div>
                    
                    <div class="summary-box" style="background-color: #f8f9fa; padding: 15px;">
                        <h4>A Pagar</h4>
                        <div style="font-size: 24px; font-weight: bold; color: ${valoresPorFase.aPagar >= 0 ? '#3498db' : '#e74c3c'};">
                            ${formatarMoeda(valoresPorFase.aPagar)}
                        </div>
                        <p>Liquidado e não pago (${formatarPercentual(percentuais.percentualAPagar)})</p>
                    </div>
                </div>
                
                <div style="height: 350px; margin-top: 30px;">
                    <canvas id="saldosOrcamentariosChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Observações do Contador</div>
            </div>
            <div style="padding: 15px;">
                <p>Com base na análise dos dados de execução orçamentária, destaco as seguintes observações:</p>
                
                <ul style="margin-top: 10px; margin-left: 20px;">
                    ${gerarObservacoesExecucao(valoresPorFase, percentuais, exercicio)}
                </ul>
                
                <p style="margin-top: 15px;"><strong>Nota:</strong> Este relatório foi gerado automaticamente com base nos dados fornecidos. Recomenda-se a conferência com os sistemas oficiais de contabilidade para validação dos valores apresentados.</p>
            </div>
        </div>
    `;
    
    // Adicionar seção de top 10 empenhos
    html += gerarSecaoTopEmpenhos(dadosExercicio);
    
    return html;
}

// 2. Relatório de Execução por Natureza de Despesa
function gerarRelatorioExecucaoPorNatureza(dados, metadados, exercicio) {
    // Filtrar dados relevantes
    const dadosExercicio = dados.filter(d => !d.Exercicio || d.Exercicio.toString() === exercicio.toString());
    
    // Agrupar por natureza de despesa
    const execucaoPorNatureza = agruparPorNaturezaDespesa(dadosExercicio);
    
    // Calcular totais
    const totais = calcularTotaisNatureza(execucaoPorNatureza);
    
    // Ordenar por valor empenhado (decrescente)
    const naturezasOrdenadas = Object.keys(execucaoPorNatureza).sort((a, b) => 
        (execucaoPorNatureza[b].valorEmpenhado || 0) - (execucaoPorNatureza[a].valorEmpenhado || 0)
    );
    
    // Gerar HTML do relatório
    let html = `
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Informações do Relatório</div>
            </div>
            <div style="padding: 15px;">
                <p><strong>Tipo:</strong> Relatório de Execução por Natureza de Despesa</p>
                <p><strong>Exercício:</strong> ${exercicio}</p>
                <p><strong>Data de Geração:</strong> ${new Date().toLocaleDateString('pt-BR')} ${new Date().toLocaleTimeString('pt-BR')}</p>
                <p><strong>Total de Registros:</strong> ${dadosExercicio.length}</p>
                ${metadados.processamento ? `<p><strong>Arquivo de Origem:</strong> ${metadados.processamento.arquivo || 'Não especificado'}</p>` : ''}
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Resumo por Grupo de Natureza de Despesa</div>
            </div>
            <div style="padding: 15px;">
                <div style="height: 350px; margin-bottom: 20px;">
                    <canvas id="naturezaGrupoChart"></canvas>
                </div>
                
                <div style="overflow-x: auto; margin-top: 20px;">
                    <table style="width: 100%; border-collapse: collapse; margin-top: 20px;">
                        <thead>
                            <tr>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Grupo de Natureza</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Empenhado</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Liquidado</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Pago</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">% do Total</th>
                            </tr>
                        </thead>
                        <tbody>
    `;
    
    // Agrupar por grupo de natureza (primeiros dígitos)
    const gruposNatureza = agruparPorGrupoNatureza(execucaoPorNatureza);
    
    // Ordenar grupos por valor empenhado (decrescente)
    const gruposOrdenados = Object.keys(gruposNatureza).sort((a, b) => 
        (gruposNatureza[b].valorEmpenhado || 0) - (gruposNatureza[a].valorEmpenhado || 0)
    );
    
    // Adicionar linhas da tabela para cada grupo
    gruposOrdenados.forEach(grupo => {
        const dadosGrupo = gruposNatureza[grupo];
        const percentualTotal = totais.valorEmpenhado > 0 ? 
            (dadosGrupo.valorEmpenhado / totais.valorEmpenhado) * 100 : 0;
        
        html += `
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;">${grupo}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(dadosGrupo.valorEmpenhado)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(dadosGrupo.valorLiquidado)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(dadosGrupo.valorPago)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarPercentual(percentualTotal)}</td>
            </tr>
        `;
    });
    
    // Adicionar linha de total
    html += `
                <tr style="font-weight: bold; background-color: #f9f9f9;">
                    <td style="padding: 10px; border: 1px solid #ddd;">TOTAL</td>
                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(totais.valorEmpenhado)}</td>
                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(totais.valorLiquidado)}</td>
                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(totais.valorPago)}</td>
                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">100,00%</td>
                </tr>
            </tbody>
        </table>
        </div>
        </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Detalhamento por Natureza de Despesa</div>
            </div>
            <div style="padding: 15px;">
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse; margin-top: 10px;">
                        <thead>
                            <tr>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Código</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Descrição</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Empenhado</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Liquidado</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Pago</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">% Exec.</th>
                            </tr>
                        </thead>
                        <tbody>
    `;
    
    // Adicionar as top 15 naturezas de despesa
    const topNaturezas = naturezasOrdenadas.slice(0, 15);
    
    topNaturezas.forEach(codigo => {
        const dados = execucaoPorNatureza[codigo];
        const descricao = obterDescricaoNaturezaDespesa(codigo);
        const percentualExecucao = dados.valorEmpenhado > 0 && dados.valorPlanejado > 0 ?
            (dados.valorPago / dados.valorEmpenhado) * 100 : 0;
        
        html += `
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;">${codigo}</td>
                <td style="padding: 10px; border: 1px solid #ddd;">${descricao}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(dados.valorEmpenhado)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(dados.valorLiquidado)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(dados.valorPago)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarPercentual(percentualExecucao)}</td>
            </tr>
        `;
    });
    
    html += `
                        </tbody>
                    </table>
                </div>
                
                <div style="height: 400px; margin-top: 30px;">
                    <canvas id="topNaturezasChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Análise Contábil por Categoria Econômica</div>
            </div>
            <div style="padding: 15px;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                    <div>
                        <h4 style="margin-bottom: 15px;">Despesas Correntes vs. Capital</h4>
                        <div style="height: 300px;">
                            <canvas id="categoriaEconomicaChart"></canvas>
                        </div>
                    </div>
                    
                    <div>
                        <h4 style="margin-bottom: 15px;">Principais Elementos de Despesa</h4>
                        <div style="height: 300px;">
                            <canvas id="elementosDespesaChart"></canvas>
                        </div>
                    </div>
                </div>
                
                <div style="margin-top: 30px;">
                    <h4 style="margin-bottom: 15px;">Observações sobre a Execução por Natureza de Despesa</h4>
                    <ul>
                        ${gerarObservacoesNatureza(execucaoPorNatureza, totais, gruposNatureza)}
                    </ul>
                </div>
            </div>
        </div>
    `;
    
    return html;
}

// 3. Relatório Comparativo Planejado x Executado
function gerarRelatorioComparativoPlanejadoExecutado(dados, metadados, exercicio) {
    // Filtrar dados relevantes
    const dadosExercicio = dados.filter(d => !d.Exercicio || d.Exercicio.toString() === exercicio.toString());
    
    // Agrupar dados planejados e executados
    const dadosPlanejados = dadosExercicio.filter(d => 
        d.Tipo_Registro === 'PLANEJADO' || d.Fase_Despesa === 'Planejamento'
    );
    
    const dadosExecutados = dadosExercicio.filter(d => 
        d.Tipo_Registro === 'EXECUTADO' || d.Fase_Despesa === 'Execução'
    );
    
    // Calcular valores planejados
    const valoresPlanejados = {
        total: somarCampoOuZero(dadosPlanejados, 'Valor_Planejado'),
        porMes: agruparValoresPorMes(dadosPlanejados, 'Valor_Planejado'),
        porNatureza: agruparValoresPorNatureza(dadosPlanejados, 'Valor_Planejado')
    };
    
    // Calcular valores executados
    const valoresExecutados = {
        empenhado: somarCampoOuZero(dadosExecutados, 'Valor_Empenhado'),
        liquidado: somarCampoOuZero(dadosExecutados, 'Valor_Liquidado'),
        pago: somarCampoOuZero(dadosExecutados, 'Valor_Pago'),
        porMes: {
            empenhado: agruparValoresPorMes(dadosExecutados, 'Valor_Empenhado'),
            liquidado: agruparValoresPorMes(dadosExecutados, 'Valor_Liquidado'),
            pago: agruparValoresPorMes(dadosExecutados, 'Valor_Pago')
        },
        porNatureza: {
            empenhado: agruparValoresPorNatureza(dadosExecutados, 'Valor_Empenhado'),
            liquidado: agruparValoresPorNatureza(dadosExecutados, 'Valor_Liquidado'),
            pago: agruparValoresPorNatureza(dadosExecutados, 'Valor_Pago')
        }
    };
    
    // Calcular percentuais de execução
    const percentuais = {
        empenhado: valoresPlanejados.total > 0 ? (valoresExecutados.empenhado / valoresPlanejados.total) * 100 : 0,
        liquidado: valoresPlanejados.total > 0 ? (valoresExecutados.liquidado / valoresPlanejados.total) * 100 : 0,
        pago: valoresPlanejados.total > 0 ? (valoresExecutados.pago / valoresPlanejados.total) * 100 : 0
    };
    
    // Gerar HTML do relatório
    let html = `
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Informações do Relatório</div>
            </div>
            <div style="padding: 15px;">
                <p><strong>Tipo:</strong> Relatório Comparativo Planejado x Executado</p>
                <p><strong>Exercício:</strong> ${exercicio}</p>
                <p><strong>Data de Geração:</strong> ${new Date().toLocaleDateString('pt-BR')} ${new Date().toLocaleTimeString('pt-BR')}</p>
                <p><strong>Total de Registros:</strong> ${dadosExercicio.length}</p>
                <p><strong>Registros Planejados:</strong> ${dadosPlanejados.length}</p>
                <p><strong>Registros Executados:</strong> ${dadosExecutados.length}</p>
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Resumo Comparativo</div>
            </div>
            <div style="padding: 15px;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-bottom: 20px;">
                    <div class="summary-box" style="background-color: #f8f9fa; padding: 15px;">
                        <h4>Valor Planejado</h4>
                        <div style="font-size: 24px; font-weight: bold; color: #4361ee;">${formatarMoeda(valoresPlanejados.total)}</div>
                        <p>Orçamento previsto para o exercício</p>
                    </div>
                    
                    <div class="summary-box" style="background-color: #f8f9fa; padding: 15px;">
                        <h4>Valor Empenhado</h4>
                        <div style="font-size: 24px; font-weight: bold; color: #7209b7;">${formatarMoeda(valoresExecutados.empenhado)}</div>
                        <p>${formatarPercentual(percentuais.empenhado)} do planejado</p>
                    </div>
                    
                    <div class="summary-box" style="background-color: #f8f9fa; padding: 15px;">
                        <h4>Valor Liquidado</h4>
                        <div style="font-size: 24px; font-weight: bold; color: #f72585;">${formatarMoeda(valoresExecutados.liquidado)}</div>
                        <p>${formatarPercentual(percentuais.liquidado)} do planejado</p>
                    </div>
                    
                    <div class="summary-box" style="background-color: #f8f9fa; padding: 15px;">
                        <h4>Valor Pago</h4>
                        <div style="font-size: 24px; font-weight: bold; color: #4cc9f0;">${formatarMoeda(valoresExecutados.pago)}</div>
                        <p>${formatarPercentual(percentuais.pago)} do planejado</p>
                    </div>
                </div>
                
                <div style="height: 350px; margin-top: 30px;">
                    <canvas id="comparativoBarChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Evolução Mensal</div>
            </div>
            <div style="padding: 15px;">
                <div style="height: 350px; margin-bottom: 20px;">
                    <canvas id="evolucaoMensalChart"></canvas>
                </div>
                
                <div style="overflow-x: auto; margin-top: 20px;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Mês</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Planejado</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Empenhado</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">% Execução</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Pago</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">% Pagamento</th>
                            </tr>
                        </thead>
                        <tbody>
    `;
    
    // Meses ordenados
    const meses = Object.keys(valoresPlanejados.porMes).sort();
    
    // Adicionar linha para cada mês
    meses.forEach(mes => {
        const planejado = valoresPlanejados.porMes[mes] || 0;
        const empenhado = valoresExecutados.porMes.empenhado[mes] || 0;
        const pago = valoresExecutados.porMes.pago[mes] || 0;
        
        const percentualExecucao = planejado > 0 ? (empenhado / planejado) * 100 : 0;
        const percentualPagamento = empenhado > 0 ? (pago / empenhado) * 100 : 0;
        
        html += `
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;">${formatarMes(mes)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(planejado)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(empenhado)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarPercentual(percentualExecucao)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(pago)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarPercentual(percentualPagamento)}</td>
            </tr>
        `;
    });
    
    // Adicionar linha de total
    html += `
                <tr style="font-weight: bold; background-color: #f9f9f9;">
                    <td style="padding: 10px; border: 1px solid #ddd;">TOTAL</td>
                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(valoresPlanejados.total)}</td>
                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(valoresExecutados.empenhado)}</td>
                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarPercentual(percentuais.empenhado)}</td>
                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(valoresExecutados.pago)}</td>
                    <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarPercentual(valoresExecutados.empenhado > 0 ? (valoresExecutados.pago / valoresExecutados.empenhado) * 100 : 0)}</td>
                </tr>
            </tbody>
        </table>
        </div>
        </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Comparativo por Natureza de Despesa</div>
            </div>
            <div style="padding: 15px;">
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Natureza</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Descrição</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Planejado</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Empenhado</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Pago</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">% Execução</th>
                            </tr>
                        </thead>
                        <tbody>
    `;
    
    // Todas as naturezas de despesa (planejadas ou executadas)
    const todasNaturezas = new Set([
        ...Object.keys(valoresPlanejados.porNatureza),
        ...Object.keys(valoresExecutados.porNatureza.empenhado)
    ]);
    
    // Ordenar por valor planejado + empenhado (decrescente)
    const naturezasOrdenadas = Array.from(todasNaturezas).sort((a, b) => {
        const totalA = (valoresPlanejados.porNatureza[a] || 0) + (valoresExecutados.porNatureza.empenhado[a] || 0);
        const totalB = (valoresPlanejados.porNatureza[b] || 0) + (valoresExecutados.porNatureza.empenhado[b] || 0);
        return totalB - totalA;
    });
    
    // Adicionar linhas para as top 10 naturezas
    const topNaturezas = naturezasOrdenadas.slice(0, 10);
    
    topNaturezas.forEach(natureza => {
        const planejado = valoresPlanejados.porNatureza[natureza] || 0;
        const empenhado = valoresExecutados.porNatureza.empenhado[natureza] || 0;
        const pago = valoresExecutados.porNatureza.pago[natureza] || 0;
        
        const percentualExecucao = planejado > 0 ? (empenhado / planejado) * 100 : 0;
        const descricao = obterDescricaoNaturezaDespesa(natureza);
        
        html += `
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;">${natureza}</td>
                <td style="padding: 10px; border: 1px solid #ddd;">${descricao}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(planejado)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(empenhado)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(pago)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarPercentual(percentualExecucao)}</td>
            </tr>
        `;
    });
    
    html += `
                        </tbody>
                    </table>
                </div>
                
                <div style="height: 400px; margin-top: 30px;">
                    <canvas id="naturezasComparativoChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Análise da Execução Orçamentária</div>
            </div>
            <div style="padding: 15px;">
                <h4 style="margin-bottom: 15px;">Observações sobre a Execução x Planejamento</h4>
                <ul>
                    ${gerarObservacoesComparativo(valoresPlanejados, valoresExecutados, percentuais, exercicio)}
                </ul>
                
                <div style="margin-top: 20px;">
                    <p><strong>Recomendações Contábeis:</strong></p>
                    <ol>
                        ${gerarRecomendacoesContabeis(valoresPlanejados, valoresExecutados, percentuais, exercicio)}
                    </ol>
                </div>
            </div>
        </div>
    `;
    
    return html;
}

// Função para gerar seção de top empenhos
function gerarSecaoTopEmpenhos(dados) {
    // Filtrar registros com valor de empenho
    const registrosEmpenho = dados.filter(d => d.Valor_Empenhado > 0);
    
    // Ordenar por valor de empenho (decrescente)
    const topEmpenhos = registrosEmpenho
        .sort((a, b) => (b.Valor_Empenhado || 0) - (a.Valor_Empenhado || 0))
        .slice(0, 10); // Top 10
    
    // Gerar HTML
    let html = `
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Maiores Empenhos do Exercício</div>
            </div>
            <div style="padding: 15px;">
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Empenho</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Credor</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Natureza</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Valor Empenhado</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Liquidado</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Pago</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: center;">Status</th>
                            </tr>
                        </thead>
                        <tbody>
    `;
    
    // Adicionar linhas para cada empenho
    topEmpenhos.forEach(empenho => {
        // Determinar status de execução
        let statusExecucao;
        let statusClass;
        
        if (empenho.Valor_Pago > 0 && Math.abs(empenho.Valor_Pago - empenho.Valor_Empenhado) < 0.01) {
            statusExecucao = "Pago Integralmente";
            statusClass = "badge-success";
        } else if (empenho.Valor_Pago > 0) {
            statusExecucao = "Pago Parcialmente";
            statusClass = "badge-warning";
        } else if (empenho.Valor_Liquidado > 0) {
            statusExecucao = "Liquidado";
            statusClass = "badge-warning";
        } else {
            statusExecucao = "Empenhado";
            statusClass = "badge-danger";
        }
        
        html += `
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;">${empenho.Numero_Empenho || 'N/D'}</td>
                <td style="padding: 10px; border: 1px solid #ddd;">${empenho.Credor || 'Não informado'}</td>
                <td style="padding: 10px; border: 1px solid #ddd;">${empenho.Natureza_Despesa || 'N/D'}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(empenho.Valor_Empenhado)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(empenho.Valor_Liquidado || 0)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(empenho.Valor_Pago || 0)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">
                    <span class="badge ${statusClass}">${statusExecucao}</span>
                </td>
            </tr>
        `;
    });
    
    html += `
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    `;
    
    return html;
}

// Funções auxiliares de cálculo

// Calcular valores por fase do orçamento
function calcularValoresPorFase(dados) {
    // Obter valores relevantes
    const dotacaoInicial = somarCampoOuZero(dados, 'Valor_Planejado');
    const dotacaoAtualizada = Math.max(dotacaoInicial, somarCampoOuZero(dados, 'Valor_Atualizado'));
    const valorEmpenhado = somarCampoOuZero(dados, 'Valor_Empenhado');
    const valorLiquidado = somarCampoOuZero(dados, 'Valor_Liquidado');
    const valorPago = somarCampoOuZero(dados, 'Valor_Pago');
    
    // Calcular saldos
    const saldoOrcamentario = dotacaoAtualizada - valorEmpenhado;
    const aLiquidar = valorEmpenhado - valorLiquidado;
    const aPagar = valorLiquidado - valorPago;
    
    return {
        dotacaoInicial,
        dotacaoAtualizada,
        valorEmpenhado,
        valorLiquidado,
        valorPago,
        saldoOrcamentario,
        aLiquidar,
        aPagar
    };
}

// Calcular percentuais de execução
function calcularPercentuaisExecucao(valores) {
    const {
        dotacaoInicial,
        dotacaoAtualizada,
        valorEmpenhado,
        valorLiquidado,
        valorPago,
        saldoOrcamentario,
        aLiquidar,
        aPagar
    } = valores;
    
    // Calcular percentuais
    const percentualEmpenhado = dotacaoAtualizada > 0 ? (valorEmpenhado / dotacaoAtualizada) * 100 : 0;
    const percentualLiquidado = valorEmpenhado > 0 ? (valorLiquidado / valorEmpenhado) * 100 : 0;
    const percentualPago = valorLiquidado > 0 ? (valorPago / valorLiquidado) * 100 : 0;
    
    // Percentuais de saldos
    const percentualSaldoOrcamentario = dotacaoAtualizada > 0 ? (saldoOrcamentario / dotacaoAtualizada) * 100 : 0;
    const percentualALiquidar = valorEmpenhado > 0 ? (aLiquidar / valorEmpenhado) * 100 : 0;
    const percentualAPagar = valorLiquidado > 0 ? (aPagar / valorLiquidado) * 100 : 0;
    
    return {
        percentualEmpenhado,
        percentualLiquidado,
        percentualPago,
        percentualSaldoOrcamentario,
        percentualALiquidar,
        percentualAPagar
    };
}

function calcularExecucaoMensal(dados) {
    // Inicializar objeto para armazenar valores mensais
    const execucaoMensal = {};
    
    // Processar registros com data de empenho
    dados.filter(d => d.Data_Empenho instanceof Date).forEach(registro => {
        const data = registro.Data_Empenho;
        const mes = `${data.getFullYear()}-${String(data.getMonth() + 1).padStart(2, '0')}`;
        
        // Inicializar mês se necessário
        if (!execucaoMensal[mes]) {
            execucaoMensal[mes] = {
                empenhado: 0,
                liquidado: 0,
                pago: 0
            };
        }
        
        // Adicionar valores
        if (registro.Valor_Empenhado) {
            execucaoMensal[mes].empenhado += registro.Valor_Empenhado;
        }
    });
    
    // Processar registros com data de liquidação
    dados.filter(d => d.Data_Liquidacao instanceof Date).forEach(registro => {
        const data = registro.Data_Liquidacao;
        const mes = `${data.getFullYear()}-${String(data.getMonth() + 1).padStart(2, '0')}`;
        
        // Inicializar mês se necessário
        if (!execucaoMensal[mes]) {
            execucaoMensal[mes] = {
                empenhado: 0,
                liquidado: 0,
                pago: 0
            };
        }
        
        // Adicionar valores
        if (registro.Valor_Liquidado) {
            execucaoMensal[mes].liquidado += registro.Valor_Liquidado;
        }
    });
    
    // Processar registros com data de pagamento
    dados.filter(d => d.Data_Pagamento instanceof Date).forEach(registro => {
        const data = registro.Data_Pagamento;
        const mes = `${data.getFullYear()}-${String(data.getMonth() + 1).padStart(2, '0')}`;
        
        // Inicializar mês se necessário
        if (!execucaoMensal[mes]) {
            execucaoMensal[mes] = {
                empenhado: 0,
                liquidado: 0,
                pago: 0
            };
        }
        
        // Adicionar valores
        if (registro.Valor_Pago) {
            execucaoMensal[mes].pago += registro.Valor_Pago;
        }
    });
    
    return execucaoMensal;
}

// Agrupar por natureza de despesa
function agruparPorNaturezaDespesa(dados) {
    const porNatureza = {};
    
    dados.forEach(registro => {
        // Verificar se tem natureza de despesa
        const natureza = registro.Natureza_Despesa;
        if (!natureza) return;
        
        // Inicializar natureza se necessário
        if (!porNatureza[natureza]) {
            porNatureza[natureza] = {
                valorPlanejado: 0,
                valorEmpenhado: 0,
                valorLiquidado: 0,
                valorPago: 0,
                quantidadeEmpenhos: 0
            };
        }
        
        // Adicionar valores
        if (registro.Valor_Planejado) {
            porNatureza[natureza].valorPlanejado += registro.Valor_Planejado;
        }
        
        if (registro.Valor_Empenhado) {
            porNatureza[natureza].valorEmpenhado += registro.Valor_Empenhado;
            porNatureza[natureza].quantidadeEmpenhos++;
        }
        
        if (registro.Valor_Liquidado) {
            porNatureza[natureza].valorLiquidado += registro.Valor_Liquidado;
        }
        
        if (registro.Valor_Pago) {
            porNatureza[natureza].valorPago += registro.Valor_Pago;
        }
    });
    
    return porNatureza;
}

// Agrupar por grupo de natureza
function agruparPorGrupoNatureza(porNatureza) {
    const porGrupo = {};
    
    // Processar cada natureza
    Object.entries(porNatureza).forEach(([natureza, valores]) => {
        // Extrair grupo da natureza (primeiros dígitos)
        let grupo = '';
        
        // Tentar extrair grupo com base no código
        if (natureza && natureza.includes('.')) {
            // Formato XX.XX (categoria + grupo)
            grupo = natureza.split('.').slice(0, 2).join('.');
        } else if (natureza && natureza.length >= 3) {
            // Formato numérico
            grupo = natureza.substring(0, 3);
        } else {
            grupo = 'Outros';
        }
        
        // Obter descrição do grupo
        let descricaoGrupo = obterDescricaoGrupoNatureza(grupo);
        if (descricaoGrupo) {
            grupo = `${grupo} - ${descricaoGrupo}`;
        }
        
        // Inicializar grupo se necessário
        if (!porGrupo[grupo]) {
            porGrupo[grupo] = {
                valorPlanejado: 0,
                valorEmpenhado: 0,
                valorLiquidado: 0,
                valorPago: 0,
                quantidadeEmpenhos: 0,
                naturezas: []
            };
        }
        
        // Adicionar valores
        porGrupo[grupo].valorPlanejado += valores.valorPlanejado || 0;
        porGrupo[grupo].valorEmpenhado += valores.valorEmpenhado || 0;
        porGrupo[grupo].valorLiquidado += valores.valorLiquidado || 0;
        porGrupo[grupo].valorPago += valores.valorPago || 0;
        porGrupo[grupo].quantidadeEmpenhos += valores.quantidadeEmpenhos || 0;
        
        // Adicionar natureza ao grupo
        porGrupo[grupo].naturezas.push(natureza);
    });
    
    return porGrupo;
}

// Calcular totais por natureza
function calcularTotaisNatureza(porNatureza) {
    const totais = {
        valorPlanejado: 0,
        valorEmpenhado: 0,
        valorLiquidado: 0,
        valorPago: 0,
        quantidadeEmpenhos: 0
    };
    
    // Somar valores de todas as naturezas
    Object.values(porNatureza).forEach(valores => {
        totais.valorPlanejado += valores.valorPlanejado || 0;
        totais.valorEmpenhado += valores.valorEmpenhado || 0;
        totais.valorLiquidado += valores.valorLiquidado || 0;
        totais.valorPago += valores.valorPago || 0;
        totais.quantidadeEmpenhos += valores.quantidadeEmpenhos || 0;
    });
    
    return totais;
}

// Agrupar valores por mês
function agruparValoresPorMes(dados, campo) {
    const porMes = {};
    
    dados.forEach(registro => {
        let data = null;
        
        // Tentar obter data relevante
        if (campo === 'Valor_Empenhado' && registro.Data_Empenho instanceof Date) {
            data = registro.Data_Empenho;
        } else if (campo === 'Valor_Liquidado' && registro.Data_Liquidacao instanceof Date) {
            data = registro.Data_Liquidacao;
        } else if (campo === 'Valor_Pago' && registro.Data_Pagamento instanceof Date) {
            data = registro.Data_Pagamento;
        } else if (registro.Data instanceof Date) {
            // Data genérica
            data = registro.Data;
        }
        
        // Se não tem data ou valor, ignorar
        if (!data || !registro[campo]) return;
        
        // Formatar chave do mês (YYYY-MM)
        const mes = `${data.getFullYear()}-${String(data.getMonth() + 1).padStart(2, '0')}`;
        
        // Inicializar mês se necessário
        if (!porMes[mes]) {
            porMes[mes] = 0;
        }
        
        // Adicionar valor
        porMes[mes] += registro[campo];
    });
    
    return porMes;
}

// Agrupar valores por natureza
function agruparValoresPorNatureza(dados, campo) {
    const porNatureza = {};
    
    dados.forEach(registro => {
        // Se não tem natureza ou valor, ignorar
        const natureza = registro.Natureza_Despesa;
        if (!natureza || !registro[campo]) return;
        
        // Inicializar natureza se necessário
        if (!porNatureza[natureza]) {
            porNatureza[natureza] = 0;
        }
        
        // Adicionar valor
        porNatureza[natureza] += registro[campo];
    });
    
    return porNatureza;
}

// Função auxiliar para somar campo ou retornar zero
function somarCampoOuZero(dados, campo) {
    return dados.reduce((soma, item) => soma + (item[campo] || 0), 0);
}

// Obter descrição da natureza de despesa
function obterDescricaoNaturezaDespesa(codigo) {
    // Mapeamento de alguns códigos comuns
    const descricoes = {
        '3.3.90.30': 'Material de Consumo',
        '3.3.90.39': 'Outros Serviços de Terceiros - PJ',
        '3.3.90.36': 'Outros Serviços de Terceiros - PF',
        '3.3.90.14': 'Diárias',
        '3.3.90.33': 'Passagens e Despesas com Locomoção',
        '3.3.90.93': 'Indenizações e Restituições',
        '3.3.90.92': 'Despesas de Exercícios Anteriores',
        '3.3.90.40': 'Serviços de Tecnologia da Informação',
        '3.3.90.37': 'Locação de Mão-de-Obra',
        '3.3.90.46': 'Auxílio-Alimentação',
        '3.3.90.49': 'Auxílio-Transporte',
        '3.3.91.39': 'Outros Serviços de Terceiros - PJ (Intra)',
        '4.4.90.51': 'Obras e Instalações',
        '4.4.90.52': 'Equipamentos e Material Permanente',
        '4.4.90.39': 'Outros Serviços de Terceiros - PJ (Investimento)',
        '3.1.90.11': 'Vencimentos e Vantagens Fixas',
        '3.1.90.13': 'Obrigações Patronais',
        '3.1.90.92': 'Despesas de Exercícios Anteriores (Pessoal)',
        '3.1.90.94': 'Indenizações e Restituições Trabalhistas'
    };
    
    // Tentar encontrar o código exato
    if (descricoes[codigo]) {
        return descricoes[codigo];
    }
    
    // Tentar resolver parcialmente pelo grupo
    for (const [chave, descricao] of Object.entries(descricoes)) {
        // Se o código começa com a mesma categoria e grupo
        if (codigo.startsWith(chave.substring(0, 5))) {
            return `Similar a ${descricao}`;
        }
    }
    
    // Descrever com base na estrutura do código
    if (codigo.startsWith('3.1')) {
        return 'Despesas com Pessoal e Encargos';
    } else if (codigo.startsWith('3.2')) {
        return 'Juros e Encargos da Dívida';
    } else if (codigo.startsWith('3.3')) {
        return 'Outras Despesas Correntes';
    } else if (codigo.startsWith('4.4')) {
        return 'Investimentos';
    } else if (codigo.startsWith('4.5')) {
        return 'Inversões Financeiras';
    } else if (codigo.startsWith('4.6')) {
        return 'Amortização da Dívida';
    }
    
    return 'Natureza de Despesa';
}

// Obter descrição do grupo de natureza
function obterDescricaoGrupoNatureza(grupo) {
    // Mapeamento de grupos comuns
    const descricoes = {
        '3.1': 'Pessoal e Encargos Sociais',
        '3.2': 'Juros e Encargos da Dívida',
        '3.3': 'Outras Despesas Correntes',
        '4.4': 'Investimentos',
        '4.5': 'Inversões Financeiras',
        '4.6': 'Amortização da Dívida'
    };
    
    return descricoes[grupo] || null;
}

// Funções para gerar observações e recomendações

// Gerar observações para o relatório de execução
function gerarObservacoesExecucao(valores, percentuais, exercicio) {
    const observacoes = [];
    
    // Avaliar nível de execução orçamentária
    if (percentuais.percentualEmpenhado < 50) {
        observacoes.push(`O percentual de empenho em relação à dotação está abaixo de 50% (${formatarPercentual(percentuais.percentualEmpenhado)}), indicando um ritmo insuficiente de execução orçamentária que pode comprometer o atingimento das metas institucionais.`);
    } else if (percentuais.percentualEmpenhado < 80) {
        observacoes.push(`A execução orçamentária apresenta ritmo moderado, com ${formatarPercentual(percentuais.percentualEmpenhado)} da dotação já empenhada.`);
    } else {
        observacoes.push(`O órgão apresenta alto percentual de execução orçamentária, com ${formatarPercentual(percentuais.percentualEmpenhado)} da dotação já empenhada.`);
    }
    
    // Avaliar liquidação e pagamento
    if (percentuais.percentualLiquidado < 70) {
        observacoes.push(`Há um volume significativo de despesas empenhadas não liquidadas (${formatarPercentual(100 - percentuais.percentualLiquidado)}), o que pode indicar atrasos na entrega de bens ou prestação de serviços.`);
    }
    
    if (percentuais.percentualPago < 90 && percentuais.percentualLiquidado > 50) {
        observacoes.push(`Existem valores expressivos liquidados e não pagos (${formatarMoeda(valores.aPagar)}), o que pode comprometer o fluxo financeiro e gerar passivos junto a fornecedores.`);
    }
    
    // Análise do saldo orçamentário
    if (percentuais.percentualSaldoOrcamentario > 30) {
        observacoes.push(`O órgão ainda possui ${formatarPercentual(percentuais.percentualSaldoOrcamentario)} da dotação não utilizada (${formatarMoeda(valores.saldoOrcamentario)}), que deve ser monitorada para evitar subexecução orçamentária.`);
    } else if (percentuais.percentualSaldoOrcamentario < 5) {
        observacoes.push(`O saldo orçamentário está próximo do esgotamento (${formatarPercentual(percentuais.percentualSaldoOrcamentario)}), o que pode exigir suplementação orçamentária caso surjam despesas não previstas.`);
    }
    
    // Avaliar relação entre empenho, liquidação e pagamento
    if (valores.valorEmpenhado > 0 && valores.valorLiquidado > 0 && valores.valorPago > 0) {
        // Calcular diferenças entre percentuais
        const difEmpLiq = percentuais.percentualEmpenhado - percentuais.percentualLiquidado;
        const difLiqPag = percentuais.percentualLiquidado - percentuais.percentualPago;
        
        if (difEmpLiq > 20 && difLiqPag > 20) {
            observacoes.push(`Há descompasso significativo entre empenho, liquidação e pagamento, com diferenças superiores a 20 pontos percentuais. Isto pode indicar deficiências nos controles administrativos ou dificuldades no fluxo financeiro.`);
        } else if (difEmpLiq < 5 && difLiqPag < 5) {
            observacoes.push(`A execução orçamentária está equilibrada, com pequena diferença entre os valores empenhados, liquidados e pagos, demonstrando boa gestão do fluxo financeiro.`);
        }
    }
    
    if (observacoes.length === 0) {
        observacoes.push(`A execução orçamentária apresenta-se adequada, sem pontos críticos que requeiram intervenção imediata.`);
    }
    
    return observacoes.map(obs => `<li>${obs}</li>`).join('');
}

// Gerar observações para o relatório por natureza de despesa
function gerarObservacoesNatureza(execucaoPorNatureza, totais, gruposNatureza) {
    const observacoes = [];
    
    // Verificar proporção de despesas correntes vs. capital (se houver grupos)
    if (gruposNatureza['3.1 - Pessoal e Encargos Sociais'] || gruposNatureza['3.3 - Outras Despesas Correntes']) {
        const despesasCorrente = (gruposNatureza['3.1 - Pessoal e Encargos Sociais']?.valorEmpenhado || 0) + 
                               (gruposNatureza['3.3 - Outras Despesas Correntes']?.valorEmpenhado || 0);
        
        const despesasCapital = (gruposNatureza['4.4 - Investimentos']?.valorEmpenhado || 0) + 
                              (gruposNatureza['4.5 - Inversões Financeiras']?.valorEmpenhado || 0);
        
        if (totais.valorEmpenhado > 0) {
            const percentualCorrente = (despesasCorrente / totais.valorEmpenhado) * 100;
            const percentualCapital = (despesasCapital / totais.valorEmpenhado) * 100;
            
            observacoes.push(`As despesas correntes representam ${formatarPercentual(percentualCorrente)} do orçamento, enquanto as despesas de capital correspondem a ${formatarPercentual(percentualCapital)}.`);
            
            if (percentualCapital < 10) {
                observacoes.push(`O baixo percentual de investimentos (${formatarPercentual(percentualCapital)}) pode comprometer a modernização e ampliação da capacidade operacional da instituição no médio e longo prazo.`);
            }
        }
    }
    
    // Analisar concentração de despesas
    const naturezasOrdenadas = Object.entries(execucaoPorNatureza)
        .sort((a, b) => (b[1].valorEmpenhado || 0) - (a[1].valorEmpenhado || 0));
    
    if (naturezasOrdenadas.length > 0) {
        const [codigoMaior, dadosMaior] = naturezasOrdenadas[0];
        const descricaoMaior = obterDescricaoNaturezaDespesa(codigoMaior);
        
        if (totais.valorEmpenhado > 0) {
            const percentualMaior = (dadosMaior.valorEmpenhado / totais.valorEmpenhado) * 100;
            
            if (percentualMaior > 30) {
                observacoes.push(`Há significativa concentração de recursos (${formatarPercentual(percentualMaior)}) na natureza de despesa ${codigoMaior} - ${descricaoMaior}.`);
            }
        }
        
        // Analisar top 3 naturezas
        if (naturezasOrdenadas.length >= 3) {
            const top3Valor = naturezasOrdenadas.slice(0, 3).reduce((soma, [_, dados]) => soma + (dados.valorEmpenhado || 0), 0);
            
            if (totais.valorEmpenhado > 0) {
                const percentualTop3 = (top3Valor / totais.valorEmpenhado) * 100;
                
                if (percentualTop3 > 70) {
                    observacoes.push(`As três principais naturezas de despesa representam ${formatarPercentual(percentualTop3)} do orçamento executado, demonstrando alta concentração de recursos.`);
                }
            }
        }
    }
    
    // Analisar execução por grupo
    Object.entries(gruposNatureza).forEach(([grupo, dados]) => {
        if (dados.valorEmpenhado > 0 && dados.valorLiquidado > 0) {
            const percentualLiquidado = (dados.valorLiquidado / dados.valorEmpenhado) * 100;
            const percentualPago = dados.valorLiquidado > 0 ? (dados.valorPago / dados.valorLiquidado) * 100 : 0;
            
            // Identificar grupos com baixa liquidação
            if (percentualLiquidado < 50 && dados.valorEmpenhado > totais.valorEmpenhado * 0.05) {
                observacoes.push(`O grupo ${grupo} apresenta baixo percentual de liquidação (${formatarPercentual(percentualLiquidado)}) em relação ao empenhado.`);
            }
            
            // Identificar grupos com baixo pagamento
            if (percentualPago < 40 && dados.valorLiquidado > totais.valorLiquidado * 0.05) {
                observacoes.push(`O grupo ${grupo} apresenta baixo percentual de pagamento (${formatarPercentual(percentualPago)}) das despesas liquidadas.`);
            }
        }
    });
    
    if (observacoes.length === 0) {
        observacoes.push(`A distribuição das despesas por natureza apresenta-se equilibrada, sem concentrações que requeiram atenção especial.`);
    }
    
    return observacoes.map(obs => `<li>${obs}</li>`).join('');
}

// Gerar observações para relatório comparativo
function gerarObservacoesComparativo(planejado, executado, percentuais, exercicio) {
    const observacoes = [];
    
    // Avaliar nível geral de execução
    if (percentuais.empenhado < 70) {
        observacoes.push(`A execução orçamentária está em ${formatarPercentual(percentuais.empenhado)} do valor planejado, indicando possível subexecução do orçamento.`);
    } else if (percentuais.empenhado > 95) {
        observacoes.push(`O nível de execução está em ${formatarPercentual(percentuais.empenhado)} do planejado, demonstrando excelente capacidade de execução orçamentária.`);
    } else {
        observacoes.push(`A execução orçamentária apresenta nível adequado (${formatarPercentual(percentuais.empenhado)}), mantendo-se próxima ao planejado.`);
    }
    
    // Avaliar ciclo completo de execução
    if (executado.empenhado > 0) {
        const ratioPagoPlanejado = planejado.total > 0 ? (executado.pago / planejado.total) * 100 : 0;
        const ratioPagoEmpenhado = executado.empenhado > 0 ? (executado.pago / executado.empenhado) * 100 : 0;
        
        if (ratioPagoPlanejado < 50 && ratioPagoEmpenhado < 60) {
            observacoes.push(`O ciclo completo de execução (planejamento até pagamento) apresenta efetividade reduzida, com apenas ${formatarPercentual(ratioPagoPlanejado)} do orçamento planejado efetivamente pago.`);
        } else if (ratioPagoPlanejado > 80 && ratioPagoEmpenhado > 90) {
            observacoes.push(`O ciclo completo de execução demonstra alta eficiência, com ${formatarPercentual(ratioPagoPlanejado)} do orçamento planejado já efetivamente pago.`);
        }
    }
    
    // Analisar padrão mensal
    if (planejado.porMes && Object.keys(planejado.porMes).length > 0) {
        const meses = Object.keys(planejado.porMes).sort();
        
        // Verificar concentração nos últimos meses
        const ultimosTresMeses = meses.slice(-3);
        const totalUltimosTres = ultimosTresMeses.reduce((total, mes) => {
            return total + (executado.porMes.empenhado[mes] || 0);
        }, 0);
        
        if (executado.empenhado > 0) {
            const percentualUltimosTres = (totalUltimosTres / executado.empenhado) * 100;
            
            if (percentualUltimosTres > 40) {
                observacoes.push(`Há concentração significativa da execução orçamentária nos últimos três meses (${formatarPercentual(percentualUltimosTres)}), o que pode indicar falta de planejamento adequado e execução apressada ao final do período.`);
            }
        }
    }
    
    // Análise de naturezas de despesa
    if (planejado.porNatureza && executado.porNatureza.empenhado) {
        const naturezasComuns = new Set([
            ...Object.keys(planejado.porNatureza),
            ...Object.keys(executado.porNatureza.empenhado)
        ]);
        
        // Identificar naturezas com grande diferença entre planejado e executado
        let naturezasSubexecutadas = [];
        let naturezasSobreexecutadas = [];
        
        naturezasComuns.forEach(natureza => {
            const valorPlanejado = planejado.porNatureza[natureza] || 0;
            const valorEmpenhado = executado.porNatureza.empenhado[natureza] || 0;
            
            if (valorPlanejado > 0) {
                const percentualExecucao = (valorEmpenhado / valorPlanejado) * 100;
                
                // Subexecução
                if (percentualExecucao < 50 && valorPlanejado > planejado.total * 0.05) {
                    naturezasSubexecutadas.push({
                        natureza,
                        percentual: percentualExecucao,
                        valor: valorPlanejado
                    });
                }
                
                // Sobreexecução
                if (percentualExecucao > 120 && valorEmpenhado > executado.empenhado * 0.05) {
                    naturezasSobreexecutadas.push({
                        natureza,
                        percentual: percentualExecucao,
                        valor: valorEmpenhado
                    });
                }
            }
        });
        
        // Ordenar por valor (decrescente)
        naturezasSubexecutadas.sort((a, b) => b.valor - a.valor);
        naturezasSobreexecutadas.sort((a, b) => b.valor - a.valor);
        
        // Adicionar observações
        if (naturezasSubexecutadas.length > 0) {
            const top = naturezasSubexecutadas[0];
            const descricao = obterDescricaoNaturezaDespesa(top.natureza);
            
            observacoes.push(`A natureza de despesa ${top.natureza} (${descricao}) apresenta subexecução significativa, com apenas ${formatarPercentual(top.percentual)} do valor planejado efetivamente empenhado.`);
        }
        
        if (naturezasSobreexecutadas.length > 0) {
            const top = naturezasSobreexecutadas[0];
            const descricao = obterDescricaoNaturezaDespesa(top.natureza);
            
            observacoes.push(`A natureza de despesa ${top.natureza} (${descricao}) apresenta execução acima do planejado, com ${formatarPercentual(top.percentual)} de execução em relação ao valor inicial.`);
        }
    }
    
    if (observacoes.length === 0) {
        observacoes.push(`A comparação entre o planejado e o executado não apresenta divergências significativas que requeiram atenção especial.`);
    }
    
    return observacoes.map(obs => `<li>${obs}</li>`).join('');
}

// Gerar recomendações contábeis
function gerarRecomendacoesContabeis(planejado, executado, percentuais, exercicio) {
    const recomendacoes = [];
    
    // Recomendações baseadas no nível de execução
    if (percentuais.empenhado < 70) {
        recomendacoes.push(`Revisar o planejamento de contratações para acelerar a execução orçamentária, evitando subexecução no exercício ${exercicio}.`);
    }
    
    if (percentuais.pago < 60 && executado.liquidado > executado.pago * 1.3) {
        recomendacoes.push(`Priorizar o pagamento das despesas já liquidadas para reduzir o volume de obrigações em aberto e melhorar a situação com fornecedores.`);
    }
    
    // Recomendações para melhorar o equilíbrio
    if (executado.empenhado > 0 && planejado.total > 0) {
        // Verificar distribuição mensal
        if (planejado.porMes && executado.porMes.empenhado) {
            const meses = Object.keys(planejado.porMes).sort();
            
            // Verificar concentração nos últimos meses
            const ultimosTresMeses = meses.slice(-3);
            const totalUltimosTres = ultimosTresMeses.reduce((total, mes) => {
                return total + (executado.porMes.empenhado[mes] || 0);
            }, 0);
            
            const percentualUltimosTres = (totalUltimosTres / executado.empenhado) * 100;
            
            if (percentualUltimosTres > 40) {
                recomendacoes.push(`Implementar cronograma de execução orçamentária com distribuição mais equilibrada ao longo do exercício, evitando concentração excessiva de empenhos nos últimos meses.`);
            }
        }
    }
    
    // Recomendações para melhoria do planejamento
    if (planejado.porNatureza && executado.porNatureza.empenhado) {
        const naturezasComuns = new Set([
            ...Object.keys(planejado.porNatureza),
            ...Object.keys(executado.porNatureza.empenhado)
        ]);
        
        // Verificar divergências significativas
        let temDivergencias = false;
        
        naturezasComuns.forEach(natureza => {
            const valorPlanejado = planejado.porNatureza[natureza] || 0;
            const valorEmpenhado = executado.porNatureza.empenhado[natureza] || 0;
            
            if (valorPlanejado > 0) {
                const percentualExecucao = (valorEmpenhado / valorPlanejado) * 100;
                
                // Divergências significativas
                if ((percentualExecucao < 50 || percentualExecucao > 150) && 
                    (valorPlanejado > planejado.total * 0.05 || valorEmpenhado > executado.empenhado * 0.05)) {
                    temDivergencias = true;
                }
            }
        });
        
        if (temDivergencias) {
            recomendacoes.push(`Revisar as metodologias de planejamento orçamentário, especialmente para naturezas com grandes divergências entre planejado e executado, visando maior acurácia nas previsões futuras.`);
        }
    }
    
    // Recomendações padrão se não houver outras específicas
    if (recomendacoes.length === 0) {
        recomendacoes.push(`Manter o monitoramento periódico da execução orçamentária, especialmente do ritmo de liquidação e pagamento, para garantir a efetividade do gasto público.`);
    }
    
    return recomendacoes.map(rec => `<li>${rec}</li>`).join('');
}

// Relatórios Financeiros Avançados para Dashboard SUAD
// Complemento ao módulo de relatórios contábeis

// Funções para relatórios específicos adicionais

// 4. Relatório Financeiro de Liquidação
function gerarRelatorioFinanceiroLiquidacao(dados, metadados, exercicio) {
    // Filtrar dados relevantes
    const dadosExercicio = dados.filter(d => !d.Exercicio || d.Exercicio.toString() === exercicio.toString());
    
    // Filtrar apenas registros liquidados
    const registrosLiquidados = dadosExercicio.filter(d => d.Valor_Liquidado > 0);
    
    // Ordenar por data de liquidação
    registrosLiquidados.sort((a, b) => {
        if (a.Data_Liquidacao instanceof Date && b.Data_Liquidacao instanceof Date) {
            return b.Data_Liquidacao - a.Data_Liquidacao;
        }
        return 0;
    });
    
    // Calcular totais
    const totalLiquidado = registrosLiquidados.reduce((soma, item) => soma + (item.Valor_Liquidado || 0), 0);
    const totalPago = registrosLiquidados.reduce((soma, item) => soma + (item.Valor_Pago || 0), 0);
    const totalAPagar = totalLiquidado - totalPago;
    
    // Agrupar por mês
    const liquidacaoPorMes = {};
    registrosLiquidados.forEach(registro => {
        if (registro.Data_Liquidacao instanceof Date) {
            const mes = `${registro.Data_Liquidacao.getFullYear()}-${String(registro.Data_Liquidacao.getMonth() + 1).padStart(2, '0')}`;
            
            if (!liquidacaoPorMes[mes]) {
                liquidacaoPorMes[mes] = {
                    valorLiquidado: 0,
                    valorPago: 0,
                    quantidade: 0
                };
            }
            
            liquidacaoPorMes[mes].valorLiquidado += (registro.Valor_Liquidado || 0);
            liquidacaoPorMes[mes].valorPago += (registro.Valor_Pago || 0);
            liquidacaoPorMes[mes].quantidade++;
        }
    });
    
    // Agrupar por natureza de despesa
    const liquidacaoPorNatureza = {};
    registrosLiquidados.forEach(registro => {
        const natureza = registro.Natureza_Despesa || 'Não classificado';
        
        if (!liquidacaoPorNatureza[natureza]) {
            liquidacaoPorNatureza[natureza] = {
                valorLiquidado: 0,
                valorPago: 0,
                quantidade: 0
            };
        }
        
        liquidacaoPorNatureza[natureza].valorLiquidado += (registro.Valor_Liquidado || 0);
        liquidacaoPorNatureza[natureza].valorPago += (registro.Valor_Pago || 0);
        liquidacaoPorNatureza[natureza].quantidade++;
    });
    
    // Gerar HTML do relatório
    let html = `
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Informações do Relatório</div>
            </div>
            <div style="padding: 15px;">
                <p><strong>Tipo:</strong> Relatório Financeiro de Liquidação</p>
                <p><strong>Exercício:</strong> ${exercicio}</p>
                <p><strong>Data de Geração:</strong> ${new Date().toLocaleDateString('pt-BR')} ${new Date().toLocaleTimeString('pt-BR')}</p>
                <p><strong>Total de Registros Liquidados:</strong> ${registrosLiquidados.length}</p>
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Resumo de Liquidações</div>
            </div>
            <div style="padding: 15px;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <div class="summary-box" style="background-color: #f8f9fa; border-left: 4px solid #f72585; padding: 15px;">
                        <h4>Total Liquidado</h4>
                        <div style="font-size: 24px; font-weight: bold;">${formatarMoeda(totalLiquidado)}</div>
                        <p>Valor total liquidado no exercício</p>
                    </div>
                    
                    <div class="summary-box" style="background-color: #f8f9fa; border-left: 4px solid #4cc9f0; padding: 15px;">
                        <h4>Total Pago</h4>
                        <div style="font-size: 24px; font-weight: bold;">${formatarMoeda(totalPago)}</div>
                        <p>${formatarPercentual(totalLiquidado > 0 ? (totalPago / totalLiquidado) * 100 : 0)} do liquidado</p>
                    </div>
                    
                    <div class="summary-box" style="background-color: #f8f9fa; border-left: 4px solid #3a0ca3; padding: 15px;">
                        <h4>A Pagar</h4>
                        <div style="font-size: 24px; font-weight: bold; color: ${totalAPagar > 0 ? '#e74c3c' : '#2ecc71'};">${formatarMoeda(totalAPagar)}</div>
                        <p>Valores liquidados ainda não pagos</p>
                    </div>
                </div>
                
                <div style="height: 350px; margin-top: 30px;">
                    <canvas id="liquidacaoMensalChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Liquidações por Natureza de Despesa</div>
            </div>
            <div style="padding: 15px;">
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Natureza</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Descrição</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Valor Liquidado</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Valor Pago</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">A Pagar</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">% Pago</th>
                            </tr>
                        </thead>
                        <tbody>
    `;
    
    // Ordenar naturezas por valor liquidado (decrescente)
    const naturezasOrdenadas = Object.entries(liquidacaoPorNatureza)
        .sort((a, b) => b[1].valorLiquidado - a[1].valorLiquidado);
    
    // Adicionar até 10 principais naturezas
    naturezasOrdenadas.slice(0, 10).forEach(([natureza, dados]) => {
        const descricao = obterDescricaoNaturezaDespesa(natureza);
        const aPagar = dados.valorLiquidado - dados.valorPago;
        const percentualPago = dados.valorLiquidado > 0 ? (dados.valorPago / dados.valorLiquidado) * 100 : 0;
        
        html += `
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;">${natureza}</td>
                <td style="padding: 10px; border: 1px solid #ddd;">${descricao}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(dados.valorLiquidado)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(dados.valorPago)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(aPagar)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarPercentual(percentualPago)}</td>
            </tr>
        `;
    });
    
    // Adicionar linha de total
    html += `
            <tr style="font-weight: bold; background-color: #f9f9f9;">
                <td style="padding: 10px; border: 1px solid #ddd;" colspan="2">TOTAL</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(totalLiquidado)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(totalPago)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(totalAPagar)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarPercentual(totalLiquidado > 0 ? (totalPago / totalLiquidado) * 100 : 0)}</td>
            </tr>
        </tbody>
        </table>
        </div>
        
        <div style="height: 350px; margin-top: 30px;">
            <canvas id="naturezaLiquidacaoChart"></canvas>
        </div>
        </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Análise Temporal de Liquidações</div>
            </div>
            <div style="padding: 15px;">
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Mês</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Valor Liquidado</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Valor Pago</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Quantidade</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">% do Total</th>
                            </tr>
                        </thead>
                        <tbody>
    `;
    
    // Ordenar meses (cronologicamente)
    const mesesOrdenados = Object.keys(liquidacaoPorMes).sort();
    
    // Adicionar linha para cada mês
    mesesOrdenados.forEach(mes => {
        const dados = liquidacaoPorMes[mes];
        const percentualDoTotal = totalLiquidado > 0 ? (dados.valorLiquidado / totalLiquidado) * 100 : 0;
        
        html += `
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;">${formatarMes(mes)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(dados.valorLiquidado)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(dados.valorPago)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${dados.quantidade}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarPercentual(percentualDoTotal)}</td>
            </tr>
        `;
    });
    
    html += `
                </tbody>
                </table>
            </div>
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Últimas Liquidações Realizadas</div>
            </div>
            <div style="padding: 15px;">
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Data</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Documento</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Credor</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Valor</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: center;">Status</th>
                            </tr>
                        </thead>
                        <tbody>
    `;
    
    // Adicionar as últimas 10 liquidações
    registrosLiquidados.slice(0, 10).forEach(registro => {
        const statusPagamento = registro.Valor_Pago > 0 ? 
            (Math.abs(registro.Valor_Pago - registro.Valor_Liquidado) < 0.01 ? 'Pago' : 'Pago Parcialmente') : 
            'Pendente';
        
        const statusClass = statusPagamento === 'Pago' ? 'badge-success' : 
                          (statusPagamento === 'Pago Parcialmente' ? 'badge-warning' : 'badge-danger');
        
        html += `
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;">${registro.Data_Liquidacao instanceof Date ? registro.Data_Liquidacao.toLocaleDateString('pt-BR') : 'N/D'}</td>
                <td style="padding: 10px; border: 1px solid #ddd;">${registro.Numero_Liquidacao || registro.Numero_Empenho || 'N/D'}</td>
                <td style="padding: 10px; border: 1px solid #ddd;">${registro.Credor || 'Não informado'}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(registro.Valor_Liquidado)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">
                    <span class="badge ${statusClass}">${statusPagamento}</span>
                </td>
            </tr>
        `;
    });
    
    html += `
                </tbody>
                </table>
            </div>
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Análise Financeira da Liquidação</div>
            </div>
            <div style="padding: 15px;">
                <h4 style="margin-bottom: 15px;">Observações Contábeis</h4>
                <ul>
                    ${gerarObservacoesLiquidacao(registrosLiquidados, totalLiquidado, totalPago, liquidacaoPorMes)}
                </ul>
            </div>
        </div>
    `;
    
    return html;
}

// 5. Relatório de Pagamentos Realizados
function gerarRelatorioPagamentosRealizados(dados, metadados, exercicio) {
    // Filtrar dados relevantes
    const dadosExercicio = dados.filter(d => !d.Exercicio || d.Exercicio.toString() === exercicio.toString());
    
    // Filtrar apenas registros com pagamentos
    const registrosPagos = dadosExercicio.filter(d => d.Valor_Pago > 0);
    
    // Ordenar por data de pagamento
    registrosPagos.sort((a, b) => {
        if (a.Data_Pagamento instanceof Date && b.Data_Pagamento instanceof Date) {
            return b.Data_Pagamento - a.Data_Pagamento;
        }
        return 0;
    });
    
    // Calcular total pago
    const totalPago = registrosPagos.reduce((soma, item) => soma + (item.Valor_Pago || 0), 0);
    
    // Agrupar por mês
    const pagamentosPorMes = {};
    registrosPagos.forEach(registro => {
        if (registro.Data_Pagamento instanceof Date) {
            const mes = `${registro.Data_Pagamento.getFullYear()}-${String(registro.Data_Pagamento.getMonth() + 1).padStart(2, '0')}`;
            
            if (!pagamentosPorMes[mes]) {
                pagamentosPorMes[mes] = {
                    valorPago: 0,
                    quantidade: 0
                };
            }
            
            pagamentosPorMes[mes].valorPago += (registro.Valor_Pago || 0);
            pagamentosPorMes[mes].quantidade++;
        }
    });
    
    // Agrupar por natureza de despesa
    const pagamentosPorNatureza = {};
    registrosPagos.forEach(registro => {
        const natureza = registro.Natureza_Despesa || 'Não classificado';
        
        if (!pagamentosPorNatureza[natureza]) {
            pagamentosPorNatureza[natureza] = {
                valorPago: 0,
                quantidade: 0
            };
        }
        
        pagamentosPorNatureza[natureza].valorPago += (registro.Valor_Pago || 0);
        pagamentosPorNatureza[natureza].quantidade++;
    });
    
    // Agrupar por credor
    const pagamentosPorCredor = {};
    registrosPagos.forEach(registro => {
        const credor = registro.Credor || 'Não informado';
        
        if (!pagamentosPorCredor[credor]) {
            pagamentosPorCredor[credor] = {
                valorPago: 0,
                quantidade: 0
            };
        }
        
        pagamentosPorCredor[credor].valorPago += (registro.Valor_Pago || 0);
        pagamentosPorCredor[credor].quantidade++;
    });
    
    // Gerar HTML do relatório
    let html = `
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Informações do Relatório</div>
            </div>
            <div style="padding: 15px;">
                <p><strong>Tipo:</strong> Relatório de Pagamentos Realizados</p>
                <p><strong>Exercício:</strong> ${exercicio}</p>
                <p><strong>Data de Geração:</strong> ${new Date().toLocaleDateString('pt-BR')} ${new Date().toLocaleTimeString('pt-BR')}</p>
                <p><strong>Total de Pagamentos:</strong> ${registrosPagos.length}</p>
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Resumo de Pagamentos</div>
            </div>
            <div style="padding: 15px;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <div class="summary-box" style="background-color: #f8f9fa; border-left: 4px solid #4cc9f0; padding: 15px;">
                        <h4>Total Pago</h4>
                        <div style="font-size: 24px; font-weight: bold;">${formatarMoeda(totalPago)}</div>
                        <p>Valor total pago no exercício</p>
                    </div>
                    
                    <div class="summary-box" style="background-color: #f8f9fa; border-left: 4px solid #7209b7; padding: 15px;">
                        <h4>Quantidade de Pagamentos</h4>
                        <div style="font-size: 24px; font-weight: bold;">${registrosPagos.length}</div>
                        <p>Total de pagamentos realizados</p>
                    </div>
                    
                    <div class="summary-box" style="background-color: #f8f9fa; border-left: 4px solid #f72585; padding: 15px;">
                        <h4>Valor Médio por Pagamento</h4>
                        <div style="font-size: 24px; font-weight: bold;">${formatarMoeda(registrosPagos.length > 0 ? totalPago / registrosPagos.length : 0)}</div>
                        <p>Média de valores pagos</p>
                    </div>
                </div>
                
                <div style="height: 350px; margin-top: 30px;">
                    <canvas id="pagamentosMensalChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Pagamentos por Natureza de Despesa</div>
            </div>
            <div style="padding: 15px;">
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Natureza</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Descrição</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Valor Pago</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Quantidade</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">% do Total</th>
                            </tr>
                        </thead>
                        <tbody>
    `;
    
    // Ordenar naturezas por valor pago (decrescente)
    const naturezasOrdenadas = Object.entries(pagamentosPorNatureza)
        .sort((a, b) => b[1].valorPago - a[1].valorPago);
    
    // Adicionar até 10 principais naturezas
    naturezasOrdenadas.slice(0, 10).forEach(([natureza, dados]) => {
        const descricao = obterDescricaoNaturezaDespesa(natureza);
        const percentualDoTotal = totalPago > 0 ? (dados.valorPago / totalPago) * 100 : 0;
        
        html += `
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;">${natureza}</td>
                <td style="padding: 10px; border: 1px solid #ddd;">${descricao}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(dados.valorPago)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${dados.quantidade}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarPercentual(percentualDoTotal)}</td>
            </tr>
        `;
    });
    
    // Adicionar linha de total
    html += `
            <tr style="font-weight: bold; background-color: #f9f9f9;">
                <td style="padding: 10px; border: 1px solid #ddd;" colspan="2">TOTAL</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(totalPago)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${registrosPagos.length}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">100,00%</td>
            </tr>
        </tbody>
        </table>
        </div>
        
        <div style="height: 350px; margin-top: 30px;">
            <canvas id="naturezaPagamentoChart"></canvas>
        </div>
        </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Maiores Credores</div>
            </div>
            <div style="padding: 15px;">
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Credor</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Valor Total</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Quantidade</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Valor Médio</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">% do Total</th>
                            </tr>
                        </thead>
                        <tbody>
    `;
    
    // Ordenar credores por valor pago (decrescente)
    const credoresOrdenados = Object.entries(pagamentosPorCredor)
        .sort((a, b) => b[1].valorPago - a[1].valorPago);
    
    // Adicionar até 10 principais credores
    credoresOrdenados.slice(0, 10).forEach(([credor, dados]) => {
        const percentualDoTotal = totalPago > 0 ? (dados.valorPago / totalPago) * 100 : 0;
        const valorMedio = dados.quantidade > 0 ? dados.valorPago / dados.quantidade : 0;
        
        html += `
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;">${credor}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(dados.valorPago)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${dados.quantidade}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(valorMedio)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarPercentual(percentualDoTotal)}</td>
            </tr>
        `;
    });
    
    html += `
                </tbody>
                </table>
            </div>
            
            <div style="height: 350px; margin-top: 30px;">
                <canvas id="credoresPagamentoChart"></canvas>
            </div>
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Últimos Pagamentos Realizados</div>
            </div>
            <div style="padding: 15px;">
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Data</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Documento</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Credor</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Natureza</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Valor</th>
                            </tr>
                        </thead>
                        <tbody>
    `;
    
    // Adicionar os últimos 15 pagamentos
    registrosPagos.slice(0, 15).forEach(registro => {
        html += `
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;">${registro.Data_Pagamento instanceof Date ? registro.Data_Pagamento.toLocaleDateString('pt-BR') : 'N/D'}</td>
                <td style="padding: 10px; border: 1px solid #ddd;">${registro.Numero_Pagamento || registro.Numero_Empenho || 'N/D'}</td>
                <td style="padding: 10px; border: 1px solid #ddd;">${registro.Credor || 'Não informado'}</td>
                <td style="padding: 10px; border: 1px solid #ddd;">${registro.Natureza_Despesa || 'N/D'}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(registro.Valor_Pago)}</td>
            </tr>
        `;
    });
    
    html += `
                </tbody>
                </table>
            </div>
            </div>
        </div>
    `;
    
    return html;
}

// 6. Relatório de Restos a Pagar
function gerarRelatorioRestosPagar(dados, metadados, exercicio) {
    // Filtrar dados relevantes - executados e não totalmente pagos
    const dadosExercicio = dados.filter(d => {
        const exercicioItem = d.Exercicio ? d.Exercicio.toString() : null;
        return exercicioItem && exercicioItem < exercicio.toString() && d.Valor_Empenhado > 0;
    });
    
    // Filtrar restos a pagar - empenhos com saldo a pagar
    const restosAPagar = dadosExercicio.filter(d => {
        const valorEmpenhado = d.Valor_Empenhado || 0;
        const valorPago = d.Valor_Pago || 0;
        return valorEmpenhado > valorPago;
    });
    
    // Separar em RPP (Processados) e RPNP (Não Processados)
    const rpp = restosAPagar.filter(d => (d.Valor_Liquidado || 0) > (d.Valor_Pago || 0));
    const rpnp = restosAPagar.filter(d => (d.Valor_Liquidado || 0) <= (d.Valor_Pago || 0));
    
    // Calcular totais
    const totalEmpenhado = restosAPagar.reduce((soma, item) => soma + (item.Valor_Empenhado || 0), 0);
    const totalLiquidado = restosAPagar.reduce((soma, item) => soma + (item.Valor_Liquidado || 0), 0);
    const totalPago = restosAPagar.reduce((soma, item) => soma + (item.Valor_Pago || 0), 0);
    
    const totalRPP = rpp.reduce((soma, item) => soma + ((item.Valor_Liquidado || 0) - (item.Valor_Pago || 0)), 0);
    const totalRPNP = rpnp.reduce((soma, item) => soma + ((item.Valor_Empenhado || 0) - (item.Valor_Liquidado || 0)), 0);
    
    // Agrupar por exercício
    const restosPorExercicio = {};
    restosAPagar.forEach(registro => {
        const exercicioItem = registro.Exercicio?.toString() || 'Não informado';
        
        if (!restosPorExercicio[exercicioItem]) {
            restosPorExercicio[exercicioItem] = {
                valorEmpenhado: 0,
                valorLiquidado: 0,
                valorPago: 0,
                saldoAPagar: 0,
                quantidade: 0
            };
        }
        
        restosPorExercicio[exercicioItem].valorEmpenhado += (registro.Valor_Empenhado || 0);
        restosPorExercicio[exercicioItem].valorLiquidado += (registro.Valor_Liquidado || 0);
        restosPorExercicio[exercicioItem].valorPago += (registro.Valor_Pago || 0);
        restosPorExercicio[exercicioItem].saldoAPagar += (registro.Valor_Empenhado || 0) - (registro.Valor_Pago || 0);
        restosPorExercicio[exercicioItem].quantidade++;
    });
    
    // Agrupar por natureza de despesa
    const restosPorNatureza = {};
    restosAPagar.forEach(registro => {
        const natureza = registro.Natureza_Despesa || 'Não classificado';
        
        if (!restosPorNatureza[natureza]) {
            restosPorNatureza[natureza] = {
                valorEmpenhado: 0,
                valorLiquidado: 0,
                valorPago: 0,
                saldoAPagar: 0,
                quantidade: 0
            };
        }
        
        restosPorNatureza[natureza].valorEmpenhado += (registro.Valor_Empenhado || 0);
        restosPorNatureza[natureza].valorLiquidado += (registro.Valor_Liquidado || 0);
        restosPorNatureza[natureza].valorPago += (registro.Valor_Pago || 0);
        restosPorNatureza[natureza].saldoAPagar += (registro.Valor_Empenhado || 0) - (registro.Valor_Pago || 0);
        restosPorNatureza[natureza].quantidade++;
    });
    
    // Gerar HTML do relatório
    let html = `
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Informações do Relatório</div>
            </div>
            <div style="padding: 15px;">
                <p><strong>Tipo:</strong> Relatório de Restos a Pagar</p>
                <p><strong>Exercício Atual:</strong> ${exercicio}</p>
                <p><strong>Data de Geração:</strong> ${new Date().toLocaleDateString('pt-BR')} ${new Date().toLocaleTimeString('pt-BR')}</p>
                <p><strong>Total de Registros:</strong> ${restosAPagar.length}</p>
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Resumo de Restos a Pagar</div>
            </div>
            <div style="padding: 15px;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <div class="summary-box" style="background-color: #f8f9fa; border-left: 4px solid #4361ee; padding: 15px;">
                        <h4>Total de Restos a Pagar</h4>
                        <div style="font-size: 24px; font-weight: bold;">${formatarMoeda(totalRPP + totalRPNP)}</div>
                        <p>Valor total inscrito em Restos a Pagar</p>
                    </div>
                    
                    <div class="summary-box" style="background-color: #f8f9fa; border-left: 4px solid #f72585; padding: 15px;">
                        <h4>Restos a Pagar Processados (RPP)</h4>
                        <div style="font-size: 24px; font-weight: bold;">${formatarMoeda(totalRPP)}</div>
                        <p>${formatarPercentual((totalRPP + totalRPNP) > 0 ? (totalRPP / (totalRPP + totalRPNP)) * 100 : 0)} do total</p>
                    </div>
                    
                    <div class="summary-box" style="background-color: #f8f9fa; border-left: 4px solid #3a0ca3; padding: 15px;">
                        <h4>Restos a Pagar Não Processados (RPNP)</h4>
                        <div style="font-size: 24px; font-weight: bold;">${formatarMoeda(totalRPNP)}</div>
                        <p>${formatarPercentual((totalRPP + totalRPNP) > 0 ? (totalRPNP / (totalRPP + totalRPNP)) * 100 : 0)} do total</p>
                    </div>
                </div>
                
                <div style="height: 350px; margin-top: 30px;">
                    <canvas id="restosAPagarChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Restos a Pagar por Exercício</div>
            </div>
            <div style="padding: 15px;">
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Exercício</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Valor Empenhado</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Valor Pago</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Saldo a Pagar</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">% do Total</th>
                            </tr>
                        </thead>
                        <tbody>
    `;
    
    // Ordenar exercícios (decrescente)
    const exerciciosOrdenados = Object.keys(restosPorExercicio).sort((a, b) => b - a);
    
    // Adicionar linha para cada exercício
    exerciciosOrdenados.forEach(exercicioItem => {
        const dados = restosPorExercicio[exercicioItem];
        const percentualDoTotal = (totalRPP + totalRPNP) > 0 ? (dados.saldoAPagar / (totalRPP + totalRPNP)) * 100 : 0;
        
        html += `
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;">${exercicioItem}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(dados.valorEmpenhado)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(dados.valorPago)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(dados.saldoAPagar)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarPercentual(percentualDoTotal)}</td>
            </tr>
        `;
    });
    
    // Adicionar linha de total
    html += `
            <tr style="font-weight: bold; background-color: #f9f9f9;">
                <td style="padding: 10px; border: 1px solid #ddd;">TOTAL</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(totalEmpenhado)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(totalPago)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(totalRPP + totalRPNP)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">100,00%</td>
            </tr>
        </tbody>
        </table>
        </div>
        </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Restos a Pagar por Natureza de Despesa</div>
            </div>
            <div style="padding: 15px;">
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Natureza</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Descrição</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Saldo a Pagar</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Quantidade</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">% do Total</th>
                            </tr>
                        </thead>
                        <tbody>
    `;
    
    // Ordenar naturezas por saldo a pagar (decrescente)
    const naturezasOrdenadas = Object.entries(restosPorNatureza)
        .sort((a, b) => b[1].saldoAPagar - a[1].saldoAPagar);
    
    // Adicionar até 10 principais naturezas
    naturezasOrdenadas.slice(0, 10).forEach(([natureza, dados]) => {
        const descricao = obterDescricaoNaturezaDespesa(natureza);
        const percentualDoTotal = (totalRPP + totalRPNP) > 0 ? (dados.saldoAPagar / (totalRPP + totalRPNP)) * 100 : 0;
        
        html += `
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;">${natureza}</td>
                <td style="padding: 10px; border: 1px solid #ddd;">${descricao}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(dados.saldoAPagar)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${dados.quantidade}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarPercentual(percentualDoTotal)}</td>
            </tr>
        `;
    });
    
    html += `
                </tbody>
                </table>
            </div>
            
            <div style="height: 350px; margin-top: 30px;">
                <canvas id="naturezaRPChart"></canvas>
            </div>
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Maiores Empenhos em Restos a Pagar</div>
            </div>
            <div style="padding: 15px;">
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Empenho</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Exercício</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Credor</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Valor Empenhado</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Saldo a Pagar</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: center;">Tipo</th>
                            </tr>
                        </thead>
                        <tbody>
    `;
    
    // Ordenar empenhos por saldo a pagar (decrescente)
    const empenhosOrdenados = [...restosAPagar].sort((a, b) => {
        const saldoA = (a.Valor_Empenhado || 0) - (a.Valor_Pago || 0);
        const saldoB = (b.Valor_Empenhado || 0) - (b.Valor_Pago || 0);
        return saldoB - saldoA;
    });
    
    // Adicionar os 15 maiores empenhos
    empenhosOrdenados.slice(0, 15).forEach(registro => {
        const saldoAPagar = (registro.Valor_Empenhado || 0) - (registro.Valor_Pago || 0);
        const tipo = (registro.Valor_Liquidado || 0) > (registro.Valor_Pago || 0) ? 'RPP' : 'RPNP';
        const tipoClass = tipo === 'RPP' ? 'badge-danger' : 'badge-warning';
        
        html += `
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;">${registro.Numero_Empenho || 'N/D'}</td>
                <td style="padding: 10px; border: 1px solid #ddd;">${registro.Exercicio || 'N/D'}</td>
                <td style="padding: 10px; border: 1px solid #ddd;">${registro.Credor || 'Não informado'}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(registro.Valor_Empenhado || 0)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(saldoAPagar)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">
                    <span class="badge ${tipoClass}">${tipo}</span>
                </td>
            </tr>
        `;
    });
    
    html += `
                </tbody>
                </table>
            </div>
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Análise de Restos a Pagar</div>
            </div>
            <div style="padding: 15px;">
                <h4 style="margin-bottom: 15px;">Observações Contábeis</h4>
                <ul>
                    ${gerarObservacoesRestosPagar(restosAPagar, totalRPP, totalRPNP, restosPorExercicio)}
                </ul>
                
                <div style="margin-top: 20px;">
                    <p><strong>Recomendações:</strong></p>
                    <ol>
                        ${gerarRecomendacoesRestosPagar(restosAPagar, totalRPP, totalRPNP, restosPorExercicio)}
                    </ol>
                </div>
            </div>
        </div>
    `;
    
    return html;
}

// 7. Relatório de Execução Detalhada por Credor
function gerarRelatorioExecucaoPorCredor(dados, metadados, exercicio) {
    // Filtrar dados relevantes
    const dadosExercicio = dados.filter(d => !d.Exercicio || d.Exercicio.toString() === exercicio.toString());
    
    // Agrupar por credor
    const dadosPorCredor = {};
    dadosExercicio.forEach(registro => {
        const credor = registro.Credor || 'Não informado';
        
        if (!dadosPorCredor[credor]) {
            dadosPorCredor[credor] = {
                valorPlanejado: 0,
                valorEmpenhado: 0,
                valorLiquidado: 0,
                valorPago: 0,
                quantidadeEmpenhos: 0,
                naturezas: new Set(),
                empenhos: []
            };
        }
        
        // Adicionar valores
        if (registro.Valor_Planejado) {
            dadosPorCredor[credor].valorPlanejado += registro.Valor_Planejado;
        }
        
        if (registro.Valor_Empenhado) {
            dadosPorCredor[credor].valorEmpenhado += registro.Valor_Empenhado;
            dadosPorCredor[credor].quantidadeEmpenhos++;
            
            // Adicionar empenho à lista
            if (registro.Numero_Empenho) {
                dadosPorCredor[credor].empenhos.push({
                    numero: registro.Numero_Empenho,
                    data: registro.Data_Empenho,
                    valor: registro.Valor_Empenhado,
                    valorLiquidado: registro.Valor_Liquidado || 0,
                    valorPago: registro.Valor_Pago || 0,
                    natureza: registro.Natureza_Despesa || 'N/D'
                });
            }
        }
        
        if (registro.Valor_Liquidado) {
            dadosPorCredor[credor].valorLiquidado += registro.Valor_Liquidado;
        }
        
        if (registro.Valor_Pago) {
            dadosPorCredor[credor].valorPago += registro.Valor_Pago;
        }
        
        // Adicionar natureza
        if (registro.Natureza_Despesa) {
            dadosPorCredor[credor].naturezas.add(registro.Natureza_Despesa);
        }
    });
    
    // Converter Sets para arrays
    Object.values(dadosPorCredor).forEach(credor => {
        credor.naturezas = Array.from(credor.naturezas);
    });
    
    // Ordenar credores por valor empenhado (decrescente)
    const credoresOrdenados = Object.entries(dadosPorCredor)
        .sort((a, b) => b[1].valorEmpenhado - a[1].valorEmpenhado);
    
    // Calcular totais
    const totalEmpenhado = credoresOrdenados.reduce((soma, [_, dados]) => soma + dados.valorEmpenhado, 0);
    const totalLiquidado = credoresOrdenados.reduce((soma, [_, dados]) => soma + dados.valorLiquidado, 0);
    const totalPago = credoresOrdenados.reduce((soma, [_, dados]) => soma + dados.valorPago, 0);
    
    // Gerar HTML do relatório
    let html = `
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Informações do Relatório</div>
            </div>
            <div style="padding: 15px;">
                <p><strong>Tipo:</strong> Execução Detalhada por Credor</p>
                <p><strong>Exercício:</strong> ${exercicio}</p>
                <p><strong>Data de Geração:</strong> ${new Date().toLocaleDateString('pt-BR')} ${new Date().toLocaleTimeString('pt-BR')}</p>
                <p><strong>Total de Credores:</strong> ${credoresOrdenados.length}</p>
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Resumo de Execução por Credor</div>
            </div>
            <div style="padding: 15px;">
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Credor</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Empenhado</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Liquidado</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Pago</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Qtd. Empenhos</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">% do Total</th>
                            </tr>
                        </thead>
                        <tbody>
    `;
    
    // Adicionar até 20 principais credores
    credoresOrdenados.slice(0, 20).forEach(([credor, dados]) => {
        const percentualDoTotal = totalEmpenhado > 0 ? (dados.valorEmpenhado / totalEmpenhado) * 100 : 0;
        
        html += `
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;">${credor}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(dados.valorEmpenhado)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(dados.valorLiquidado)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(dados.valorPago)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${dados.quantidadeEmpenhos}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarPercentual(percentualDoTotal)}</td>
            </tr>
        `;
    });
    
    // Adicionar linha de total
    html += `
            <tr style="font-weight: bold; background-color: #f9f9f9;">
                <td style="padding: 10px; border: 1px solid #ddd;">TOTAL</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(totalEmpenhado)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(totalLiquidado)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(totalPago)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${credoresOrdenados.reduce((soma, [_, dados]) => soma + dados.quantidadeEmpenhos, 0)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">100,00%</td>
            </tr>
        </tbody>
        </table>
        </div>
        
        <div style="height: 350px; margin-top: 30px;">
            <canvas id="maioresCredoresChart"></canvas>
        </div>
        </div>
        </div>
    `;
    
    // Adicionar seção detalhada para os 5 maiores credores
    const top5Credores = credoresOrdenados.slice(0, 5);
    
    if (top5Credores.length > 0) {
        html += `
            <div class="card" style="margin-bottom: 20px;">
                <div class="card-header">
                    <div class="card-title">Detalhamento dos Principais Credores</div>
                </div>
                <div style="padding: 15px;">
        `;
        
        // Para cada um dos 5 maiores credores
        top5Credores.forEach(([credor, dados], index) => {
            const percentualLiquidado = dados.valorEmpenhado > 0 ? (dados.valorLiquidado / dados.valorEmpenhado) * 100 : 0;
            const percentualPago = dados.valorLiquidado > 0 ? (dados.valorPago / dados.valorLiquidado) * 100 : 0;
            
            html += `
                <div class="summary-box" style="background-color: #f8f9fa; padding: 15px; margin-bottom: 20px;">
                    <h4 style="margin-bottom: 15px; border-bottom: 1px solid #ddd; padding-bottom: 10px;">
                        ${index + 1}. ${credor}
                    </h4>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;">
                        <div>
                            <p><strong>Valor Empenhado:</strong> ${formatarMoeda(dados.valorEmpenhado)}</p>
                            <p><strong>Valor Liquidado:</strong> ${formatarMoeda(dados.valorLiquidado)} (${formatarPercentual(percentualLiquidado)})</p>
                            <p><strong>Valor Pago:</strong> ${formatarMoeda(dados.valorPago)} (${formatarPercentual(percentualPago)})</p>
                        </div>
                        
                        <div>
                            <p><strong>Quantidade de Empenhos:</strong> ${dados.quantidadeEmpenhos}</p>
                            <p><strong>Naturezas de Despesa:</strong> ${dados.naturezas.length}</p>
                            <p><strong>% do Orçamento Total:</strong> ${formatarPercentual(totalEmpenhado > 0 ? (dados.valorEmpenhado / totalEmpenhado) * 100 : 0)}</p>
                        </div>
                    </div>
                    
                    <h5 style="margin-top: 20px; margin-bottom: 10px;">Empenhos deste Credor:</h5>
                    <div style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr>
                                    <th style="padding: 8px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Empenho</th>
                                    <th style="padding: 8px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Data</th>
                                    <th style="padding: 8px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Natureza</th>
                                    <th style="padding: 8px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Valor</th>
                                    <th style="padding: 8px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Liquidado</th>
                                    <th style="padding: 8px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Pago</th>
                                </tr>
                            </thead>
                            <tbody>
            `;
            
            // Ordenar empenhos por valor (decrescente)
            const empenhosOrdenados = [...dados.empenhos].sort((a, b) => b.valor - a.valor);
            
            // Mostrar até 10 empenhos por credor
            empenhosOrdenados.slice(0, 10).forEach(empenho => {
                html += `
                    <tr>
                        <td style="padding: 8px; border: 1px solid #ddd;">${empenho.numero}</td>
                        <td style="padding: 8px; border: 1px solid #ddd;">${empenho.data instanceof Date ? empenho.data.toLocaleDateString('pt-BR') : 'N/D'}</td>
                        <td style="padding: 8px; border: 1px solid #ddd;">${empenho.natureza}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(empenho.valor)}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(empenho.valorLiquidado)}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(empenho.valorPago)}</td>
                    </tr>
                `;
            });
            
            html += `
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        });
        
        html += `
                </div>
            </div>
        `;
    }
    
    // Adicionar análise de concentração
    html += `
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Análise de Concentração</div>
            </div>
            <div style="padding: 15px;">
                <div style="height: 350px; margin-bottom: 20px;">
                    <canvas id="concentracaoCredoresChart"></canvas>
                </div>
                
                <div style="margin-top: 20px;">
                    <h4 style="margin-bottom: 15px;">Observações</h4>
                    <ul>
                        ${gerarObservacoesConcentracaoCredores(credoresOrdenados, totalEmpenhado)}
                    </ul>
                </div>
            </div>
        </div>
    `;
    
    return html;
}

// 8. Relatório de Indicadores de Desempenho Orçamentário
function gerarRelatorioIndicadoresDesempenho(dados, metadados, exercicio) {
    // Filtrar dados relevantes
    const dadosExercicio = dados.filter(d => !d.Exercicio || d.Exercicio.toString() === exercicio.toString());
    
    // Calcular indicadores gerais
    const indicadores = calcularIndicadoresDesempenho(dadosExercicio);
    
    // Analisar eficiência de execução (tempo entre empenho, liquidação e pagamento)
    const temposExecucao = analisarTemposExecucao(dadosExercicio);
    
    // Analisar execução por categoria/grupo
    const execucaoPorCategoria = analisarExecucaoPorCategoria(dadosExercicio);
    
    // Calcular tendências
    const tendencias = calcularTendenciasExecucao(dadosExercicio);
    
    // Gerar HTML do relatório
    let html = `
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Informações do Relatório</div>
            </div>
            <div style="padding: 15px;">
                <p><strong>Tipo:</strong> Indicadores de Desempenho Orçamentário</p>
                <p><strong>Exercício:</strong> ${exercicio}</p>
                <p><strong>Data de Geração:</strong> ${new Date().toLocaleDateString('pt-BR')} ${new Date().toLocaleTimeString('pt-BR')}</p>
                <p><strong>Total de Registros Analisados:</strong> ${dadosExercicio.length}</p>
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Indicadores Principais</div>
            </div>
            <div style="padding: 15px;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <div class="summary-box" style="background-color: #f8f9fa; border-left: 4px solid #4361ee; padding: 15px;">
                        <h4>Percentual de Execução Orçamentária</h4>
                        <div style="font-size: 24px; font-weight: bold; color: ${getColorByPercentage(indicadores.percentualExecucaoOrcamentaria)};">
                            ${formatarPercentual(indicadores.percentualExecucaoOrcamentaria)}
                        </div>
                        <p>Percentual do orçamento empenhado</p>
                        <div class="progress" style="height: 10px; background-color: #e9ecef; border-radius: 5px; overflow: hidden; margin-top: 10px;">
                            <div class="progress-bar" style="width: ${Math.min(100, indicadores.percentualExecucaoOrcamentaria)}%; height: 100%; background-color: ${getColorByPercentage(indicadores.percentualExecucaoOrcamentaria)};"></div>
                        </div>
                    </div>
                    
                    <div class="summary-box" style="background-color: #f8f9fa; border-left: 4px solid #f72585; padding: 15px;">
                        <h4>Percentual de Liquidação</h4>
                        <div style="font-size: 24px; font-weight: bold; color: ${getColorByPercentage(indicadores.percentualLiquidacao)};">
                            ${formatarPercentual(indicadores.percentualLiquidacao)}
                        </div>
                        <p>Percentual do empenhado que foi liquidado</p>
                        <div class="progress" style="height: 10px; background-color: #e9ecef; border-radius: 5px; overflow: hidden; margin-top: 10px;">
                            <div class="progress-bar" style="width: ${Math.min(100, indicadores.percentualLiquidacao)}%; height: 100%; background-color: ${getColorByPercentage(indicadores.percentualLiquidacao)};"></div>
                        </div>
                    </div>
                    
                    <div class="summary-box" style="background-color: #f8f9fa; border-left: 4px solid #4cc9f0; padding: 15px;">
                        <h4>Percentual de Pagamento</h4>
                        <div style="font-size: 24px; font-weight: bold; color: ${getColorByPercentage(indicadores.percentualPagamento)};">
                            ${formatarPercentual(indicadores.percentualPagamento)}
                        </div>
                        <p>Percentual do liquidado que foi pago</p>
                        <div class="progress" style="height: 10px; background-color: #e9ecef; border-radius: 5px; overflow: hidden; margin-top: 10px;">
                            <div class="progress-bar" style="width: ${Math.min(100, indicadores.percentualPagamento)}%; height: 100%; background-color: ${getColorByPercentage(indicadores.percentualPagamento)};"></div>
                        </div>
                    </div>
                    
                    <div class="summary-box" style="background-color: #f8f9fa; border-left: 4px solid #3a0ca3; padding: 15px;">
                        <h4>Percentual de Execução Financeira</h4>
                        <div style="font-size: 24px; font-weight: bold; color: ${getColorByPercentage(indicadores.percentualExecucaoFinanceira)};">
                            ${formatarPercentual(indicadores.percentualExecucaoFinanceira)}
                        </div>
                        <p>Percentual do orçamento efetivamente pago</p>
                        <div class="progress" style="height: 10px; background-color: #e9ecef; border-radius: 5px; overflow: hidden; margin-top: 10px;">
                            <div class="progress-bar" style="width: ${Math.min(100, indicadores.percentualExecucaoFinanceira)}%; height: 100%; background-color: ${getColorByPercentage(indicadores.percentualExecucaoFinanceira)};"></div>
                        </div>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; margin-bottom: 20px; margin-top: 20px;">
                    <div class="summary-box" style="background-color: #f8f9fa; padding: 15px;">
                        <h4>Tempo Médio de Liquidação</h4>
                        <div style="font-size: 24px; font-weight: bold; color: ${getColorByDays(temposExecucao.tempoMedioLiquidacao, true)};">
                            ${formatarDias(temposExecucao.tempoMedioLiquidacao)}
                        </div>
                        <p>Média de dias entre empenho e liquidação</p>
                    </div>
                    
                    <div class="summary-box" style="background-color: #f8f9fa; padding: 15px;">
                        <h4>Tempo Médio de Pagamento</h4>
                        <div style="font-size: 24px; font-weight: bold; color: ${getColorByDays(temposExecucao.tempoMedioPagamento, true)};">
                            ${formatarDias(temposExecucao.tempoMedioPagamento)}
                        </div>
                        <p>Média de dias entre liquidação e pagamento</p>
                    </div>
                    
                    <div class="summary-box" style="background-color: #f8f9fa; padding: 15px;">
                        <h4>Tempo Total de Processamento</h4>
                        <div style="font-size: 24px; font-weight: bold; color: ${getColorByDays(temposExecucao.tempoMedioTotal, true)};">
                            ${formatarDias(temposExecucao.tempoMedioTotal)}
                        </div>
                        <p>Média de dias do empenho até o pagamento</p>
                    </div>
                </div>
                
                <div style="height: 350px; margin-top: 30px;">
                    <canvas id="indicadoresPrincipaisChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Desempenho por Categoria Econômica</div>
            </div>
            <div style="padding: 15px;">
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Categoria</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Planejado</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Empenhado</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Pago</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">% Execução</th>
                                <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: center;">Desempenho</th>
                            </tr>
                        </thead>
                        <tbody>
    `;
    
    // Adicionar linha para cada categoria
    Object.entries(execucaoPorCategoria).forEach(([categoria, dados]) => {
        const percentualExecucao = dados.valorPlanejado > 0 ? (dados.valorEmpenhado / dados.valorPlanejado) * 100 : 0;
        
        // Determinar classificação de desempenho
        let desempenho;
        let desempenhoClass;
        
        if (percentualExecucao >= 90) {
            desempenho = "Excelente";
            desempenhoClass = "badge-success";
        } else if (percentualExecucao >= 70) {
            desempenho = "Bom";
            desempenhoClass = "badge-success";
        } else if (percentualExecucao >= 50) {
            desempenho = "Regular";
            desempenhoClass = "badge-warning";
        } else {
            desempenho = "Insuficiente";
            desempenhoClass = "badge-danger";
        }
        
        html += `
            <tr>
                <td style="padding: 10px; border: 1px solid #ddd;">${categoria}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(dados.valorPlanejado)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(dados.valorEmpenhado)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarMoeda(dados.valorPago)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarPercentual(percentualExecucao)}</td>
                <td style="padding: 10px; border: 1px solid #ddd; text-align: center;">
                    <span class="badge ${desempenhoClass}">${desempenho}</span>
                </td>
            </tr>
        `;
    });
    
    html += `
                </tbody>
                </table>
            </div>
            
            <div style="height: 350px; margin-top: 30px;">
                <canvas id="desempenhoCategoriaChart"></canvas>
            </div>
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Análise de Tendências</div>
            </div>
            <div style="padding: 15px;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                    <div>
                        <h4 style="margin-bottom: 15px;">Tendência de Execução Mensal</h4>
                        <div style="height: 300px;">
                            <canvas id="tendenciaExecucaoChart"></canvas>
                        </div>
                    </div>
                    
                    <div>
                        <h4 style="margin-bottom: 15px;">Projeção de Execução</h4>
                        <div style="height: 300px;">
                            <canvas id="projecaoExecucaoChart"></canvas>
                        </div>
                    </div>
                </div>
                
                <div style="margin-top: 30px;">
                    <h4 style="margin-bottom: 15px;">Observações sobre Tendências</h4>
                    <ul>
                        ${gerarObservacoesTendencias(tendencias, indicadores)}
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-header">
                <div class="card-title">Benchmarking e Recomendações</div>
            </div>
            <div style="padding: 15px;">
                <div style="display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 20px;">
                    <div style="flex: 1; min-width: 300px; background-color: #f8f9fa; padding: 15px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                        <h4 style="margin-bottom: 15px; color: #4361ee;">Pontuação de Desempenho Geral</h4>
                        <div style="font-size: 32px; font-weight: bold; text-align: center; margin: 20px 0; color: ${getColorByScore(indicadores.pontuacaoDesempenho)};">
                            ${indicadores.pontuacaoDesempenho.toFixed(1)}
                            <span style="font-size: 16px; display: block; color: #666; margin-top: 5px;">(0-10)</span>
                        </div>
                        <p style="text-align: center;">
                            ${getDesempenhoDescription(indicadores.pontuacaoDesempenho)}
                        </p>
                    </div>
                    
                    <div style="flex: 2; min-width: 300px;">
                        <h4 style="margin-bottom: 15px;">Comparativo com Referências</h4>
                        <div style="overflow-x: auto;">
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead>
                                    <tr>
                                        <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: left;">Indicador</th>
                                        <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Valor Atual</th>
                                        <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Meta</th>
                                        <th style="padding: 10px; background-color: #f5f5f5; border: 1px solid #ddd; text-align: right;">Atingimento</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td style="padding: 10px; border: 1px solid #ddd;">Execução Orçamentária</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarPercentual(indicadores.percentualExecucaoOrcamentaria)}</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">95,00%</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarPercentual(indicadores.percentualExecucaoOrcamentaria / 95 * 100)}</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 10px; border: 1px solid #ddd;">Execução Financeira</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarPercentual(indicadores.percentualExecucaoFinanceira)}</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">85,00%</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarPercentual(indicadores.percentualExecucaoFinanceira / 85 * 100)}</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 10px; border: 1px solid #ddd;">Tempo de Liquidação</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarDias(temposExecucao.tempoMedioLiquidacao)}</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">15 dias</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarPercentual(temposExecucao.tempoMedioLiquidacao > 0 ? Math.min(100, (15 / temposExecucao.tempoMedioLiquidacao) * 100) : 100)}</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 10px; border: 1px solid #ddd;">Tempo de Pagamento</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarDias(temposExecucao.tempoMedioPagamento)}</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">5 dias</td>
                                        <td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${formatarPercentual(temposExecucao.tempoMedioPagamento > 0 ? Math.min(100, (5 / temposExecucao.tempoMedioPagamento) * 100) : 100)}</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
                
                <div style="margin-top: 20px;">
                    <h4 style="margin-bottom: 15px;">Recomendações para Melhoria de Desempenho</h4>
                    <ol>
                        ${gerarRecomendacoesDesempenho(indicadores, temposExecucao, execucaoPorCategoria, tendencias)}
                    </ol>
                </div>
            </div>
        </div>
    `;
    
    return html;
}

// Função para calcular indicadores de desempenho
function calcularIndicadoresDesempenho(dados) {
    // Calcular valores totais
    const dotacaoAtualizada = dados.reduce((soma, item) => soma + (item.Valor_Planejado || 0), 0);
    const valorEmpenhado = dados.reduce((soma, item) => soma + (item.Valor_Empenhado || 0), 0);
    const valorLiquidado = dados.reduce((soma, item) => soma + (item.Valor_Liquidado || 0), 0);
    const valorPago = dados.reduce((soma, item) => soma + (item.Valor_Pago || 0), 0);
    
    // Calcular percentuais
    const percentualExecucaoOrcamentaria = dotacaoAtualizada > 0 ? (valorEmpenhado / dotacaoAtualizada) * 100 : 0;
    const percentualLiquidacao = valorEmpenhado > 0 ? (valorLiquidado / valorEmpenhado) * 100 : 0;
    const percentualPagamento = valorLiquidado > 0 ? (valorPago / valorLiquidado) * 100 : 0;
    const percentualExecucaoFinanceira = dotacaoAtualizada > 0 ? (valorPago / dotacaoAtualizada) * 100 : 0;
    
    // Calcular saldos
    const saldoOrcamentario = dotacaoAtualizada - valorEmpenhado;
    const percentualSaldoOrcamentario = dotacaoAtualizada > 0 ? (saldoOrcamentario / dotacaoAtualizada) * 100 : 0;
    
    // Calcular pontuação geral
    const pontuacaoDesempenho = calcularPontuacaoDesempenho(
        percentualExecucaoOrcamentaria, 
        percentualLiquidacao, 
        percentualPagamento, 
        percentualExecucaoFinanceira
    );
    
    return {
        dotacaoAtualizada,
        valorEmpenhado,
        valorLiquidado,
        valorPago,
        saldoOrcamentario,
        percentualExecucaoOrcamentaria,
        percentualLiquidacao,
        percentualPagamento,
        percentualExecucaoFinanceira,
        percentualSaldoOrcamentario,
        pontuacaoDesempenho
    };
}

// Utilitários Financeiros e Funções Complementares para Dashboard SUAD
// Complementa as implementações anteriores com funções especializadas para análise contábil

// Completa a função de cálculo de pontuação de desempenho
function calcularPontuacaoDesempenho(percentualExecucaoOrcamentaria, percentualLiquidacao, 
                                    percentualPagamento, percentualExecucaoFinanceira) {
    // Pesos dos indicadores
    const pesoExecucaoOrcamentaria = 0.35;
    const pesoLiquidacao = 0.25;
    const pesoPagamento = 0.15;
    const pesoExecucaoFinanceira = 0.25;
    
    // Normalizar percentuais para escala de 0-10
    const notaExecucaoOrcamentaria = Math.min(10, (percentualExecucaoOrcamentaria / 100) * 10);
    const notaLiquidacao = Math.min(10, (percentualLiquidacao / 100) * 10);
    const notaPagamento = Math.min(10, (percentualPagamento / 100) * 10);
    const notaExecucaoFinanceira = Math.min(10, (percentualExecucaoFinanceira / 100) * 10);
    
    // Calcular pontuação ponderada
    const pontuacao = (notaExecucaoOrcamentaria * pesoExecucaoOrcamentaria) +
                      (notaLiquidacao * pesoLiquidacao) +
                      (notaPagamento * pesoPagamento) +
                      (notaExecucaoFinanceira * pesoExecucaoFinanceira);
    
    return pontuacao;
}

// Função para analisar tempos de execução orçamentária
function analisarTemposExecucao(dados) {
    // Arrays para armazenar tempos
    const temposLiquidacao = [];
    const temposPagamento = [];
    const temposTotal = [];
    
    // Calcular tempos para cada registro
    dados.forEach(registro => {
        // Verificar se tem datas necessárias
        if (registro.Data_Empenho instanceof Date && registro.Data_Liquidacao instanceof Date) {
            // Calcular dias entre empenho e liquidação
            const diffEmpenhoLiquidacao = Math.abs(registro.Data_Liquidacao - registro.Data_Empenho);
            const diasEmpenhoLiquidacao = Math.ceil(diffEmpenhoLiquidacao / (1000 * 60 * 60 * 24));
            
            // Adicionar ao array de tempos de liquidação
            temposLiquidacao.push(diasEmpenhoLiquidacao);
        }
        
        if (registro.Data_Liquidacao instanceof Date && registro.Data_Pagamento instanceof Date) {
            // Calcular dias entre liquidação e pagamento
            const diffLiquidacaoPagamento = Math.abs(registro.Data_Pagamento - registro.Data_Liquidacao);
            const diasLiquidacaoPagamento = Math.ceil(diffLiquidacaoPagamento / (1000 * 60 * 60 * 24));
            
            // Adicionar ao array de tempos de pagamento
            temposPagamento.push(diasLiquidacaoPagamento);
        }
        
        if (registro.Data_Empenho instanceof Date && registro.Data_Pagamento instanceof Date) {
            // Calcular dias entre empenho e pagamento
            const diffEmpenhoPagamento = Math.abs(registro.Data_Pagamento - registro.Data_Empenho);
            const diasEmpenhoPagamento = Math.ceil(diffEmpenhoPagamento / (1000 * 60 * 60 * 24));
            
            // Adicionar ao array de tempos totais
            temposTotal.push(diasEmpenhoPagamento);
        }
    });
    
    // Calcular médias
    const tempoMedioLiquidacao = temposLiquidacao.length > 0 ? 
        temposLiquidacao.reduce((soma, tempo) => soma + tempo, 0) / temposLiquidacao.length : 0;
    
    const tempoMedioPagamento = temposPagamento.length > 0 ? 
        temposPagamento.reduce((soma, tempo) => soma + tempo, 0) / temposPagamento.length : 0;
    
    const tempoMedioTotal = temposTotal.length > 0 ? 
        temposTotal.reduce((soma, tempo) => soma + tempo, 0) / temposTotal.length : 0;
    
    // Calcular medianas
    const tempoMedianaLiquidacao = calcularMediana(temposLiquidacao);
    const tempoMedianaPagamento = calcularMediana(temposPagamento);
    const tempoMedianaTotal = calcularMediana(temposTotal);
    
    // Calcular percentis
    const percentil90Liquidacao = calcularPercentil(temposLiquidacao, 90);
    const percentil90Pagamento = calcularPercentil(temposPagamento, 90);
    const percentil90Total = calcularPercentil(temposTotal, 90);
    
    // Distribuição por faixas de tempo
    const distribuicaoLiquidacao = calcularDistribuicaoTempos(temposLiquidacao);
    const distribuicaoPagamento = calcularDistribuicaoTempos(temposPagamento);
    const distribuicaoTotal = calcularDistribuicaoTempos(temposTotal);
    
    return {
        tempoMedioLiquidacao,
        tempoMedioPagamento,
        tempoMedioTotal,
        tempoMedianaLiquidacao,
        tempoMedianaPagamento,
        tempoMedianaTotal,
        percentil90Liquidacao,
        percentil90Pagamento,
        percentil90Total,
        distribuicaoLiquidacao,
        distribuicaoPagamento,
        distribuicaoTotal,
        quantidadeLiquidacoes: temposLiquidacao.length,
        quantidadePagamentos: temposPagamento.length,
        quantidadeCompletos: temposTotal.length
    };
}

// Função para calcular a mediana de um array de números
function calcularMediana(array) {
    if (array.length === 0) return 0;
    
    // Ordenar array
    const ordenado = [...array].sort((a, b) => a - b);
    
    // Calcular mediana
    const meio = Math.floor(ordenado.length / 2);
    
    if (ordenado.length % 2 === 0) {
        // Se o array tem um número par de elementos, a mediana é a média dos dois elementos do meio
        return (ordenado[meio - 1] + ordenado[meio]) / 2;
    } else {
        // Se o array tem um número ímpar de elementos, a mediana é o elemento do meio
        return ordenado[meio];
    }
}

// Função para calcular percentil de um array de números
function calcularPercentil(array, percentil) {
    if (array.length === 0) return 0;
    
    // Ordenar array
    const ordenado = [...array].sort((a, b) => a - b);
    
    // Calcular índice para o percentil
    const indice = Math.ceil((percentil / 100) * ordenado.length) - 1;
    
    // Retornar o valor no índice calculado
    return ordenado[Math.max(0, Math.min(indice, ordenado.length - 1))];
}

// Função para calcular distribuição de tempos por faixas
function calcularDistribuicaoTempos(tempos) {
    // Definir faixas de tempo (em dias)
    const faixas = [
        { limite: 5, rotulo: 'Até 5 dias' },
        { limite: 15, rotulo: 'De 6 a 15 dias' },
        { limite: 30, rotulo: 'De 16 a 30 dias' },
        { limite: 60, rotulo: 'De 31 a 60 dias' },
        { limite: 90, rotulo: 'De 61 a 90 dias' },
        { limite: Infinity, rotulo: 'Mais de 90 dias' }
    ];
    
    // Inicializar contadores
    const distribuicao = faixas.map(faixa => ({
        faixa: faixa.rotulo,
        quantidade: 0,
        percentual: 0
    }));
    
    // Contar tempos por faixa
    tempos.forEach(tempo => {
        for (let i = 0; i < faixas.length; i++) {
            if (tempo <= faixas[i].limite) {
                distribuicao[i].quantidade++;
                break;
            }
        }
    });
    
    // Calcular percentuais
    if (tempos.length > 0) {
        distribuicao.forEach(item => {
            item.percentual = (item.quantidade / tempos.length) * 100;
        });
    }
    
    return distribuicao;
}

// Função para analisar execução por categoria
function analisarExecucaoPorCategoria(dados) {
    const execucaoPorCategoria = {};
    
    // Agrupar por categoria econômica
    dados.forEach(registro => {
        let categoria = registro.Categoria_Economica || 'Não classificado';
        
        // Se não tem categoria econômica explícita, tentar inferir pela natureza
        if (categoria === 'Não classificado' && registro.Natureza_Despesa) {
            const natureza = registro.Natureza_Despesa.toString();
            
            // Extrair primeiro dígito para categoria econômica
            if (natureza.charAt(0) === '3') {
                categoria = 'Despesas Correntes';
            } else if (natureza.charAt(0) === '4') {
                categoria = 'Despesas de Capital';
            }
        }
        
        // Inicializar categoria se necessário
        if (!execucaoPorCategoria[categoria]) {
            execucaoPorCategoria[categoria] = {
                valorPlanejado: 0,
                valorEmpenhado: 0,
                valorLiquidado: 0,
                valorPago: 0
            };
        }
        
        // Adicionar valores
        execucaoPorCategoria[categoria].valorPlanejado += (registro.Valor_Planejado || 0);
        execucaoPorCategoria[categoria].valorEmpenhado += (registro.Valor_Empenhado || 0);
        execucaoPorCategoria[categoria].valorLiquidado += (registro.Valor_Liquidado || 0);
        execucaoPorCategoria[categoria].valorPago += (registro.Valor_Pago || 0);
    });
    
    return execucaoPorCategoria;
}

// Função para calcular tendências de execução
function calcularTendenciasExecucao(dados) {
    // Agrupar valores por mês
    const execucaoMensal = {};
    
    // Processar empenhos
    dados.filter(d => d.Valor_Empenhado > 0 && d.Data_Empenho instanceof Date).forEach(registro => {
        const data = registro.Data_Empenho;
        const mes = `${data.getFullYear()}-${String(data.getMonth() + 1).padStart(2, '0')}`;
        
        if (!execucaoMensal[mes]) {
            execucaoMensal[mes] = {
                empenhado: 0,
                liquidado: 0,
                pago: 0
            };
        }
        
        execucaoMensal[mes].empenhado += registro.Valor_Empenhado;
    });
    
    // Processar liquidações
    dados.filter(d => d.Valor_Liquidado > 0 && d.Data_Liquidacao instanceof Date).forEach(registro => {
        const data = registro.Data_Liquidacao;
        const mes = `${data.getFullYear()}-${String(data.getMonth() + 1).padStart(2, '0')}`;
        
        if (!execucaoMensal[mes]) {
            execucaoMensal[mes] = {
                empenhado: 0,
                liquidado: 0,
                pago: 0
            };
        }
        
        execucaoMensal[mes].liquidado += registro.Valor_Liquidado;
    });
    
    // Processar pagamentos
    dados.filter(d => d.Valor_Pago > 0 && d.Data_Pagamento instanceof Date).forEach(registro => {
        const data = registro.Data_Pagamento;
        const mes = `${data.getFullYear()}-${String(data.getMonth() + 1).padStart(2, '0')}`;
        
        if (!execucaoMensal[mes]) {
            execucaoMensal[mes] = {
                empenhado: 0,
                liquidado: 0,
                pago: 0
            };
        }
        
        execucaoMensal[mes].pago += registro.Valor_Pago;
    });
    
    // Ordenar meses cronologicamente
    const mesesOrdenados = Object.keys(execucaoMensal).sort();
    
    // Calcular valores acumulados
    const execucaoAcumulada = {};
    let empenhadoAcumulado = 0;
    let liquidadoAcumulado = 0;
    let pagoAcumulado = 0;
    
    mesesOrdenados.forEach(mes => {
        empenhadoAcumulado += execucaoMensal[mes].empenhado;
        liquidadoAcumulado += execucaoMensal[mes].liquidado;
        pagoAcumulado += execucaoMensal[mes].pago;
        
        execucaoAcumulada[mes] = {
            empenhado: empenhadoAcumulado,
            liquidado: liquidadoAcumulado,
            pago: pagoAcumulado
        };
    });
    
    // Calcular ritmo médio de execução mensal
    const numMeses = mesesOrdenados.length;
    const ritmoMedioMensal = {
        empenhado: numMeses > 0 ? empenhadoAcumulado / numMeses : 0,
        liquidado: numMeses > 0 ? liquidadoAcumulado / numMeses : 0,
        pago: numMeses > 0 ? pagoAcumulado / numMeses : 0
    };
    
    // Calcular tendência linear para projeção
    const tendenciaLinear = calcularTendenciaLinear(mesesOrdenados, execucaoMensal);
    
    // Calcular projeção para os próximos meses
    const projecao = calcularProjecao(mesesOrdenados, execucaoMensal, execucaoAcumulada, tendenciaLinear);
    
    return {
        execucaoMensal,
        execucaoAcumulada,
        ritmoMedioMensal,
        tendenciaLinear,
        projecao,
        mesesOrdenados
    };
}

// Função para calcular tendência linear
function calcularTendenciaLinear(meses, execucaoMensal) {
    // Converter meses para números sequenciais (1, 2, 3, ...)
    const x = meses.map((_, index) => index + 1);
    
    // Valores mensais
    const yEmpenhado = meses.map(mes => execucaoMensal[mes].empenhado);
    const yLiquidado = meses.map(mes => execucaoMensal[mes].liquidado);
    const yPago = meses.map(mes => execucaoMensal[mes].pago);
    
    // Calcular tendência para cada série
    return {
        empenhado: calcularRegressaoLinear(x, yEmpenhado),
        liquidado: calcularRegressaoLinear(x, yLiquidado),
        pago: calcularRegressaoLinear(x, yPago)
    };
}

// Função para calcular regressão linear simples
function calcularRegressaoLinear(x, y) {
    const n = x.length;
    
    if (n === 0 || n !== y.length) {
        return { slope: 0, intercept: 0, r2: 0 };
    }
    
    // Calcular médias
    const mediaX = x.reduce((acc, val) => acc + val, 0) / n;
    const mediaY = y.reduce((acc, val) => acc + val, 0) / n;
    
    // Calcular coeficientes
    let numerador = 0;
    let denominador = 0;
    
    for (let i = 0; i < n; i++) {
        numerador += (x[i] - mediaX) * (y[i] - mediaY);
        denominador += Math.pow(x[i] - mediaX, 2);
    }
    
    // Calcular slope (coeficiente angular)
    const slope = denominador !== 0 ? numerador / denominador : 0;
    
    // Calcular intercept (intercepto)
    const intercept = mediaY - slope * mediaX;
    
    // Calcular R² (coeficiente de determinação)
    let sumSquaredErrors = 0;
    let sumSquaredTotal = 0;
    
    for (let i = 0; i < n; i++) {
        const predictedY = slope * x[i] + intercept;
        sumSquaredErrors += Math.pow(y[i] - predictedY, 2);
        sumSquaredTotal += Math.pow(y[i] - mediaY, 2);
    }
    
    const r2 = sumSquaredTotal !== 0 ? 1 - (sumSquaredErrors / sumSquaredTotal) : 0;
    
    return { slope, intercept, r2 };
}

// Função para calcular projeção de execução
function calcularProjecao(meses, execucaoMensal, execucaoAcumulada, tendenciaLinear) {
    const n = meses.length;
    
    if (n === 0) {
        return {
            mesesProjetados: [],
            valoresProjetados: {
                empenhado: [],
                liquidado: [],
                pago: []
            },
            acumuladosProjetados: {
                empenhado: [],
                liquidado: [],
                pago: []
            }
        };
    }
    
    // Último mês disponível
    const ultimoMes = meses[n - 1];
    const [anoUltimo, mesUltimo] = ultimoMes.split('-').map(Number);
    
    // Último valor acumulado
    const ultimoAcumulado = execucaoAcumulada[ultimoMes];
    
    // Número de meses a projetar
    const numMesesProjetar = 3;
    
    // Meses projetados
    const mesesProjetados = [];
    
    // Gerar meses futuros
    for (let i = 1; i <= numMesesProjetar; i++) {
        let projeçãoMes = mesUltimo + i;
        let projeçãoAno = anoUltimo;
        
        // Ajustar para o próximo ano se necessário
        if (projeçãoMes > 12) {
            projeçãoMes -= 12;
            projeçãoAno += 1;
        }
        
        mesesProjetados.push(`${projeçãoAno}-${String(projeçãoMes).padStart(2, '0')}`);
    }
    
    // Calcular valores projetados mensais
    const valoresProjetados = {
        empenhado: [],
        liquidado: [],
        pago: []
    };
    
    // Calcular valores acumulados projetados
    const acumuladosProjetados = {
        empenhado: [],
        liquidado: [],
        pago: []
    };
    
    // Para cada mês projetado
    for (let i = 0; i < numMesesProjetar; i++) {
        // Calcular valores mensais projetados usando tendência linear
        const mesTendencia = n + i + 1; // Próximo mês na sequência
        
        valoresProjetados.empenhado.push(
            Math.max(0, tendenciaLinear.empenhado.slope * mesTendencia + tendenciaLinear.empenhado.intercept)
        );
        
        valoresProjetados.liquidado.push(
            Math.max(0, tendenciaLinear.liquidado.slope * mesTendencia + tendenciaLinear.liquidado.intercept)
        );
        
        valoresProjetados.pago.push(
            Math.max(0, tendenciaLinear.pago.slope * mesTendencia + tendenciaLinear.pago.intercept)
        );
        
        // Calcular valores acumulados projetados
        acumuladosProjetados.empenhado.push(
            ultimoAcumulado.empenhado + 
            valoresProjetados.empenhado.reduce((acc, val) => acc + val, 0)
        );
        
        acumuladosProjetados.liquidado.push(
            ultimoAcumulado.liquidado + 
            valoresProjetados.liquidado.reduce((acc, val) => acc + val, 0)
        );
        
        acumuladosProjetados.pago.push(
            ultimoAcumulado.pago + 
            valoresProjetados.pago.reduce((acc, val) => acc + val, 0)
        );
    }
    
    return {
        mesesProjetados,
        valoresProjetados,
        acumuladosProjetados
    };
}

// Função para gerar observações sobre liquidações
function gerarObservacoesLiquidacao(registros, totalLiquidado, totalPago, liquidacaoPorMes) {
    const observacoes = [];
    
    // Analisar o percentual de pagamento
    const percentualPago = totalLiquidado > 0 ? (totalPago / totalLiquidado) * 100 : 0;
    
    if (percentualPago < 50) {
        observacoes.push(`O percentual de pagamento das despesas liquidadas está baixo (${formatarPercentual(percentualPago)}), o que pode indicar problemas no fluxo financeiro ou acúmulo de passivos.`);
    } else if (percentualPago > 90) {
        observacoes.push(`O percentual de pagamento das despesas liquidadas está excelente (${formatarPercentual(percentualPago)}), demonstrando boa gestão do fluxo financeiro.`);
    } else {
        observacoes.push(`O percentual de pagamento das despesas liquidadas está em nível moderado (${formatarPercentual(percentualPago)}).`);
    }
    
    // Analisar tempo médio de liquidação
    const registrosComDatas = registros.filter(
        r => r.Data_Empenho instanceof Date && r.Data_Liquidacao instanceof Date
    );
    
    if (registrosComDatas.length > 0) {
        const temposLiquidacao = registrosComDatas.map(r => {
            const diff = Math.abs(r.Data_Liquidacao - r.Data_Empenho);
            return Math.ceil(diff / (1000 * 60 * 60 * 24));
        });
        
        const tempoMedio = temposLiquidacao.reduce((acc, tempo) => acc + tempo, 0) / temposLiquidacao.length;
        
        if (tempoMedio <= 10) {
            observacoes.push(`O tempo médio de liquidação está excelente (${Math.round(tempoMedio)} dias), demonstrando agilidade no processamento de despesas.`);
        } else if (tempoMedio > 30) {
            observacoes.push(`O tempo médio de liquidação está elevado (${Math.round(tempoMedio)} dias), indicando possíveis gargalos no processo de confirmação da entrega de bens e serviços.`);
        } else {
            observacoes.push(`O tempo médio de liquidação está em nível aceitável (${Math.round(tempoMedio)} dias).`);
        }
    }
    
    // Analisar distribuição mensal
    if (Object.keys(liquidacaoPorMes).length > 1) {
        const meses = Object.keys(liquidacaoPorMes).sort();
        const ultimoMes = liquidacaoPorMes[meses[meses.length - 1]];
        const mediaOutrosMeses = meses.slice(0, -1).reduce(
            (acc, mes) => acc + liquidacaoPorMes[mes].valorLiquidado, 0
        ) / (meses.length - 1);
        
        if (ultimoMes.valorLiquidado > mediaOutrosMeses * 2) {
            observacoes.push(`Há uma concentração significativa de liquidações no último mês analisado (${formatarPercentual(ultimoMes.valorLiquidado / totalLiquidado * 100)} do total), o que pode indicar acúmulo de processamento ao final do período.`);
        }
    }
    
    // Se houver poucos insights, adicionar observação padrão
    if (observacoes.length < 2) {
        observacoes.push(`A análise da liquidação de despesas não identificou padrões críticos que requeiram atenção especial.`);
    }
    
    return observacoes.map(obs => `<li>${obs}</li>`).join('');
}

// Função para gerar observações sobre restos a pagar
function gerarObservacoesRestosPagar(registros, totalRPP, totalRPNP, restosPorExercicio) {
    const observacoes = [];
    
    // Analisar proporção RPP x RPNP
    const totalRP = totalRPP + totalRPNP;
    
    if (totalRP > 0) {
        const percentualRPP = (totalRPP / totalRP) * 100;
        
        if (percentualRPP > 70) {
            observacoes.push(`Há uma concentração significativa em Restos a Pagar Processados (RPP) - ${formatarPercentual(percentualRPP)} do total. Isso indica que os bens e serviços já foram entregues e verificados, mas permanecem pendentes de pagamento.`);
        } else if (percentualRPP < 30) {
            observacoes.push(`Predominam os Restos a Pagar Não Processados (RPNP) - ${formatarPercentual(100 - percentualRPP)} do total. Isso indica um volume expressivo de despesas empenhadas que ainda aguardam a verificação da entrega de bens e serviços.`);
        }
    }
    
    // Analisar antiguidade dos restos a pagar
    const exercicios = Object.keys(restosPorExercicio).sort();
    
    if (exercicios.length > 0) {
        // Verificar se há RP de exercícios antigos (mais de 2 anos)
        const exercicioAtual = new Date().getFullYear();
        const exerciciosAntigos = exercicios.filter(ex => parseInt(ex) < exercicioAtual - 2);
        
        if (exerciciosAntigos.length > 0) {
            const valorAntigos = exerciciosAntigos.reduce(
                (acc, ex) => acc + restosPorExercicio[ex].saldoAPagar, 0
            );
            
            if (valorAntigos > 0) {
                const percentualAntigos = (valorAntigos / totalRP) * 100;
                
                if (percentualAntigos > 10) {
                    observacoes.push(`Existem Restos a Pagar com mais de 2 anos (${formatarPercentual(percentualAntigos)} do total), o que pode indicar risco de prescrição e necessidade de análise detalhada da viabilidade de liquidação e pagamento desses valores.`);
                }
            }
        }
    }
    
    // Analisar impacto no orçamento atual
    if (totalRP > 0) {
        observacoes.push(`O montante inscrito em Restos a Pagar (${formatarMoeda(totalRP)}) representa um compromisso financeiro que impacta o fluxo de caixa do exercício atual, devendo ser considerado no planejamento financeiro.`);
    }
    
    // Se houver poucos insights, adicionar observação padrão
    if (observacoes.length < 2) {
        observacoes.push(`A análise dos Restos a Pagar não identificou padrões críticos que requeiram atenção especial.`);
    }
    
    return observacoes.map(obs => `<li>${obs}</li>`).join('');
}

// Função para gerar recomendações sobre restos a pagar
function gerarRecomendacoesRestosPagar(registros, totalRPP, totalRPNP, restosPorExercicio) {
    const recomendacoes = [];
    
    const totalRP = totalRPP + totalRPNP;
    
    // Recomendações específicas conforme análise
    if (totalRPP > 0 && totalRP > 0 && (totalRPP / totalRP) > 0.5) {
        recomendacoes.push(`Priorizar o pagamento dos Restos a Pagar Processados (RPP), no valor de ${formatarMoeda(totalRPP)}, uma vez que representam despesas já liquidadas e, portanto, com obrigação reconhecida perante os fornecedores.`);
    }
    
    // Verificar RP de exercícios antigos
    const exercicios = Object.keys(restosPorExercicio).sort();
    const exercicioAtual = new Date().getFullYear();
    const exerciciosAntigos = exercicios.filter(ex => parseInt(ex) < exercicioAtual - 2);
    
    if (exerciciosAntigos.length > 0) {
        const valorAntigos = exerciciosAntigos.reduce(
            (acc, ex) => acc + restosPorExercicio[ex].saldoAPagar, 0
        );
        
        if (valorAntigos > 0) {
            recomendacoes.push(`Realizar análise criteriosa dos Restos a Pagar de exercícios anteriores a ${exercicioAtual - 2}, no valor de ${formatarMoeda(valorAntigos)}, para identificar possíveis cancelamentos por prescrição ou inexequibilidade.`);
        }
    }
    
    // Recomendações para RPNP
    if (totalRPNP > 0) {
        recomendacoes.push(`Verificar a situação atual dos Restos a Pagar Não Processados (RPNP), no valor de ${formatarMoeda(totalRPNP)}, para avaliar se os bens e serviços foram efetivamente entregues e podem ser liquidados, ou se devem ser cancelados por não cumprimento contratual.`);
    }
    
    // Recomendação de controle e monitoramento
    recomendacoes.push(`Implementar controle gerencial específico para acompanhamento dos Restos a Pagar, estabelecendo cronograma de pagamento conforme disponibilidade financeira e priorizando os mais antigos e os que possuem maior risco de prescrição.`);
    
    // Recomendação preventiva
    recomendacoes.push(`Avaliar processos de execução orçamentária e financeira para reduzir a inscrição de valores em Restos a Pagar nos próximos exercícios, buscando melhor planejamento e sincronização entre empenho, liquidação e pagamento.`);
    
    return recomendacoes.map(rec => `<li>${rec}</li>`).join('');
}

// Função para gerar observações sobre concentração de credores
function gerarObservacoesConcentracaoCredores(credoresOrdenados, totalEmpenhado) {
    const observacoes = [];
    
    if (credoresOrdenados.length === 0 || totalEmpenhado === 0) {
        observacoes.push(`Não há dados suficientes para análise de concentração de credores.`);
        return observacoes.map(obs => `<li>${obs}</li>`).join('');
    }
    
    // Analisar concentração nos top credores
    const top1 = credoresOrdenados[0];
    const percentualTop1 = (top1[1].valorEmpenhado / totalEmpenhado) * 100;
    
    if (percentualTop1 > 30) {
        observacoes.push(`Há elevada concentração de recursos em um único credor (${top1[0]}), que representa ${formatarPercentual(percentualTop1)} do orçamento empenhado. Recomenda-se avaliar a dependência e os riscos associados a esta concentração.`);
    }
    
    // Analisar top 5 credores
    if (credoresOrdenados.length >= 5) {
        const top5Valor = credoresOrdenados.slice(0, 5).reduce(
            (acc, [_, dados]) => acc + dados.valorEmpenhado, 0
        );
        
        const percentualTop5 = (top5Valor / totalEmpenhado) * 100;
        
        if (percentualTop5 > 60) {
            observacoes.push(`Os 5 maiores credores concentram ${formatarPercentual(percentualTop5)} do orçamento empenhado, indicando possível concentração de mercado ou especialização nos produtos/serviços adquiridos.`);
        }
    }
    
    // Analisar conversão para pagamento por credor
    const credoresComBaixaConversao = credoresOrdenados
        .filter(([_, dados]) => 
            dados.valorEmpenhado > totalEmpenhado * 0.05 && // Pelo menos 5% do total
            dados.valorPago < dados.valorEmpenhado * 0.5 // Menos de 50% pago
        );
    
    if (credoresComBaixaConversao.length > 0) {
        const exemplo = credoresComBaixaConversao[0][0];
        observacoes.push(`Identificados ${credoresComBaixaConversao.length} credores significativos com baixa conversão de empenho em pagamento (menos de 50%), como ${exemplo}. Isto pode indicar atrasos na entrega de bens/serviços ou gargalos no processo de liquidação e pagamento.`);
    }
    
    // Analisar diversificação
    if (credoresOrdenados.length > 20) {
        observacoes.push(`Há boa diversificação de credores (${credoresOrdenados.length} no total), o que tende a reduzir riscos de dependência e favorece a competitividade nas contratações.`);
    } else if (credoresOrdenados.length < 10 && totalEmpenhado > 0) {
        observacoes.push(`O número de credores é relativamente baixo (${credoresOrdenados.length}), o que pode indicar restrições de mercado ou especificidade nas contratações realizadas.`);
    }
    
    // Se houver poucos insights, adicionar observação padrão
    if (observacoes.length < 2) {
        observacoes.push(`A análise de concentração de credores não identificou padrões críticos que requeiram atenção especial.`);
    }
    
    return observacoes.map(obs => `<li>${obs}</li>`).join('');
}

// Função para gerar observações sobre tendências
function gerarObservacoesTendencias(tendencias, indicadores) {
    const observacoes = [];
    
    // Verificar se há dados suficientes
    if (!tendencias.mesesOrdenados || tendencias.mesesOrdenados.length < 2) {
        observacoes.push(`Não há dados suficientes para análise de tendências (mínimo de 2 meses necessários).`);
        return observacoes.map(obs => `<li>${obs}</li>`).join('');
    }
    
    // Analisar tendência de crescimento/decrescimento
    const { empenhado, liquidado, pago } = tendencias.tendenciaLinear;
    
    if (empenhado.slope > 0) {
        observacoes.push(`A tendência de empenhos é de crescimento (${formatarMoeda(empenhado.slope)} por mês), indicando aceleração na execução orçamentária.`);
    } else if (empenhado.slope < 0) {
        observacoes.push(`A tendência de empenhos é de redução (${formatarMoeda(Math.abs(empenhado.slope))} por mês), indicando desaceleração na execução orçamentária.`);
    }
    
    if (pago.slope > 0 && Math.abs(pago.slope) > Math.abs(empenhado.slope)) {
        observacoes.push(`A execução financeira (pagamentos) apresenta crescimento mais acelerado que os empenhos, indicando esforço para redução de passivos e melhoria do fluxo financeiro.`);
    } else if (pago.slope < 0 && empenhado.slope > 0) {
        observacoes.push(`Há um descompasso entre a tendência de empenhos (crescente) e pagamentos (decrescente), o que pode indicar acúmulo progressivo de obrigações não pagas.`);
    }
    
    // Analisar sazonalidade
    const mesesOrdenados = tendencias.mesesOrdenados;
    if (mesesOrdenados.length >= 6) {
        // Verificar concentração nos últimos meses
        const ultimosTresMeses = mesesOrdenados.slice(-3);
        const valorUltimosTres = ultimosTresMeses.reduce(
            (acc, mes) => acc + tendencias.execucaoMensal[mes].empenhado, 0
        );
        
        const valorTotal = Object.values(tendencias.execucaoMensal).reduce(
            (acc, dados) => acc + dados.empenhado, 0
        );
        
        if (valorTotal > 0) {
            const percentualUltimosTres = (valorUltimosTres / valorTotal) * 100;
            
            if (percentualUltimosTres > 50) {
                observacoes.push(`Há forte concentração da execução nos últimos 3 meses analisados (${formatarPercentual(percentualUltimosTres)} do total), indicando possível padrão sazonal ou acúmulo de execução ao final do período.`);
            }
        }
    }
    
    // Analisar projeção
    if (tendencias.projecao && tendencias.projecao.acumuladosProjetados) {
        const ultimoMes = mesesOrdenados[mesesOrdenados.length - 1];
        const ultimoAcumulado = tendencias.execucaoAcumulada[ultimoMes];
        
        // Projeção de execução final
        const execucaoFinalProjetada = tendencias.projecao.acumuladosProjetados.empenhado.length > 0 ?
            tendencias.projecao.acumuladosProjetados.empenhado[tendencias.projecao.acumuladosProjetados.empenhado.length - 1] :
            ultimoAcumulado.empenhado;
        
        // Projeção de execução financeira final
        const execucaoFinanceiraFinalProjetada = tendencias.projecao.acumuladosProjetados.pago.length > 0 ?
            tendencias.projecao.acumuladosProjetados.pago[tendencias.projecao.acumuladosProjetados.pago.length - 1] :
            ultimoAcumulado.pago;
        
        if (indicadores.percentualExecucaoOrcamentaria < 80 && execucaoFinalProjetada > ultimoAcumulado.empenhado * 1.3) {
            observacoes.push(`A projeção indica aceleração significativa dos empenhos nos próximos meses, atingindo aproximadamente ${formatarMoeda(execucaoFinalProjetada)} até o final do período projetado.`);
        } else if (indicadores.percentualExecucaoOrcamentaria < 60) {
            observacoes.push(`Mesmo com a projeção de crescimento, o ritmo atual aponta para possível subexecução orçamentária ao final do período.`);
        }
        
        if (execucaoFinanceiraFinalProjetada < execucaoFinalProjetada * 0.7) {
            observacoes.push(`A projeção indica que a execução financeira (pagamentos) continuará defasada em relação à execução orçamentária, com diferença projetada de aproximadamente ${formatarMoeda(execucaoFinalProjetada - execucaoFinanceiraFinalProjetada)}.`);
        }
    }
    
    // Se houver poucos insights, adicionar observação padrão
    if (observacoes.length < 2) {
        observacoes.push(`A análise de tendências não identificou padrões críticos que requeiram atenção especial.`);
    }
    
    return observacoes.map(obs => `<li>${obs}</li>`).join('');
}

// Função para gerar recomendações de desempenho
function gerarRecomendacoesDesempenho(indicadores, temposExecucao, execucaoPorCategoria, tendencias) {
    const recomendacoes = [];
    
    // Recomendações baseadas no nível de execução orçamentária
    if (indicadores.percentualExecucaoOrcamentaria < 70) {
        recomendacoes.push(`Intensificar o ritmo de execução orçamentária, que atualmente está em ${formatarPercentual(indicadores.percentualExecucaoOrcamentaria)}, identificando gargalos no processo de contratação e empenho.`);
    }
    
    // Recomendações baseadas na execução financeira
    if (indicadores.percentualExecucaoFinanceira < 50) {
        recomendacoes.push(`Priorizar a liquidação e pagamento das despesas já empenhadas, uma vez que a execução financeira (${formatarPercentual(indicadores.percentualExecucaoFinanceira)}) está significativamente abaixo da execução orçamentária.`);
    }
    
    // Recomendações baseadas no tempo de processamento
    if (temposExecucao.tempoMedioLiquidacao > 30) {
        recomendacoes.push(`Revisar os processos de liquidação para reduzir o tempo médio atual (${Math.round(temposExecucao.tempoMedioLiquidacao)} dias), identificando pontos de gargalo e implementando melhorias nos fluxos de trabalho.`);
    }
    
    if (temposExecucao.tempoMedioPagamento > 10) {
        recomendacoes.push(`Otimizar o processo de pagamento após liquidação, que atualmente leva em média ${Math.round(temposExecucao.tempoMedioPagamento)} dias, através da revisão de procedimentos e da programação financeira.`);
    }
    
    // Recomendações baseadas na execução por categoria
    const categorias = Object.entries(execucaoPorCategoria);
    const categoriasComBaixaExecucao = categorias.filter(([_, dados]) => {
        const percentualExecucao = dados.valorPlanejado > 0 ? (dados.valorEmpenhado / dados.valorPlanejado) * 100 : 0;
        return percentualExecucao < 50 && dados.valorPlanejado > 0;
    });
    
    if (categoriasComBaixaExecucao.length > 0) {
        const exemplos = categoriasComBaixaExecucao.slice(0, 2).map(([cat, _]) => cat).join(' e ');
        recomendacoes.push(`Analisar as categorias com baixa execução, como ${exemplos}, identificando especificidades e elaborando estratégias para acelerar a aplicação dos recursos.`);
    }
    
    // Recomendações baseadas nas tendências
    if (tendencias.mesesOrdenados && tendencias.mesesOrdenados.length >= 3) {
        const ultimosTresMeses = tendencias.mesesOrdenados.slice(-3);
        const valorUltimosTres = ultimosTresMeses.reduce(
            (acc, mes) => acc + tendencias.execucaoMensal[mes].empenhado, 0
        );
        
        const valorTotal = Object.values(tendencias.execucaoMensal).reduce(
            (acc, dados) => acc + dados.empenhado, 0
        );
        
        if (valorTotal > 0) {
            const percentualUltimosTres = (valorUltimosTres / valorTotal) * 100;
            
            if (percentualUltimosTres > 50) {
                recomendacoes.push(`Distribuir a execução orçamentária de forma mais equilibrada ao longo do exercício, evitando a concentração observada nos últimos meses (${formatarPercentual(percentualUltimosTres)} do total).`);
            }
        }
    }
    
    // Recomendações padrão
    recomendacoes.push(`Implementar monitoramento mais efetivo dos indicadores de desempenho orçamentário e financeiro, com relatórios periódicos de acompanhamento e metas de execução.`);
    
    recomendacoes.push(`Realizar análise comparativa entre o desempenho atual e o de exercícios anteriores, identificando padrões e estabelecendo referências para melhoria contínua.`);
    
    return recomendacoes.map(rec => `<li>${rec}</li>`).join('');
}

// Funções utilitárias auxiliares

// Formatar valor monetário
function formatarMoeda(valor) {
    return new Intl.NumberFormat('pt-BR', {
        style: 'currency',
        currency: 'BRL',
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    }).format(valor);
}

// Formatar percentual
function formatarPercentual(percentual) {
    return new Intl.NumberFormat('pt-BR', {
        style: 'percent',
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    }).format(percentual / 100);
}

// Formatar nome do mês
function formatarMes(mes) {
    if (!mes.includes('-')) return mes;
    
    const [ano, numMes] = mes.split('-');
    const nomesMeses = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
    
    return `${nomesMeses[parseInt(numMes) - 1]}/${ano}`;
}

// Formatar dias
function formatarDias(dias) {
    return `${Math.round(dias)} dias`;
}

// Obter cor com base em percentual
function getColorByPercentage(percentual) {
    if (percentual >= 90) return '#27ae60'; // Verde (bom)
    if (percentual >= 70) return '#2980b9'; // Azul (regular)
    if (percentual >= 50) return '#f39c12'; // Amarelo (atenção)
    return '#e74c3c'; // Vermelho (crítico)
}

// Obter cor com base em dias (invertido)
function getColorByDays(dias, inverter = false) {
    if (inverter) {
        // Para métricas onde menos dias é melhor
        if (dias <= 15) return '#27ae60'; // Verde (bom)
        if (dias <= 30) return '#2980b9'; // Azul (regular)
        if (dias <= 45) return '#f39c12'; // Amarelo (atenção)
        return '#e74c3c'; // Vermelho (crítico)
    } else {
        // Para métricas onde mais dias é melhor
        if (dias >= 45) return '#27ae60'; // Verde (bom)
        if (dias >= 30) return '#2980b9'; // Azul (regular)
        if (dias >= 15) return '#f39c12'; // Amarelo (atenção)
        return '#e74c3c'; // Vermelho (crítico)
    }
}

// Obter cor com base em pontuação
function getColorByScore(pontuacao) {
    if (pontuacao >= 8) return '#27ae60'; // Verde (bom)
    if (pontuacao >= 6) return '#2980b9'; // Azul (regular)
    if (pontuacao >= 4) return '#f39c12'; // Amarelo (atenção)
    return '#e74c3c'; // Vermelho (crítico)
}

// Obter descrição do desempenho
function getDesempenhoDescription(pontuacao) {
    if (pontuacao >= 8) return 'Excelente desempenho';
    if (pontuacao >= 6) return 'Bom desempenho';
    if (pontuacao >= 4) return 'Desempenho regular';
    return 'Desempenho insatisfatório';
}

// Função de entrada principal para gerar relatórios contábeis
function gerarRelatorioContabil(tipoRelatorio, metadados = {}, exercicio = new Date().getFullYear().toString()) {
    // Verificar se há dados disponíveis
    if (!window.filteredData || window.filteredData.length === 0) {
        return `
            <div class="alert alert-warning">
                <i class="fas fa-exclamation-triangle"></i>
                Não há dados disponíveis para gerar o relatório contábil.
                Por favor, importe uma planilha com dados orçamentários e financeiros.
            </div>
        `;
    }
    
    const dados = window.filteredData;
    
    try {
        // Chamar função específica conforme tipo de relatório solicitado
        switch (tipoRelatorio) {
            case 'execucao_orcamentaria':
                return gerarRelatorioExecucaoOrcamentaria(dados, metadados, exercicio);
                
            case 'execucao_por_natureza':
                return gerarRelatorioExecucaoPorNatureza(dados, metadados, exercicio);
                
            case 'comparativo_planejado_executado':
                return gerarRelatorioComparativoPlanejadoExecutado(dados, metadados, exercicio);
                
            case 'financeiro_liquidacao':
                return gerarRelatorioFinanceiroLiquidacao(dados, metadados, exercicio);
                
            case 'pagamentos_realizados':
                return gerarRelatorioPagamentosRealizados(dados, metadados, exercicio);
                
            case 'restos_pagar':
                return gerarRelatorioRestosPagar(dados, metadados, exercicio);
                
            case 'execucao_detalhada_credor':
                return gerarRelatorioExecucaoPorCredor(dados, metadados, exercicio);
                
            case 'indicadores_desempenho':
                return gerarRelatorioIndicadoresDesempenho(dados, metadados, exercicio);
                
            default:
                return `
                    <div class="alert alert-warning">
                        <i class="fas fa-exclamation-triangle"></i>
                        Tipo de relatório contábil não reconhecido: ${tipoRelatorio}
                    </div>
                `;
        }
    } catch (error) {
        console.error(`Erro ao gerar relatório contábil: ${error.message}`, error);
        
        return `
            <div class="alert alert-danger">
                <i class="fas fa-exclamation-circle"></i>
                <strong>Erro ao gerar relatório contábil:</strong><br>
                ${error.message}
            </div>
        `;
    }
}

// Funções para renderização de gráficos nos relatórios contábeis
function renderizarGraficosContabeis(tipoRelatorio) {
    try {
        logDebug(`Renderizando gráficos para o relatório contábil: ${tipoRelatorio}`);
        
        // Verificar se a biblioteca de gráficos está disponível
        if (typeof Chart === 'undefined') {
            throw new Error('A biblioteca Chart.js não está disponível.');
        }
        
        // Obter a paleta de cores atual
        const colorPalette = document.getElementById('colorPalette')?.value || 'default';
        const colors = colorPalettes[colorPalette] || colorPalettes.default;
        
        switch (tipoRelatorio) {
            case 'execucao_orcamentaria':
                renderizarGraficosExecucaoOrcamentaria(colors);
                break;
            case 'execucao_por_natureza':
                renderizarGraficosExecucaoPorNatureza(colors);
                break;
            case 'comparativo_planejado_executado':
                renderizarGraficosComparativoPlanejadoExecutado(colors);
                break;
            case 'financeiro_liquidacao':
                renderizarGraficosFinanceiroLiquidacao(colors);
                break;
            case 'pagamentos_realizados':
                renderizarGraficosPagamentosRealizados(colors);
                break;
            case 'restos_pagar':
                renderizarGraficosRestosPagar(colors);
                break;
            case 'execucao_detalhada_credor':
                renderizarGraficosExecucaoPorCredor(colors);
                break;
            case 'indicadores_desempenho':
                renderizarGraficosIndicadoresDesempenho(colors);
                break;
            default:
                logDebug(`Tipo de relatório não reconhecido para renderização de gráficos: ${tipoRelatorio}`);
        }
        
        logDebug(`Gráficos do relatório ${tipoRelatorio} renderizados com sucesso`);
// Continuação da função renderizarGraficosContabeis
} catch (error) {
        console.error(`Erro ao renderizar gráficos para o relatório ${tipoRelatorio}:`, error);
        logDebug(`ERRO ao renderizar gráficos: ${error.message}`);
    }
}

// Renderizar gráficos do relatório de execução orçamentária
function renderizarGraficosExecucaoOrcamentaria(colors) {
    // Obter valores para os gráficos
    const dadosFiltrados = window.filteredData || [];
    
    // Agrupar dados por mês
    const dadosPorMes = {};
    dadosFiltrados.forEach(registro => {
        if (registro.Data_Empenho instanceof Date) {
            const mes = `${registro.Data_Empenho.getFullYear()}-${String(registro.Data_Empenho.getMonth() + 1).padStart(2, '0')}`;
            
            if (!dadosPorMes[mes]) {
                dadosPorMes[mes] = {
                    empenhado: 0,
                    liquidado: 0,
                    pago: 0
                };
            }
            
            dadosPorMes[mes].empenhado += (registro.Valor_Empenhado || 0);
        }
        
        if (registro.Data_Liquidacao instanceof Date) {
            const mes = `${registro.Data_Liquidacao.getFullYear()}-${String(registro.Data_Liquidacao.getMonth() + 1).padStart(2, '0')}`;
            
            if (!dadosPorMes[mes]) {
                dadosPorMes[mes] = {
                    empenhado: 0,
                    liquidado: 0,
                    pago: 0
                };
            }
            
            dadosPorMes[mes].liquidado += (registro.Valor_Liquidado || 0);
        }
        
        if (registro.Data_Pagamento instanceof Date) {
            const mes = `${registro.Data_Pagamento.getFullYear()}-${String(registro.Data_Pagamento.getMonth() + 1).padStart(2, '0')}`;
            
            if (!dadosPorMes[mes]) {
                dadosPorMes[mes] = {
                    empenhado: 0,
                    liquidado: 0,
                    pago: 0
                };
            }
            
            dadosPorMes[mes].pago += (registro.Valor_Pago || 0);
        }
    });
    
    // Ordenar meses
    const mesesOrdenados = Object.keys(dadosPorMes).sort();
    
    // Calcular valores acumulados
    const acumulados = { empenhado: 0, liquidado: 0, pago: 0 };
    const dadosAcumulados = mesesOrdenados.map(mes => {
        acumulados.empenhado += dadosPorMes[mes].empenhado;
        acumulados.liquidado += dadosPorMes[mes].liquidado;
        acumulados.pago += dadosPorMes[mes].pago;
        
        return {
            mes,
            empenhado: acumulados.empenhado,
            liquidado: acumulados.liquidado,
            pago: acumulados.pago
        };
    });
    
    // Calcular valores para o gráfico de execução orçamentária
    const valorPlanejado = dadosFiltrados.reduce((soma, item) => soma + (item.Valor_Planejado || 0), 0);
    const valorEmpenhado = dadosFiltrados.reduce((soma, item) => soma + (item.Valor_Empenhado || 0), 0);
    const valorLiquidado = dadosFiltrados.reduce((soma, item) => soma + (item.Valor_Liquidado || 0), 0);
    const valorPago = dadosFiltrados.reduce((soma, item) => soma + (item.Valor_Pago || 0), 0);
    
    const saldoOrcamentario = valorPlanejado - valorEmpenhado;
    const aLiquidar = valorEmpenhado - valorLiquidado;
    const aPagar = valorLiquidado - valorPago;
    
    // Gráfico 1: Execução Orçamentária (acumulado)
    const execucaoChart = document.getElementById('execucaoOrcamentariaChart');
    if (execucaoChart) {
        new Chart(execucaoChart.getContext('2d'), {
            type: 'line',
            data: {
                labels: mesesOrdenados.map(mes => formatarMes(mes)),
                datasets: [
                    {
                        label: 'Empenhado',
                        data: dadosAcumulados.map(d => d.empenhado),
                        borderColor: colors[0],
                        backgroundColor: 'rgba(0, 0, 0, 0)',
                        borderWidth: 3,
                        fill: false,
                        tension: 0.3
                    },
                    {
                        label: 'Liquidado',
                        data: dadosAcumulados.map(d => d.liquidado),
                        borderColor: colors[1],
                        backgroundColor: 'rgba(0, 0, 0, 0)',
                        borderWidth: 3,
                        fill: false,
                        tension: 0.3
                    },
                    {
                        label: 'Pago',
                        data: dadosAcumulados.map(d => d.pago),
                        borderColor: colors[2],
                        backgroundColor: 'rgba(0, 0, 0, 0)',
                        borderWidth: 3,
                        fill: false,
                        tension: 0.3
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Evolução da Execução Orçamentária (Acumulado)',
                        font: { size: 16 }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + formatarMoeda(context.parsed.y);
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Mês'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Valor Acumulado'
                        },
                        ticks: {
                            callback: function(value) {
                                if (value >= 1000000) {
                                    return 'R$ ' + (value / 1000000).toFixed(1) + ' mi';
                                } else if (value >= 1000) {
                                    return 'R$ ' + (value / 1000).toFixed(1) + ' mil';
                                }
                                return 'R$ ' + value;
                            }
                        }
                    }
                }
            }
        });
    }
    
    // Gráfico 2: Saldos Orçamentários
    const saldosChart = document.getElementById('saldosOrcamentariosChart');
    if (saldosChart) {
        new Chart(saldosChart.getContext('2d'), {
            type: 'bar',
            data: {
                labels: ['Saldo Orçamentário', 'A Liquidar', 'A Pagar'],
                datasets: [{
                    label: 'Valores',
                    data: [saldoOrcamentario, aLiquidar, aPagar],
                    backgroundColor: [
                        colors[3] + '80',
                        colors[4] + '80',
                        colors[5] + '80'
                    ],
                    borderColor: [
                        colors[3],
                        colors[4],
                        colors[5]
                    ],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Análise de Saldos Orçamentários e Financeiros',
                        font: { size: 16 }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return 'Valor: ' + formatarMoeda(context.parsed.y);
                            },
                            afterLabel: function(context) {
                                let percentual = 0;
                                if (context.label === 'Saldo Orçamentário' && valorPlanejado > 0) {
                                    percentual = (saldoOrcamentario / valorPlanejado) * 100;
                                    return `${percentual.toFixed(2)}% da dotação atualizada`;
                                } else if (context.label === 'A Liquidar' && valorEmpenhado > 0) {
                                    percentual = (aLiquidar / valorEmpenhado) * 100;
                                    return `${percentual.toFixed(2)}% do valor empenhado`;
                                } else if (context.label === 'A Pagar' && valorLiquidado > 0) {
                                    percentual = (aPagar / valorLiquidado) * 100;
                                    return `${percentual.toFixed(2)}% do valor liquidado`;
                                }
                                return '';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            callback: function(value) {
                                if (value >= 1000000) {
                                    return 'R$ ' + (value / 1000000).toFixed(1) + ' mi';
                                } else if (value >= 1000) {
                                    return 'R$ ' + (value / 1000).toFixed(1) + ' mil';
                                }
                                return 'R$ ' + value;
                            }
                        }
                    }
                }
            }
        });
    }
}

// Renderizar gráficos do relatório de execução por natureza
function renderizarGraficosExecucaoPorNatureza(colors) {
    // Obter dados filtrados
    const dadosFiltrados = window.filteredData || [];
    
    // Agrupar por natureza de despesa
    const dadosPorNatureza = {};
    dadosFiltrados.forEach(registro => {
        const natureza = registro.Natureza_Despesa || 'Não classificado';
        
        if (!dadosPorNatureza[natureza]) {
            dadosPorNatureza[natureza] = {
                empenhado: 0,
                liquidado: 0,
                pago: 0
            };
        }
        
        dadosPorNatureza[natureza].empenhado += (registro.Valor_Empenhado || 0);
        dadosPorNatureza[natureza].liquidado += (registro.Valor_Liquidado || 0);
        dadosPorNatureza[natureza].pago += (registro.Valor_Pago || 0);
    });
    
    // Agrupar por grupo de natureza (primeiros dígitos)
    const dadosPorGrupo = {};
    
    Object.entries(dadosPorNatureza).forEach(([natureza, valores]) => {
        // Extrair grupo da natureza
        let grupo = '';
        
        if (natureza && natureza.includes('.')) {
            // Formato XX.XX (categoria + grupo)
            grupo = natureza.split('.').slice(0, 2).join('.');
        } else if (natureza && natureza.length >= 3) {
            // Formato numérico
            grupo = natureza.substring(0, 3);
        } else {
            grupo = 'Outros';
        }
        
        // Obter descrição do grupo
        let descricaoGrupo = obterDescricaoGrupoNatureza(grupo);
        if (descricaoGrupo) {
            grupo = `${grupo} - ${descricaoGrupo}`;
        }
        
        // Inicializar grupo se necessário
        if (!dadosPorGrupo[grupo]) {
            dadosPorGrupo[grupo] = {
                empenhado: 0,
                liquidado: 0,
                pago: 0
            };
        }
        
        // Adicionar valores
        dadosPorGrupo[grupo].empenhado += valores.empenhado;
        dadosPorGrupo[grupo].liquidado += valores.liquidado;
        dadosPorGrupo[grupo].pago += valores.pago;
    });
    
    // Ordenar grupos por valor empenhado
    const gruposOrdenados = Object.entries(dadosPorGrupo)
        .sort((a, b) => b[1].empenhado - a[1].empenhado);
    
    // Ordenar naturezas por valor empenhado
    const naturezasOrdenadas = Object.entries(dadosPorNatureza)
        .sort((a, b) => b[1].empenhado - a[1].empenhado);
    
    // Gráfico 1: Grupos de Natureza
    const gruposChart = document.getElementById('naturezaGrupoChart');
    if (gruposChart) {
        new Chart(gruposChart.getContext('2d'), {
            type: 'bar',
            data: {
                labels: gruposOrdenados.slice(0, 8).map(([grupo, _]) => grupo),
                datasets: [{
                    label: 'Valor Empenhado',
                    data: gruposOrdenados.slice(0, 8).map(([_, dados]) => dados.empenhado),
                    backgroundColor: colors.map(color => color + '80').slice(0, 8),
                    borderColor: colors.slice(0, 8),
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                indexAxis: 'y', // Barras horizontais para melhor visualização
                plugins: {
                    title: {
                        display: true,
                        text: 'Execução por Grupo de Natureza de Despesa',
                        font: { size: 16 }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return 'Valor: ' + formatarMoeda(context.parsed.x);
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        beginAtZero: true,
                        ticks: {
                            callback: function(value) {
                                if (value >= 1000000) {
                                    return 'R$ ' + (value / 1000000).toFixed(1) + ' mi';
                                } else if (value >= 1000) {
                                    return 'R$ ' + (value / 1000).toFixed(1) + ' mil';
                                }
                                return 'R$ ' + value;
                            }
                        }
                    }
                }
            }
        });
    }
    
    // Gráfico 2: Top Naturezas
    const topNaturezasChart = document.getElementById('topNaturezasChart');
    if (topNaturezasChart) {
        // Preparar dados
        const labels = naturezasOrdenadas.slice(0, 10).map(([natureza, _]) => {
            // Adicionar descrição se disponível
            const descricao = obterDescricaoNaturezaDespesa(natureza);
            // Abreviar para caber no gráfico
            const textoCompleto = natureza + (descricao !== 'Natureza de Despesa' ? ' - ' + descricao : '');
            return textoCompleto.length > 30 ? textoCompleto.substring(0, 27) + '...' : textoCompleto;
        });
        
        new Chart(topNaturezasChart.getContext('2d'), {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: 'Empenhado',
                        data: naturezasOrdenadas.slice(0, 10).map(([_, dados]) => dados.empenhado),
                        backgroundColor: colors[0] + '80',
                        borderColor: colors[0],
                        borderWidth: 1
                    },
                    {
                        label: 'Liquidado',
                        data: naturezasOrdenadas.slice(0, 10).map(([_, dados]) => dados.liquidado),
                        backgroundColor: colors[1] + '80',
                        borderColor: colors[1],
                        borderWidth: 1
                    },
                    {
                        label: 'Pago',
                        data: naturezasOrdenadas.slice(0, 10).map(([_, dados]) => dados.pago),
                        backgroundColor: colors[2] + '80',
                        borderColor: colors[2],
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Top 10 Naturezas de Despesa',
                        font: { size: 16 }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + formatarMoeda(context.parsed.y);
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        ticks: {
                            maxRotation: 45,
                            minRotation: 45
                        }
                    },
                    y: {
                        beginAtZero: true,
                        ticks: {
                            callback: function(value) {
                                if (value >= 1000000) {
                                    return 'R$ ' + (value / 1000000).toFixed(1) + ' mi';
                                } else if (value >= 1000) {
                                    return 'R$ ' + (value / 1000).toFixed(1) + ' mil';
                                }
                                return 'R$ ' + value;
                            }
                        }
                    }
                }
            }
        });
    }
    
    // Gráfico 3: Distribuição por Categoria Econômica
    const categoriaEconomicaChart = document.getElementById('categoriaEconomicaChart');
    if (categoriaEconomicaChart) {
        // Calcular valores por categoria econômica
        const categorias = {
            'Despesas Correntes': 0,
            'Despesas de Capital': 0,
            'Outras Categorias': 0
        };
        
        // Somar por categoria econômica
        dadosFiltrados.forEach(registro => {
            let categoria = '';
            const natureza = registro.Natureza_Despesa;
            
            if (natureza) {
                // Obter primeiro dígito da natureza
                const primeiroDigito = natureza.toString().charAt(0);
                
                if (primeiroDigito === '3') {
                    categoria = 'Despesas Correntes';
                } else if (primeiroDigito === '4') {
                    categoria = 'Despesas de Capital';
                } else {
                    categoria = 'Outras Categorias';
                }
            } else {
                categoria = 'Outras Categorias';
            }
            
            categorias[categoria] += (registro.Valor_Empenhado || 0);
        });
        
        // Filtrar categorias com valores
        const categoriasFiltradas = Object.entries(categorias)
            .filter(([_, valor]) => valor > 0)
            .sort((a, b) => b[1] - a[1]);
        
        new Chart(categoriaEconomicaChart.getContext('2d'), {
            type: 'pie',
            data: {
                labels: categoriasFiltradas.map(([cat, _]) => cat),
                datasets: [{
                    data: categoriasFiltradas.map(([_, valor]) => valor),
                    backgroundColor: [colors[0] + '80', colors[1] + '80', colors[2] + '80'],
                    borderColor: [colors[0], colors[1], colors[2]],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Distribuição por Categoria Econômica',
                        font: { size: 16 }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = formatarMoeda(context.parsed);
                                const percentage = ((context.parsed / context.dataset.data.reduce((a, b) => a + b, 0)) * 100).toFixed(2) + '%';
                                return `${label}: ${value} (${percentage})`;
                            }
                        }
                    }
                }
            }
        });
    }
}

// Renderizar gráficos do relatório financeiro de liquidação
function renderizarGraficosFinanceiroLiquidacao(colors) {
    // Obter dados filtrados
    const dadosFiltrados = window.filteredData || [];
    
    // Filtrar apenas registros liquidados
    const registrosLiquidados = dadosFiltrados.filter(d => d.Valor_Liquidado > 0);
    
    // Agrupar por mês
    const liquidacaoPorMes = {};
    registrosLiquidados.forEach(registro => {
        if (registro.Data_Liquidacao instanceof Date) {
            const mes = `${registro.Data_Liquidacao.getFullYear()}-${String(registro.Data_Liquidacao.getMonth() + 1).padStart(2, '0')}`;
            
            if (!liquidacaoPorMes[mes]) {
                liquidacaoPorMes[mes] = {
                    valorLiquidado: 0,
                    valorPago: 0,
                    quantidade: 0
                };
            }
            
            liquidacaoPorMes[mes].valorLiquidado += (registro.Valor_Liquidado || 0);
            liquidacaoPorMes[mes].valorPago += (registro.Valor_Pago || 0);
            liquidacaoPorMes[mes].quantidade++;
        }
    });
    
    // Ordenar meses cronologicamente
    const mesesOrdenados = Object.keys(liquidacaoPorMes).sort();
    
    // Agrupar por natureza de despesa
    const liquidacaoPorNatureza = {};
    registrosLiquidados.forEach(registro => {
        const natureza = registro.Natureza_Despesa || 'Não classificado';
        
        if (!liquidacaoPorNatureza[natureza]) {
            liquidacaoPorNatureza[natureza] = {
                valorLiquidado: 0,
                valorPago: 0,
                quantidade: 0
            };
        }
        
        liquidacaoPorNatureza[natureza].valorLiquidado += (registro.Valor_Liquidado || 0);
        liquidacaoPorNatureza[natureza].valorPago += (registro.Valor_Pago || 0);
        liquidacaoPorNatureza[natureza].quantidade++;
    });
    
    // Ordenar naturezas por valor liquidado
    const naturezasOrdenadas = Object.entries(liquidacaoPorNatureza)
        .sort((a, b) => b[1].valorLiquidado - a[1].valorLiquidado);
    
    // Gráfico 1: Liquidação mensal
    const liquidacaoMensalChart = document.getElementById('liquidacaoMensalChart');
    if (liquidacaoMensalChart) {
        new Chart(liquidacaoMensalChart.getContext('2d'), {
            type: 'bar',
            data: {
                labels: mesesOrdenados.map(mes => formatarMes(mes)),
                datasets: [
                    {
                        label: 'Valor Liquidado',
                        data: mesesOrdenados.map(mes => liquidacaoPorMes[mes].valorLiquidado),
                        backgroundColor: colors[0] + '80',
                        borderColor: colors[0],
                        borderWidth: 1
                    },
                    {
                        label: 'Valor Pago',
                        data: mesesOrdenados.map(mes => liquidacaoPorMes[mes].valorPago),
                        backgroundColor: colors[1] + '80',
                        borderColor: colors[1],
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Evolução Mensal de Liquidações e Pagamentos',
                        font: { size: 16 }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + formatarMoeda(context.parsed.y);
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            callback: function(value) {
                                if (value >= 1000000) {
                                    return 'R$ ' + (value / 1000000).toFixed(1) + ' mi';
                                } else if (value >= 1000) {
                                    return 'R$ ' + (value / 1000).toFixed(1) + ' mil';
                                }
                                return 'R$ ' + value;
                            }
                        }
                    }
                }
            }
        });
    }
    
    // Gráfico 2: Liquidação por natureza
    const naturezaLiquidacaoChart = document.getElementById('naturezaLiquidacaoChart');
    if (naturezaLiquidacaoChart) {
        new Chart(naturezaLiquidacaoChart.getContext('2d'), {
            type: 'pie',
            data: {
                labels: naturezasOrdenadas.slice(0, 5).map(([natureza, _]) => {
                    const descricao = obterDescricaoNaturezaDespesa(natureza);
                    return natureza + (descricao !== 'Natureza de Despesa' ? ` - ${descricao}` : '');
                }),
                datasets: [{
                    data: naturezasOrdenadas.slice(0, 5).map(([_, dados]) => dados.valorLiquidado),
                    backgroundColor: colors.slice(0, 5).map(color => color + '80'),
                    borderColor: colors.slice(0, 5),
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Principais Naturezas de Despesa Liquidadas',
                        font: { size: 16 }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = formatarMoeda(context.parsed);
                                const total = context.dataset.data.reduce((acc, val) => acc + val, 0);
                                const percentage = ((context.parsed / total) * 100).toFixed(2) + '%';
                                return `${label}: ${value} (${percentage})`;
                            }
                        }
                    }
                }
            }
        });
    }
}

// Renderizar gráficos do relatório de pagamentos realizados
function renderizarGraficosPagamentosRealizados(colors) {
    // Obter dados filtrados
    const dadosFiltrados = window.filteredData || [];
    
    // Filtrar apenas registros com pagamentos
    const registrosPagos = dadosFiltrados.filter(d => d.Valor_Pago > 0);
    
    // Agrupar por mês
    const pagamentosPorMes = {};
    registrosPagos.forEach(registro => {
        if (registro.Data_Pagamento instanceof Date) {
            const mes = `${registro.Data_Pagamento.getFullYear()}-${String(registro.Data_Pagamento.getMonth() + 1).padStart(2, '0')}`;
            
            if (!pagamentosPorMes[mes]) {
                pagamentosPorMes[mes] = {
                    valorPago: 0,
                    quantidade: 0
                };
            }
            
            pagamentosPorMes[mes].valorPago += (registro.Valor_Pago || 0);
            pagamentosPorMes[mes].quantidade++;
        }
    });
    
    // Ordenar meses cronologicamente
    const mesesOrdenados = Object.keys(pagamentosPorMes).sort();
    
    // Agrupar por natureza de despesa
    const pagamentosPorNatureza = {};
    registrosPagos.forEach(registro => {
        const natureza = registro.Natureza_Despesa || 'Não classificado';
        
        if (!pagamentosPorNatureza[natureza]) {
            pagamentosPorNatureza[natureza] = {
                valorPago: 0,
                quantidade: 0
            };
        }
        
        pagamentosPorNatureza[natureza].valorPago += (registro.Valor_Pago || 0);
        pagamentosPorNatureza[natureza].quantidade++;
    });
    
    // Ordenar naturezas por valor pago
    const naturezasOrdenadas = Object.entries(pagamentosPorNatureza)
        .sort((a, b) => b[1].valorPago - a[1].valorPago);
    
    // Agrupar por credor
    const pagamentosPorCredor = {};
    registrosPagos.forEach(registro => {
        const credor = registro.Credor || 'Não informado';
        
        if (!pagamentosPorCredor[credor]) {
            pagamentosPorCredor[credor] = {
                valorPago: 0,
                quantidade: 0
            };
        }
        
        pagamentosPorCredor[credor].valorPago += (registro.Valor_Pago || 0);
        pagamentosPorCredor[credor].quantidade++;
    });
    
    // Ordenar credores por valor pago
    const credoresOrdenados = Object.entries(pagamentosPorCredor)
        .sort((a, b) => b[1].valorPago - a[1].valorPago);
    
    // Gráfico 1: Pagamentos mensais
    const pagamentosMensalChart = document.getElementById('pagamentosMensalChart');
    if (pagamentosMensalChart) {
        new Chart(pagamentosMensalChart.getContext('2d'), {
            type: 'line',
            data: {
                labels: mesesOrdenados.map(mes => formatarMes(mes)),
                datasets: [
                    {
                        label: 'Valor Pago',
                        data: mesesOrdenados.map(mes => pagamentosPorMes[mes].valorPago),
                        borderColor: colors[0],
                        backgroundColor: colors[0] + '30',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    },
                    {
                        label: 'Quantidade',
                        data: mesesOrdenados.map(mes => pagamentosPorMes[mes].quantidade),
                        borderColor: colors[1],
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        tension: 0.4,
                        yAxisID: 'y1'
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Evolução Mensal de Pagamentos',
                        font: { size: 16 }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                if (context.dataset.label === 'Valor Pago') {
                                    return 'Valor Pago: ' + formatarMoeda(context.parsed.y);
                                } else {
                                    return 'Quantidade: ' + context.parsed.y;
                                }
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        position: 'left',
                        title: {
                            display: true,
                            text: 'Valor Pago'
                        },
                        ticks: {
                            callback: function(value) {
                                if (value >= 1000000) {
                                    return 'R$ ' + (value / 1000000).toFixed(1) + ' mi';
                                } else if (value >= 1000) {
                                    return 'R$ ' + (value / 1000).toFixed(1) + ' mil';
                                }
                                return 'R$ ' + value;
                            }
                        }
                    },
                    y1: {
                        beginAtZero: true,
                        position: 'right',
                        grid: {
                            drawOnChartArea: false
                        },
                        title: {
                            display: true,
                            text: 'Quantidade'
                        }
                    }
                }
            }
        });
    }
    
    // Gráfico 2: Pagamentos por natureza
    const naturezaPagamentoChart = document.getElementById('naturezaPagamentoChart');
    if (naturezaPagamentoChart) {
        new Chart(naturezaPagamentoChart.getContext('2d'), {
            type: 'doughnut',
            data: {
                labels: naturezasOrdenadas.slice(0, 7).map(([natureza, _]) => {
                    const descricao = obterDescricaoNaturezaDespesa(natureza);
                    return natureza + (descricao !== 'Natureza de Despesa' ? ` - ${descricao}` : '');
                }),
                datasets: [{
                    data: naturezasOrdenadas.slice(0, 7).map(([_, dados]) => dados.valorPago),
                    backgroundColor: colors.slice(0, 7).map(color => color + '80'),
                    borderColor: colors.slice(0, 7),
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Distribuição de Pagamentos por Natureza',
                        font: { size: 16 }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = formatarMoeda(context.parsed);
                                const total = context.dataset.data.reduce((acc, val) => acc + val, 0);
                                const percentage = ((context.parsed / total) * 100).toFixed(2) + '%';
                                return `${label}: ${value} (${percentage})`;
                            }
                        }
                    },
                    legend: {
                        position: 'right'
                    }
                }
            }
        });
    }
    
    // Gráfico 3: Pagamentos por credor
    const credoresPagamentoChart = document.getElementById('credoresPagamentoChart');
    if (credoresPagamentoChart) {
        new Chart(credoresPagamentoChart.getContext('2d'), {
            type: 'bar',
            data: {
                labels: credoresOrdenados.slice(0, 10).map(([credor, _]) => 
                    credor.length > 25 ? credor.substring(0, 22) + '...' : credor
                ),
                datasets: [{
                    label: 'Valor Pago',
                    data: credoresOrdenados.slice(0, 10).map(([_, dados]) => dados.valorPago),
                    backgroundColor: colors[2] + '80',
                    borderColor: colors[2],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                indexAxis: 'y',
                plugins: {
                    title: {
                        display: true,
                        text: 'Maiores Credores (por Valor Pago)',
                        font: { size: 16 }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return 'Valor Pago: ' + formatarMoeda(context.parsed.x);
                            },
                            afterLabel: function(context) {
                                const credor = credoresOrdenados[context.dataIndex][0];
                                const dados = credoresOrdenados[context.dataIndex][1];
                                return `Quantidade: ${dados.quantidade} pagamento(s)`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        beginAtZero: true,
                        ticks: {
                            callback: function(value) {
                                if (value >= 1000000) {
                                    return 'R$ ' + (value / 1000000).toFixed(1) + ' mi';
                                } else if (value >= 1000) {
                                    return 'R$ ' + (value / 1000).toFixed(1) + ' mil';
                                }
                                return 'R$ ' + value;
                            }
                        }
                    }
                }
            }
        });
    }
}

// Renderizar gráficos do relatório de restos a pagar
function renderizarGraficosRestosPagar(colors) {
    // Obter dados filtrados
    const dadosFiltrados = window.filteredData || [];
    
    // Determinar exercício atual (para filtrar restos a pagar)
    const exercicioAtual = new Date().getFullYear().toString();
    
    // Filtrar dados de exercícios anteriores com empenhos não totalmente pagos
    const restosAPagar = dadosFiltrados.filter(d => {
        const exercicioItem = d.Exercicio ? d.Exercicio.toString() : null;
        return exercicioItem && 
               exercicioItem < exercicioAtual && 
               d.Valor_Empenhado > 0 && 
               (d.Valor_Empenhado || 0) > (d.Valor_Pago || 0);
    });
    
    // Separar em RPP (Processados) e RPNP (Não Processados)
    const rpp = restosAPagar.filter(d => (d.Valor_Liquidado || 0) > (d.Valor_Pago || 0));
    const rpnp = restosAPagar.filter(d => (d.Valor_Liquidado || 0) <= (d.Valor_Pago || 0));
    
    // Calcular totais
    const totalRPP = rpp.reduce((soma, item) => soma + ((item.Valor_Liquidado || 0) - (item.Valor_Pago || 0)), 0);
    const totalRPNP = rpnp.reduce((soma, item) => soma + ((item.Valor_Empenhado || 0) - (item.Valor_Liquidado || 0)), 0);
    
    // Agrupar por exercício
    const restosPorExercicio = {};
    restosAPagar.forEach(registro => {
        const exercicioItem = registro.Exercicio?.toString() || 'Não informado';
        
        if (!restosPorExercicio[exercicioItem]) {
            restosPorExercicio[exercicioItem] = {
                valorEmpenhado: 0,
                valorLiquidado: 0,
                valorPago: 0,
                saldoAPagar: 0,
                rpp: 0,
                rpnp: 0
            };
        }
        
        const saldoAPagar = (registro.Valor_Empenhado || 0) - (registro.Valor_Pago || 0);
        restosPorExercicio[exercicioItem].valorEmpenhado += (registro.Valor_Empenhado || 0);
        restosPorExercicio[exercicioItem].valorLiquidado += (registro.Valor_Liquidado || 0);
        restosPorExercicio[exercicioItem].valorPago += (registro.Valor_Pago || 0);
        restosPorExercicio[exercicioItem].saldoAPagar += saldoAPagar;
        
        // Classificar saldo em RPP ou RPNP
        if ((registro.Valor_Liquidado || 0) > (registro.Valor_Pago || 0)) {
            restosPorExercicio[exercicioItem].rpp += (registro.Valor_Liquidado || 0) - (registro.Valor_Pago || 0);
        } else {
            restosPorExercicio[exercicioItem].rpnp += (registro.Valor_Empenhado || 0) - (registro.Valor_Liquidado || 0);
        }
    });
    
    // Ordenar exercícios
    const exerciciosOrdenados = Object.keys(restosPorExercicio).sort((a, b) => a - b);
    
    // Gráfico 1: Restos a Pagar (RPP vs RPNP)
    const restosAPagarChart = document.getElementById('restosAPagarChart');
    if (restosAPagarChart) {
        new Chart(restosAPagarChart.getContext('2d'), {
            type: 'pie',
            data: {
                labels: ['Restos a Pagar Processados (RPP)', 'Restos a Pagar Não Processados (RPNP)'],
                datasets: [{
                    data: [totalRPP, totalRPNP],
                    backgroundColor: [colors[0] + '80', colors[1] + '80'],
                    borderColor: [colors[0], colors[1]],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Distribuição de Restos a Pagar',
                        font: { size: 16 }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = formatarMoeda(context.parsed);
                                const percentage = ((context.parsed / (totalRPP + totalRPNP)) * 100).toFixed(2) + '%';
                                return `${label}: ${value} (${percentage})`;
                            }
                        }
                    }
                }
            }
        });
    }
    
    // Gráfico 2: Restos a Pagar por Exercício
    const exercicioRPChart = document.getElementById('exercicioRPChart');
    if (exercicioRPChart) {
        new Chart(exercicioRPChart.getContext('2d'), {
            type: 'bar',
            data: {
                labels: exerciciosOrdenados,
                datasets: [
                    {
                        label: 'RPP',
                        data: exerciciosOrdenados.map(ex => restosPorExercicio[ex].rpp),
                        backgroundColor: colors[0] + '80',
                        borderColor: colors[0],
                        borderWidth: 1
                    },
                    {
                        label: 'RPNP',
                        data: exerciciosOrdenados.map(ex => restosPorExercicio[ex].rpnp),
                        backgroundColor: colors[1] + '80',
                        borderColor: colors[1],
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Restos a Pagar por Exercício',
                        font: { size: 16 }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + formatarMoeda(context.parsed.y);
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        stacked: true,
                        ticks: {
                            callback: function(value) {
                                if (value >= 1000000) {
                                    return 'R$ ' + (value / 1000000).toFixed(1) + ' mi';
                                } else if (value >= 1000) {
                                    return 'R$ ' + (value / 1000).toFixed(1) + ' mil';
                                }
                                return 'R$ ' + value;
                            }
                        }
                    },
                    x: {
                        stacked: true
                    }
                }
            }
        });
    }
    
    // Agrupar por natureza de despesa
    const naturezasRP = {};
    restosAPagar.forEach(registro => {
        const natureza = registro.Natureza_Despesa || 'Não classificado';
        const saldoAPagar = (registro.Valor_Empenhado || 0) - (registro.Valor_Pago || 0);
        
        if (!naturezasRP[natureza]) {
            naturezasRP[natureza] = 0;
        }
        
        naturezasRP[natureza] += saldoAPagar;
    });
    
    // Ordenar naturezas por saldo a pagar
    const naturezasOrdenadas = Object.entries(naturezasRP)
        .sort((a, b) => b[1] - a[1]);
    
    // Gráfico 3: Restos a Pagar por Natureza
    const naturezaRPChart = document.getElementById('naturezaRPChart');
    if (naturezaRPChart && naturezasOrdenadas.length > 0) {
        new Chart(naturezaRPChart.getContext('2d'), {
            type: 'doughnut',
            data: {
                labels: naturezasOrdenadas.slice(0, 7).map(([natureza, _]) => {
                    const descricao = obterDescricaoNaturezaDespesa(natureza);
                    return natureza + (descricao !== 'Natureza de Despesa' ? ` - ${descricao}` : '');
                }),
                datasets: [{
                    data: naturezasOrdenadas.slice(0, 7).map(([_, valor]) => valor),
                    backgroundColor: colors.slice(0, 7).map(color => color + '80'),
                    borderColor: colors.slice(0, 7),
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Principais Naturezas de Despesa em Restos a Pagar',
                        font: { size: 16 }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = formatarMoeda(context.parsed);
                                const total = context.dataset.data.reduce((acc, val) => acc + val, 0);
                                const percentage = ((context.parsed / total) * 100).toFixed(2) + '%';
                                return `${label}: ${value} (${percentage})`;
                            }
                        }
                    },
                    legend: {
                        position: 'right',
                        labels: {
                            font: {
                                size: 11
                            }
                        }
                    }
                }
            }
        });
    }
}

// Renderizar gráficos do relatório de execução por credor
function renderizarGraficosExecucaoPorCredor(colors) {
    // Obter dados filtrados
    const dadosFiltrados = window.filteredData || [];
    
    // Agrupar por credor
    const dadosPorCredor = {};
    dadosFiltrados.forEach(registro => {
        const credor = registro.Credor || 'Não informado';
        
        if (!dadosPorCredor[credor]) {
            dadosPorCredor[credor] = {
                valorEmpenhado: 0,
                valorLiquidado: 0,
                valorPago: 0,
                quantidadeEmpenhos: 0
            };
        }
        
        if (registro.Valor_Empenhado) {
            dadosPorCredor[credor].valorEmpenhado += registro.Valor_Empenhado;
            dadosPorCredor[credor].quantidadeEmpenhos++;
        }
        
        if (registro.Valor_Liquidado) {
            dadosPorCredor[credor].valorLiquidado += registro.Valor_Liquidado;
        }
        
        if (registro.Valor_Pago) {
            dadosPorCredor[credor].valorPago += registro.Valor_Pago;
        }
    });
    
    // Ordenar credores por valor empenhado
    const credoresOrdenados = Object.entries(dadosPorCredor)
        .sort((a, b) => b[1].valorEmpenhado - a[1].valorEmpenhado);
    
    // Calcular valor total empenhado
    const totalEmpenhado = credoresOrdenados.reduce((soma, [_, dados]) => soma + dados.valorEmpenhado, 0);
    
    // Gráfico 1: Maiores Credores
    const maioresCredoresChart = document.getElementById('maioresCredoresChart');
    if (maioresCredoresChart) {
        // Limitar aos 10 maiores
        const top10Credores = credoresOrdenados.slice(0, 10);
        
        new Chart(maioresCredoresChart.getContext('2d'), {
            type: 'bar',
            data: {
                labels: top10Credores.map(([credor, _]) => 
                    credor.length > 30 ? credor.substring(0, 27) + '...' : credor
                ),
                datasets: [
                    {
                        label: 'Valor Empenhado',
                        data: top10Credores.map(([_, dados]) => dados.valorEmpenhado),
                        backgroundColor: colors[0] + '80',
                        borderColor: colors[0],
                        borderWidth: 1
                    },
                    {
                        label: 'Valor Pago',
                        data: top10Credores.map(([_, dados]) => dados.valorPago),
                        backgroundColor: colors[1] + '80',
                        borderColor: colors[1],
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                indexAxis: 'y',
                plugins: {
                    title: {
                        display: true,
                        text: 'Maiores Credores por Valor Empenhado',
                        font: { size: 16 }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + formatarMoeda(context.parsed.x);
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        beginAtZero: true,
                        ticks: {
                            callback: function(value) {
                                if (value >= 1000000) {
                                    return 'R$ ' + (value / 1000000).toFixed(1) + ' mi';
                                } else if (value >= 1000) {
                                    return 'R$ ' + (value / 1000).toFixed(1) + ' mil';
                                }
                                return 'R$ ' + value;
                            }
                        }
                    }
                }
            }
        });
    }
    
    // Gráfico 2: Concentração de Credores
    const concentracaoCredoresChart = document.getElementById('concentracaoCredoresChart');
    if (concentracaoCredoresChart) {
        // Calcular faixas de concentração
        const top1 = credoresOrdenados.slice(0, 1).reduce((soma, [_, dados]) => soma + dados.valorEmpenhado, 0);
        const top5 = credoresOrdenados.slice(0, 5).reduce((soma, [_, dados]) => soma + dados.valorEmpenhado, 0);
        const top10 = credoresOrdenados.slice(0, 10).reduce((soma, [_, dados]) => soma + dados.valorEmpenhado, 0);
        const outros = totalEmpenhado - top10;
        
        new Chart(concentracaoCredoresChart.getContext('2d'), {
            type: 'pie',
            data: {
                labels: ['Maior Credor', 'Top 2-5', 'Top 6-10', 'Demais Credores'],
                datasets: [{
                    data: [top1, top5 - top1, top10 - top5, outros],
                    backgroundColor: colors.slice(0, 4).map(color => color + '80'),
                    borderColor: colors.slice(0, 4),
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Análise de Concentração de Credores',
                        font: { size: 16 }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = formatarMoeda(context.parsed);
                                const percentage = ((context.parsed / totalEmpenhado) * 100).toFixed(2) + '%';
                                return `${label}: ${value} (${percentage})`;
                            }
                        }
                    }
                }
            }
        });
    }
}

// Renderizar gráficos do relatório de indicadores de desempenho
function renderizarGraficosIndicadoresDesempenho(colors) {
    // Obter dados filtrados
    const dadosFiltrados = window.filteredData || [];
    
    // Calcular indicadores
    const indicadores = calcularIndicadoresDesempenho(dadosFiltrados);
    const temposExecucao = analisarTemposExecucao(dadosFiltrados);
    const execucaoPorCategoria = analisarExecucaoPorCategoria(dadosFiltrados);
    const tendencias = calcularTendenciasExecucao(dadosFiltrados);
    
    // Gráfico 1: Indicadores Principais
    const indicadoresPrincipaisChart = document.getElementById('indicadoresPrincipaisChart');
    if (indicadoresPrincipaisChart) {
        new Chart(indicadoresPrincipaisChart.getContext('2d'), {
            type: 'radar',
            data: {
                labels: [
                    'Execução Orçamentária', 
                    'Liquidação', 
                    'Pagamento', 
                    'Execução Financeira',
                    'Tempo de Liquidação*',
                    'Tempo de Pagamento*'
                ],
                datasets: [{
                    label: 'Desempenho Atual',
                    data: [
                        indicadores.percentualExecucaoOrcamentaria,
                        indicadores.percentualLiquidacao,
                        indicadores.percentualPagamento,
                        indicadores.percentualExecucaoFinanceira,
                        Math.max(0, 100 - temposExecucao.tempoMedioLiquidacao),  // Invertido para radar (menor tempo = melhor desempenho)
                        Math.max(0, 100 - temposExecucao.tempoMedioPagamento)    // Invertido para radar (menor tempo = melhor desempenho)
                    ],
                    fill: true,
                    backgroundColor: colors[0] + '30',
                    borderColor: colors[0],
                    pointBackgroundColor: colors[0],
                    pointBorderColor: '#fff',
                    pointHoverBackgroundColor: '#fff',
                    pointHoverBorderColor: colors[0]
                }, {
                    label: 'Meta',
                    data: [95, 90, 90, 85, 85, 90],  // Valores de referência (metas)
                    fill: true,
                    backgroundColor: 'rgba(0, 0, 0, 0)',
                    borderColor: colors[3],
                    borderDash: [5, 5],
                    pointBackgroundColor: colors[3],
                    pointBorderColor: '#fff',
                    pointHoverBackgroundColor: '#fff',
                    pointHoverBorderColor: colors[3]
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    r: {
                        angleLines: {
                            display: true
                        },
                        suggestedMin: 0,
                        suggestedMax: 100
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Indicadores de Desempenho Orçamentário',
                        font: { size: 16 }
                    },
                    subtitle: {
                        display: true,
                        text: '* Tempo: valores invertidos (100% = 0 dias)',
                        position: 'bottom',
                        font: { size: 12, style: 'italic' }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.dataset.label;
                                let value = context.parsed.r;
                                
                                // Tratar tempos para mostrar em dias
                                if (context.label.includes('Tempo') && context.dataset.label === 'Desempenho Atual') {
                                    const diasEquivalentes = Math.max(0, 100 - value);
                                    return `${label}: ${diasEquivalentes.toFixed(0)} dias`;
                                }
                                
                                return `${label}: ${value.toFixed(2)}%`;
                            }
                        }
                    }
                }
            }
        });
    }
    
    // Gráfico 2: Desempenho por Categoria
    const desempenhoCategoriaChart = document.getElementById('desempenhoCategoriaChart');
    if (desempenhoCategoriaChart) {
        // Preparar dados por categoria
        const categorias = Object.entries(execucaoPorCategoria);
        const labelsCategoria = categorias.map(([categoria, _]) => categoria);
        const percentuaisExecucao = categorias.map(([_, dados]) => 
            dados.valorPlanejado > 0 ? (dados.valorEmpenhado / dados.valorPlanejado) * 100 : 0
        );
        const valoresEmpenhados = categorias.map(([_, dados]) => dados.valorEmpenhado);
        
        new Chart(desempenhoCategoriaChart.getContext('2d'), {
            type: 'bar',
            data: {
                labels: labelsCategoria,
                datasets: [
                    {
                        label: 'Valor Empenhado',
                        data: valoresEmpenhados,
                        backgroundColor: colors[0] + '80',
                        borderColor: colors[0],
                        borderWidth: 1,
                        order: 2,
                        yAxisID: 'y'
                    },
                    {
                        label: '% Execução',
                        data: percentuaisExecucao,
                        backgroundColor: 'rgba(0,0,0,0)',
                        borderColor: colors[1],
                        borderWidth: 3,
                        type: 'line',
                        order: 1,
                        yAxisID: 'y1'
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Desempenho por Categoria Econômica',
                        font: { size: 16 }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                if (context.dataset.label === 'Valor Empenhado') {
                                    return 'Valor Empenhado: ' + formatarMoeda(context.parsed.y);
                                } else {
                                    return '% Execução: ' + context.parsed.y.toFixed(2) + '%';
                                }
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        position: 'left',
                        title: {
                            display: true,
                            text: 'Valor Empenhado'
                        },
                        ticks: {
                            callback: function(value) {
                                if (value >= 1000000) {
                                    return 'R$ ' + (value / 1000000).toFixed(1) + ' mi';
                                } else if (value >= 1000) {
                                    return 'R$ ' + (value / 1000).toFixed(1) + ' mil';
                                }
                                return 'R$ ' + value;
                            }
                        }
                    },
                    y1: {
                        beginAtZero: true,
                        position: 'right',
                        max: 100,
                        title: {
                            display: true,
                            text: 'Percentual de Execução'
                        },
                        grid: {
                            drawOnChartArea: false
                        },
                        ticks: {
                            callback: function(value) {
                                return value + '%';
                            }
                        }
                    }
                }
            }
        });
    }
    
    // Gráfico 3: Tendência de Execução
    const tendenciaExecucaoChart = document.getElementById('tendenciaExecucaoChart');
    if (tendenciaExecucaoChart && tendencias.mesesOrdenados && tendencias.mesesOrdenados.length > 0) {
        const mesesFormatados = tendencias.mesesOrdenados.map(mes => formatarMes(mes));
        const valoresMensais = tendencias.mesesOrdenados.map(mes => tendencias.execucaoMensal[mes].empenhado);
        
        // Calcular tendência linear
        const trendLine = tendencias.mesesOrdenados.map((_, index) => {
            return tendencias.tendenciaLinear.empenhado.slope * (index + 1) + tendencias.tendenciaLinear.empenhado.intercept;
        });
        
        new Chart(tendenciaExecucaoChart.getContext('2d'), {
            type: 'line',
            data: {
                labels: mesesFormatados,
                datasets: [
                    {
                        label: 'Valor Mensal',
                        data: valoresMensais,
                        backgroundColor: colors[0] + '50',
                        borderColor: colors[0],
                        borderWidth: 2,
                        fill: true
                    },
                    {
                        label: 'Tendência',
                        data: trendLine,
                        backgroundColor: 'rgba(0,0,0,0)',
                        borderColor: colors[2],
                        borderWidth: 2,
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Tendência de Execução Orçamentária Mensal',
                        font: { size: 16 }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + formatarMoeda(context.parsed.y);
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            callback: function(value) {
                                if (value >= 1000000) {
                                    return 'R$ ' + (value / 1000000).toFixed(1) + ' mi';
                                } else if (value >= 1000) {
                                    return 'R$ ' + (value / 1000).toFixed(1) + ' mil';
                                }
                                return 'R$ ' + value;
                            }
                        }
                    }
                }
            }
        });
    }
    
    // Gráfico 4: Projeção de Execução
    const projecaoExecucaoChart = document.getElementById('projecaoExecucaoChart');
    if (projecaoExecucaoChart && tendencias.mesesOrdenados && tendencias.mesesOrdenados.length > 0 && tendencias.projecao) {
        // Preparar dados para o gráfico
        const mesesReais = tendencias.mesesOrdenados.map(mes => formatarMes(mes));
        const mesesProjetados = tendencias.projecao.mesesProjetados.map(mes => formatarMes(mes) + '*');
        const todosOsMeses = [...mesesReais, ...mesesProjetados];
        
        const valoresAcumulados = tendencias.mesesOrdenados.map(mes => tendencias.execucaoAcumulada[mes].empenhado);
        const valoresProjetados = tendencias.projecao.acumuladosProjetados.empenhado;
        
        new Chart(projecaoExecucaoChart.getContext('2d'), {
            type: 'line',
            data: {
                labels: todosOsMeses,
                datasets: [{
                    label: 'Realizado',
                    data: [...valoresAcumulados, ...Array(mesesProjetados.length).fill(null)],
                    borderColor: colors[0],
                    backgroundColor: colors[0] + '50',
                    fill: true,
                    tension: 0.1
                }, {
                    label: 'Projeção',
                    data: [...Array(mesesReais.length).fill(null), ...valoresProjetados],
                    borderColor: colors[2],
                    borderDash: [5, 5],
                    backgroundColor: colors[2] + '30',
                    fill: true,
                    tension: 0.1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Projeção de Execução Orçamentária',
                        font: { size: 16 }
                    },
                    subtitle: {
                        display: true,
                        text: '* Valores projetados',
                        position: 'bottom',
                        font: { size: 12, style: 'italic' }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + formatarMoeda(context.parsed.y);
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            callback: function(value) {
                                if (value >= 1000000) {
                                    return 'R$ ' + (value / 1000000).toFixed(1) + ' mi';
                                } else if (value >= 1000) {
                                    return 'R$ ' + (value / 1000).toFixed(1) + ' mil';
                                }
                                return 'R$ ' + value;
                            }
                        }
                    }
                }
            }
        });
    }
}

// Função para renderizar gráficos do relatório comparativo planejado vs. executado
function renderizarGraficosComparativoPlanejadoExecutado(colors) {
    // Obter dados filtrados
    const dadosFiltrados = window.filteredData || [];
    
    // Calcular valores planejados e executados
    const valorPlanejadoTotal = dadosFiltrados.reduce((soma, item) => soma + (item.Valor_Planejado || 0), 0);
    const valorEmpenhadoTotal = dadosFiltrados.reduce((soma, item) => soma + (item.Valor_Empenhado || 0), 0);
    const valorLiquidadoTotal = dadosFiltrados.reduce((soma, item) => soma + (item.Valor_Liquidado || 0), 0);
    const valorPagoTotal = dadosFiltrados.reduce((soma, item) => soma + (item.Valor_Pago || 0), 0);
    
    // Agrupar por natureza de despesa
    const planejadoPorNatureza = {};
    const empenhadoPorNatureza = {};
    const liquidadoPorNatureza = {};
    const pagoPorNatureza = {};
    
    dadosFiltrados.forEach(registro => {
        const natureza = registro.Natureza_Despesa || 'Não classificado';
        
        // Inicializar se necessário
        if (!planejadoPorNatureza[natureza]) planejadoPorNatureza[natureza] = 0;
        if (!empenhadoPorNatureza[natureza]) empenhadoPorNatureza[natureza] = 0;
        if (!liquidadoPorNatureza[natureza]) liquidadoPorNatureza[natureza] = 0;
        if (!pagoPorNatureza[natureza]) pagoPorNatureza[natureza] = 0;
        
        // Adicionar valores
        planejadoPorNatureza[natureza] += (registro.Valor_Planejado || 0);
        empenhadoPorNatureza[natureza] += (registro.Valor_Empenhado || 0);
        liquidadoPorNatureza[natureza] += (registro.Valor_Liquidado || 0);
        pagoPorNatureza[natureza] += (registro.Valor_Pago || 0);
    });
    
    // Gráfico 1: Comparativo geral
    const comparativoGeralChart = document.getElementById('comparativoGeralChart');
    if (comparativoGeralChart) {
        new Chart(comparativoGeralChart.getContext('2d'), {
            type: 'bar',
            data: {
                labels: ['Planejado', 'Empenhado', 'Liquidado', 'Pago'],
                datasets: [{
                    label: 'Valores',
                    data: [valorPlanejadoTotal, valorEmpenhadoTotal, valorLiquidadoTotal, valorPagoTotal],
                    backgroundColor: [
                        colors[0] + '80',
                        colors[1] + '80',
                        colors[2] + '80',
                        colors[3] + '80'
                    ],
                    borderColor: [
                        colors[0],
                        colors[1],
                        colors[2],
                        colors[3]
                    ],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Comparativo Planejado x Executado',
                        font: { size: 16 }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const valor = formatarMoeda(context.parsed.y);
                                
                                let percentual = 0;
                                if (context.label === 'Empenhado' && valorPlanejadoTotal > 0) {
                                    percentual = (valorEmpenhadoTotal / valorPlanejadoTotal) * 100;
                                    return `Valor: ${valor} (${percentual.toFixed(2)}% do planejado)`;
                                } else if (context.label === 'Liquidado' && valorEmpenhadoTotal > 0) {
                                    percentual = (valorLiquidadoTotal / valorEmpenhadoTotal) * 100;
                                    return `Valor: ${valor} (${percentual.toFixed(2)}% do empenhado)`;
                                } else if (context.label === 'Pago' && valorLiquidadoTotal > 0) {
                                    percentual = (valorPagoTotal / valorLiquidadoTotal) * 100;
                                    return `Valor: ${valor} (${percentual.toFixed(2)}% do liquidado)`;
                                }
                                
                                return `Valor: ${valor}`;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            callback: function(value) {
                                if (value >= 1000000) {
                                    return 'R$ ' + (value / 1000000).toFixed(1) + ' mi';
                                } else if (value >= 1000) {
                                    return 'R$ ' + (value / 1000).toFixed(1) + ' mil';
                                }
                                return 'R$ ' + value;
                            }
                        }
                    }
                }
            }
        });
    }
    
    // Gráfico 2: Top 10 naturezas comparativas
    const topNaturezasComparativoChart = document.getElementById('topNaturezasComparativoChart');
    if (topNaturezasComparativoChart) {
        // Encontrar as top 10 naturezas por valor planejado
        const naturezasOrdenadas = Object.entries(planejadoPorNatureza)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 10);
        
        const labels = naturezasOrdenadas.map(([natureza, _]) => {
            const descricao = obterDescricaoNaturezaDespesa(natureza);
            return natureza + (descricao !== 'Natureza de Despesa' ? ' - ' + descricao : '');
        });
        
        const planejadoValues = naturezasOrdenadas.map(([natureza, _]) => planejadoPorNatureza[natureza]);
        const empenhadoValues = naturezasOrdenadas.map(([natureza, _]) => empenhadoPorNatureza[natureza] || 0);
        
        new Chart(topNaturezasComparativoChart.getContext('2d'), {
            type: 'bar',
            data: {
                labels: labels.map(label => label.length > 25 ? label.substring(0, 22) + '...' : label),
                datasets: [
                    {
                        label: 'Planejado',
                        data: planejadoValues,
                        backgroundColor: colors[0] + '80',
                        borderColor: colors[0],
                        borderWidth: 1
                    },
                    {
                        label: 'Empenhado',
                        data: empenhadoValues,
                        backgroundColor: colors[1] + '80',
                        borderColor: colors[1],
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                indexAxis: 'y',
                plugins: {
                    title: {
                        display: true,
                        text: 'Comparativo por Natureza de Despesa',
                        font: { size: 16 }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.dataset.label;
                                const valor = formatarMoeda(context.parsed.x);
                                return `${label}: ${valor}`;
                            },
                            afterLabel: function(context) {
                                if (context.dataset.label === 'Empenhado') {
                                    const natureza = naturezasOrdenadas[context.dataIndex][0];
                                    const planejado = planejadoPorNatureza[natureza];
                                    const empenhado = empenhadoPorNatureza[natureza] || 0;
                                    
                                    if (planejado > 0) {
                                        const percentual = (empenhado / planejado) * 100;
                                        return `Execução: ${percentual.toFixed(2)}% do planejado`;
                                    }
                                }
                                return '';
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        beginAtZero: true,
                        ticks: {
                            callback: function(value) {
                                if (value >= 1000000) {
                                    return 'R$ ' + (value / 1000000).toFixed(1) + ' mi';
                                } else if (value >= 1000) {
                                    return 'R$ ' + (value / 1000).toFixed(1) + ' mil';
                                }
                                return 'R$ ' + value;
                            }
                        }
                    }
                }
            }
        });
    }
    
    // Gráfico 3: Percentual de execução por natureza
    const percentualExecucaoChart = document.getElementById('percentualExecucaoChart');
    if (percentualExecucaoChart) {
        // Obter naturezas com maior divergência
        const naturezasComDivergencia = Object.keys(planejadoPorNatureza)
            .filter(natureza => planejadoPorNatureza[natureza] > valorPlanejadoTotal * 0.02) // Pelo menos 2% do total
            .map(natureza => {
                const planejado = planejadoPorNatureza[natureza];
                const empenhado = empenhadoPorNatureza[natureza] || 0;
                const percentual = planejado > 0 ? (empenhado / planejado) * 100 : 0;
                return { natureza, percentual, planejado };
            })
            .sort((a, b) => Math.abs(b.percentual - 100) - Math.abs(a.percentual - 100))
            .slice(0, 8);
        
        const labels = naturezasComDivergencia.map(item => {
            const descricao = obterDescricaoNaturezaDespesa(item.natureza);
            const texto = item.natureza + (descricao !== 'Natureza de Despesa' ? ' - ' + descricao : '');
            return texto.length > 25 ? texto.substring(0, 22) + '...' : texto;
        });
        
        const percentuais = naturezasComDivergencia.map(item => item.percentual);
        const valores = naturezasComDivergencia.map(item => item.planejado);
        
        // Calcular cor baseada no percentual (vermelho para baixo, verde para alto)
        const getColorByPercentage = (percentual) => {
            if (percentual < 50) return '#e74c3c';        // Vermelho
            if (percentual < 80) return '#f39c12';        // Amarelo
            if (percentual <= 120) return '#27ae60';      // Verde
            return '#8e44ad';                            // Roxo (acima de 120%)
        };
        
        const backgroundColors = percentuais.map(p => getColorByPercentage(p) + '80');
        const borderColors = percentuais.map(p => getColorByPercentage(p));
        
        new Chart(percentualExecucaoChart.getContext('2d'), {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Percentual de Execução',
                    data: percentuais,
                    backgroundColor: backgroundColors,
                    borderColor: borderColors,
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Percentual de Execução por Natureza de Despesa',
                        font: { size: 16 }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const percentual = context.parsed.y.toFixed(2) + '%';
                                const planejado = formatarMoeda(naturezasComDivergencia[context.dataIndex].planejado);
                                const empenhado = formatarMoeda((naturezasComDivergencia[context.dataIndex].planejado * context.parsed.y) / 100);
                                return [
                                    `Execução: ${percentual}`,
                                    `Planejado: ${planejado}`,
                                    `Empenhado: ${empenhado}`
                                ];
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        suggestedMax: 150,
                        ticks: {
                            callback: function(value) {
                                return value + '%';
                            }
                        }
                    }
                }
            }
        });
    }
}

// Paletas de cores para os gráficos
const graphColorPalettes = {
    default: ['#4361ee', '#4cc9f0', '#3a0ca3', '#f72585', '#7209b7', '#560bad', '#480ca8', '#4895ef'],
    grayscale: ['#151515', '#313131', '#555555', '#888888', '#AAAAAA', '#CCCCCC', '#E0E0E0', '#F5F5F5'],
    colorblind: ['#006BA4', '#FF800E', '#ABABAB', '#595959', '#5F9ED1', '#C85200', '#898989', '#A2C8EC'],
    pastel: ['#A1C9F4', '#FFB482', '#8DE5A1', '#FF9F9B', '#D0BBFF', '#DEBB9B', '#CFD5E5', '#FFC8DC'],
    warm: ['#E58606', '#5D69B1', '#52BCA3', '#99C945', '#CC61B0', '#24796C', '#DAA51B', '#2F8AC4']
};

// Funções para auditoria contábil

/**
 * Realiza auditoria nos dados contábeis, identificando inconsistências e anomalias
 * @param {Array} dados - Conjunto de dados a ser auditado
 * @returns {Object} Resultado da auditoria
 */
function auditarDadosContabeis(dados) {
    if (!dados || dados.length === 0) {
        return {
            status: 'error',
            message: 'Não há dados disponíveis para auditoria.'
        };
    }
    
    // Inicializar estruturas para armazenar resultados
    const resultado = {
        inconsistencias: [],
        duplicidades: [],
        anomalias: [],
        totalRegistros: dados.length,
        resumo: {
            totalInconsistencias: 0,
            totalDuplicidades: 0,
            totalAnomalias: 0,
            nivelConfianca: 100,
            observacoes: []
        }
    };
    
    // Dicionários para controle de duplicidades
    const numerosEmpenho = {};
    const numerosLiquidacao = {};
    const numerosPagamento = {};
    
    // Armazenar valores para detecção de outliers
    const valoresEmpenhados = [];
    const valoresLiquidados = [];
    const valoresPagos = [];
    
    // Verificar cada registro
    dados.forEach((registro, index) => {
        // 1. Verificar valores inconsistentes
        verificarValoresInconsistentes(registro, index, resultado);
        
        // 2. Verificar datas inconsistentes
        verificarDatasInconsistentes(registro, index, resultado);
        
        // 3. Verificar duplicidades
        verificarDuplicidades(registro, index, resultado, numerosEmpenho, numerosLiquidacao, numerosPagamento);
        
        // 4. Coletar valores para análise estatística
        if (registro.Valor_Empenhado > 0) valoresEmpenhados.push(registro.Valor_Empenhado);
        if (registro.Valor_Liquidado > 0) valoresLiquidados.push(registro.Valor_Liquidado);
        if (registro.Valor_Pago > 0) valoresPagos.push(registro.Valor_Pago);
    });
    
    // 5. Detectar outliers (valores anômalos)
    detectarOutliers(valoresEmpenhados, 'Valor_Empenhado', resultado);
    detectarOutliers(valoresLiquidados, 'Valor_Liquidado', resultado);
    detectarOutliers(valoresPagos, 'Valor_Pago', resultado);
    
    // 6. Verificar consistência entre empenhos, liquidações e pagamentos
    verificarConsistenciaFases(dados, resultado);
    
    // Contabilizar totais
    resultado.resumo.totalInconsistencias = resultado.inconsistencias.length;
    resultado.resumo.totalDuplicidades = resultado.duplicidades.length;
    resultado.resumo.totalAnomalias = resultado.anomalias.length;
    
    // Calcular nível de confiança
    resultado.resumo.nivelConfianca = calcularNivelConfianca(resultado);
    
    // Gerar observações
    gerarObservacoesAuditoria(resultado);
    
    return resultado;
}

/**
 * Verifica valores inconsistentes em um registro
 */
function verificarValoresInconsistentes(registro, index, resultado) {
    // Verificar valores negativos
    if (registro.Valor_Empenhado < 0) {
        resultado.inconsistencias.push({
            tipo: 'Valor negativo',
            campo: 'Valor_Empenhado',
            registro: index,
            valor: registro.Valor_Empenhado,
            descricao: 'Empenho com valor negativo'
        });
    }
    
    if (registro.Valor_Liquidado < 0) {
        resultado.inconsistencias.push({
            tipo: 'Valor negativo',
            campo: 'Valor_Liquidado',
            registro: index,
            valor: registro.Valor_Liquidado,
            descricao: 'Liquidação com valor negativo'
        });
    }
    
    if (registro.Valor_Pago < 0) {
        resultado.inconsistencias.push({
            tipo: 'Valor negativo',
            campo: 'Valor_Pago',
            registro: index,
            valor: registro.Valor_Pago,
            descricao: 'Pagamento com valor negativo'
        });
    }
    
    // Verificar se liquidação excede empenho
    if (registro.Valor_Liquidado > registro.Valor_Empenhado && registro.Valor_Empenhado > 0) {
        resultado.inconsistencias.push({
            tipo: 'Liquidação excede empenho',
            campo: 'Valor_Liquidado',
            registro: index,
            valorLiquidado: registro.Valor_Liquidado,
            valorEmpenhado: registro.Valor_Empenhado,
            diferenca: registro.Valor_Liquidado - registro.Valor_Empenhado,
            descricao: `Valor liquidado (${formatarMoeda(registro.Valor_Liquidado)}) maior que o empenhado (${formatarMoeda(registro.Valor_Empenhado)})`
        });
    }

    // Verificar se pagamento excede liquidação
    if (registro.Valor_Pago > registro.Valor_Liquidado && registro.Valor_Liquidado > 0) {
        resultado.inconsistencias.push({
            tipo: 'Pagamento excede liquidação',
            campo: 'Valor_Pago',
            registro: index,
            valorPago: registro.Valor_Pago,
            valorLiquidado: registro.Valor_Liquidado,
            diferenca: registro.Valor_Pago - registro.Valor_Liquidado,
            descricao: `Valor pago (${formatarMoeda(registro.Valor_Pago)}) maior que o liquidado (${formatarMoeda(registro.Valor_Liquidado)})`
        });
    }
    
    // Verificar pagamento sem liquidação prévia
    if (registro.Valor_Pago > 0 && registro.Valor_Liquidado === 0) {
        resultado.inconsistencias.push({
            tipo: 'Pagamento sem liquidação',
            campo: 'Valor_Pago',
            registro: index,
            valorPago: registro.Valor_Pago,
            descricao: 'Pagamento realizado sem liquidação prévia'
        });
    }
    
    // Verificar liquidação sem empenho prévio
    if (registro.Valor_Liquidado > 0 && registro.Valor_Empenhado === 0) {
        resultado.inconsistencias.push({
            tipo: 'Liquidação sem empenho',
            campo: 'Valor_Liquidado',
            registro: index,
            valorLiquidado: registro.Valor_Liquidado,
            descricao: 'Liquidação realizada sem empenho prévio'
        });
    }
}

/**
 * Verifica datas inconsistentes em um registro
 */
function verificarDatasInconsistentes(registro, index, resultado) {
    const hoje = new Date();
    
    // Verificar datas futuras
    if (registro.Data_Empenho instanceof Date && registro.Data_Empenho > hoje) {
        resultado.inconsistencias.push({
            tipo: 'Data futura',
            campo: 'Data_Empenho',
            registro: index,
            data: registro.Data_Empenho,
            descricao: `Data de empenho (${registro.Data_Empenho.toLocaleDateString()}) no futuro`
        });
    }
    
    if (registro.Data_Liquidacao instanceof Date && registro.Data_Liquidacao > hoje) {
        resultado.inconsistencias.push({
            tipo: 'Data futura',
            campo: 'Data_Liquidacao',
            registro: index,
            data: registro.Data_Liquidacao,
            descricao: `Data de liquidação (${registro.Data_Liquidacao.toLocaleDateString()}) no futuro`
        });
    }
    
    if (registro.Data_Pagamento instanceof Date && registro.Data_Pagamento > hoje) {
        resultado.inconsistencias.push({
            tipo: 'Data futura',
            campo: 'Data_Pagamento',
            registro: index,
            data: registro.Data_Pagamento,
            descricao: `Data de pagamento (${registro.Data_Pagamento.toLocaleDateString()}) no futuro`
        });
    }
    
    // Verificar sequência cronológica incorreta
    if (registro.Data_Empenho instanceof Date && 
        registro.Data_Liquidacao instanceof Date && 
        registro.Data_Liquidacao < registro.Data_Empenho) {
        
        resultado.inconsistencias.push({
            tipo: 'Sequência cronológica inválida',
            campo: 'Data_Liquidacao',
            registro: index,
            dataLiquidacao: registro.Data_Liquidacao,
            dataEmpenho: registro.Data_Empenho,
            descricao: `Data de liquidação (${registro.Data_Liquidacao.toLocaleDateString()}) anterior à data de empenho (${registro.Data_Empenho.toLocaleDateString()})`
        });
    }
    
    if (registro.Data_Liquidacao instanceof Date && 
        registro.Data_Pagamento instanceof Date && 
        registro.Data_Pagamento < registro.Data_Liquidacao) {
        
        resultado.inconsistencias.push({
            tipo: 'Sequência cronológica inválida',
            campo: 'Data_Pagamento',
            registro: index,
            dataPagamento: registro.Data_Pagamento,
            dataLiquidacao: registro.Data_Liquidacao,
            descricao: `Data de pagamento (${registro.Data_Pagamento.toLocaleDateString()}) anterior à data de liquidação (${registro.Data_Liquidacao.toLocaleDateString()})`
        });
    }
    
    if (registro.Data_Empenho instanceof Date && 
        registro.Data_Pagamento instanceof Date && 
        registro.Data_Pagamento < registro.Data_Empenho) {
        
        resultado.inconsistencias.push({
            tipo: 'Sequência cronológica inválida',
            campo: 'Data_Pagamento',
            registro: index,
            dataPagamento: registro.Data_Pagamento,
            dataEmpenho: registro.Data_Empenho,
            descricao: `Data de pagamento (${registro.Data_Pagamento.toLocaleDateString()}) anterior à data de empenho (${registro.Data_Empenho.toLocaleDateString()})`
        });
    }
}

/**
 * Verifica duplicidades em números de documento
 */
function verificarDuplicidades(registro, index, resultado, numerosEmpenho, numerosLiquidacao, numerosPagamento) {
    // Verificar duplicidade no número de empenho
    if (registro.Numero_Empenho && registro.Valor_Empenhado > 0) {
        if (numerosEmpenho[registro.Numero_Empenho]) {
            const registroAnterior = numerosEmpenho[registro.Numero_Empenho];
            
            // Verificar se é realmente uma duplicidade (mesmo número, valores diferentes, não complementar)
            // Geralmente, um reforço de empenho é legítimo, mas com valores diferentes
            if (registroAnterior.valor !== registro.Valor_Empenhado &&
               !registro.Numero_Empenho.includes('COMPLEMENTAR') &&
               !registro.Numero_Empenho.includes('REFORCO')) {
                
                resultado.duplicidades.push({
                    tipo: 'Empenho duplicado',
                    campo: 'Numero_Empenho',
                    registro: index,
                    registroAnterior: registroAnterior.index,
                    numero: registro.Numero_Empenho,
                    valorAtual: registro.Valor_Empenhado,
                    valorAnterior: registroAnterior.valor,
                    descricao: `Número de empenho "${registro.Numero_Empenho}" duplicado com valores diferentes`
                });
            }
        } else {
            numerosEmpenho[registro.Numero_Empenho] = {
                index: index,
                valor: registro.Valor_Empenhado,
                data: registro.Data_Empenho
            };
        }
    }
    
    // Verificar duplicidade no número de liquidação
    if (registro.Numero_Liquidacao && registro.Valor_Liquidado > 0) {
        if (numerosLiquidacao[registro.Numero_Liquidacao]) {
            const registroAnterior = numerosLiquidacao[registro.Numero_Liquidacao];
            
            if (registroAnterior.valor !== registro.Valor_Liquidado) {
                resultado.duplicidades.push({
                    tipo: 'Liquidação duplicada',
                    campo: 'Numero_Liquidacao',
                    registro: index,
                    registroAnterior: registroAnterior.index,
                    numero: registro.Numero_Liquidacao,
                    valorAtual: registro.Valor_Liquidado,
                    valorAnterior: registroAnterior.valor,
                    descricao: `Número de liquidação "${registro.Numero_Liquidacao}" duplicado com valores diferentes`
                });
            }
        } else {
            numerosLiquidacao[registro.Numero_Liquidacao] = {
                index: index,
                valor: registro.Valor_Liquidado,
                data: registro.Data_Liquidacao
            };
        }
    }
    
    // Verificar duplicidade no número de pagamento
    if (registro.Numero_Pagamento && registro.Valor_Pago > 0) {
        if (numerosPagamento[registro.Numero_Pagamento]) {
            const registroAnterior = numerosPagamento[registro.Numero_Pagamento];
            
            if (registroAnterior.valor !== registro.Valor_Pago) {
                resultado.duplicidades.push({
                    tipo: 'Pagamento duplicado',
                    campo: 'Numero_Pagamento',
                    registro: index,
                    registroAnterior: registroAnterior.index,
                    numero: registro.Numero_Pagamento,
                    valorAtual: registro.Valor_Pago,
                    valorAnterior: registroAnterior.valor,
                    descricao: `Número de pagamento "${registro.Numero_Pagamento}" duplicado com valores diferentes`
                });
            }
        } else {
            numerosPagamento[registro.Numero_Pagamento] = {
                index: index,
                valor: registro.Valor_Pago,
                data: registro.Data_Pagamento
            };
        }
    }
}

/**
 * Detecta valores outliers (anômalos) em uma série de valores
 */
function detectarOutliers(valores, campo, resultado) {
    if (valores.length < 10) return; // Precisa de dados suficientes para análise estatística
    
    // Ordenar valores
    const valoresOrdenados = [...valores].sort((a, b) => a - b);
    
    // Calcular quartis
    const q1Index = Math.floor(valoresOrdenados.length * 0.25);
    const q3Index = Math.floor(valoresOrdenados.length * 0.75);
    
    const q1 = valoresOrdenados[q1Index];
    const q3 = valoresOrdenados[q3Index];
    
    // Calcular IQR (Intervalo Interquartil)
    const iqr = q3 - q1;
    
    // Definir limites para outliers (método padrão: Q1 - 1.5*IQR e Q3 + 1.5*IQR)
    const limiteInferior = q1 - 1.5 * iqr;
    const limiteSuperior = q3 + 1.5 * iqr;
    
    // Identificar outliers
    valores.forEach((valor, index) => {
        if (valor < limiteInferior || valor > limiteSuperior) {
            resultado.anomalias.push({
                tipo: 'Valor atípico',
                campo: campo,
                valor: valor,
                q1: q1,
                q3: q3,
                limiteInferior: limiteInferior,
                limiteSuperior: limiteSuperior,
                registro: index,
                descricao: valor > limiteSuperior ?
                    `Valor excepcionalmente alto (${formatarMoeda(valor)})` :
                    `Valor excepcionalmente baixo (${formatarMoeda(valor)})`
            });
        }
    });
}

/**
 * Verifica a consistência entre fases de empenho, liquidação e pagamento
 */
function verificarConsistenciaFases(dados, resultado) {
    // Agrupar por número de empenho
    const empenhosPorNumero = {};
    
    dados.forEach((registro, index) => {
        if (registro.Numero_Empenho) {
            if (!empenhosPorNumero[registro.Numero_Empenho]) {
                empenhosPorNumero[registro.Numero_Empenho] = {
                    registros: [],
                    totalEmpenhado: 0,
                    totalLiquidado: 0,
                    totalPago: 0
                };
            }
            
            empenhosPorNumero[registro.Numero_Empenho].registros.push({...registro, index});
            
            if (registro.Valor_Empenhado > 0) {
                empenhosPorNumero[registro.Numero_Empenho].totalEmpenhado += registro.Valor_Empenhado;
            }
            
            if (registro.Valor_Liquidado > 0) {
                empenhosPorNumero[registro.Numero_Empenho].totalLiquidado += registro.Valor_Liquidado;
            }
            
            if (registro.Valor_Pago > 0) {
                empenhosPorNumero[registro.Numero_Empenho].totalPago += registro.Valor_Pago;
            }
        }
    });
    
    // Verificar consistência para cada grupo de empenho
    Object.entries(empenhosPorNumero).forEach(([numeroEmpenho, dados]) => {
        const { totalEmpenhado, totalLiquidado, totalPago, registros } = dados;
        
        // Verificar se liquidação total excede empenho total
        if (totalLiquidado > totalEmpenhado * 1.01) { // Tolerância de 1% para arredondamentos
            resultado.inconsistencias.push({
                tipo: 'Liquidação total excede empenho total',
                empenho: numeroEmpenho,
                totalEmpenhado: totalEmpenhado,
                totalLiquidado: totalLiquidado,
                diferenca: totalLiquidado - totalEmpenhado,
                registrosEnvolvidos: registros.map(r => r.index),
                descricao: `Empenho ${numeroEmpenho}: Total liquidado (${formatarMoeda(totalLiquidado)}) excede o total empenhado (${formatarMoeda(totalEmpenhado)})`
            });
        }
        
        // Verificar se pagamento total excede liquidação total
        if (totalPago > totalLiquidado * 1.01) { // Tolerância de 1% para arredondamentos
            resultado.inconsistencias.push({
                tipo: 'Pagamento total excede liquidação total',
                empenho: numeroEmpenho,
                totalLiquidado: totalLiquidado,
                totalPago: totalPago,
                diferenca: totalPago - totalLiquidado,
                registrosEnvolvidos: registros.map(r => r.index),
                descricao: `Empenho ${numeroEmpenho}: Total pago (${formatarMoeda(totalPago)}) excede o total liquidado (${formatarMoeda(totalLiquidado)})`
            });
        }
    });
}

/**
 * Calcula o nível de confiança dos dados com base nas inconsistências detectadas
 */
function calcularNivelConfianca(resultado) {
    const { totalRegistros } = resultado;
    const totalProblemas = resultado.inconsistencias.length + resultado.duplicidades.length + resultado.anomalias.length;
    
    if (totalRegistros === 0) return 0;
    
    // Pesos para cada tipo de problema
    const pesoInconsistencia = 1.0; // Cada inconsistência reduz 1 ponto percentual
    const pesoDuplicidade = 0.7;    // Cada duplicidade reduz 0.7 pontos percentuais
    const pesoAnomalia = 0.3;       // Cada anomalia reduz 0.3 pontos percentuais
    
    // Calcular penalidades ponderadas
    const penalidades = 
        (resultado.inconsistencias.length * pesoInconsistencia) + 
        (resultado.duplicidades.length * pesoDuplicidade) + 
        (resultado.anomalias.length * pesoAnomalia);
    
    // Aplicar escala para não penalizar muito conjuntos grandes de dados
    const fatorEscala = Math.min(1, Math.sqrt(100 / totalRegistros));
    
    // Calcular nível de confiança (base 100%)
    let nivelConfianca = 100 - (penalidades * fatorEscala);
    
    // Limitar entre 0 e 100
    return Math.max(0, Math.min(100, nivelConfianca));
}

/**
 * Gera observações e recomendações com base nos resultados da auditoria
 */
function gerarObservacoesAuditoria(resultado) {
    const observacoes = [];
    
    // Analisar inconsistências por tipo
    const tiposInconsistencia = {};
    resultado.inconsistencias.forEach(inc => {
        tiposInconsistencia[inc.tipo] = (tiposInconsistencia[inc.tipo] || 0) + 1;
    });
    
    // Observações sobre inconsistências de valores
    if (tiposInconsistencia['Liquidação excede empenho'] || tiposInconsistencia['Liquidação total excede empenho total']) {
        observacoes.push(`Foram encontradas ${tiposInconsistencia['Liquidação excede empenho'] || 0 + tiposInconsistencia['Liquidação total excede empenho total'] || 0} ocorrências de liquidações com valor superior ao empenhado, o que pode indicar erros de registro ou problemas no controle financeiro.`);
    }
    
    if (tiposInconsistencia['Pagamento excede liquidação'] || tiposInconsistencia['Pagamento total excede liquidação total']) {
        observacoes.push(`Foram encontradas ${tiposInconsistencia['Pagamento excede liquidação'] || 0 + tiposInconsistencia['Pagamento total excede liquidação total'] || 0} ocorrências de pagamentos com valor superior ao liquidado, o que viola o fluxo normal do processo de execução da despesa.`);
    }
    
    if (tiposInconsistencia['Pagamento sem liquidação']) {
        observacoes.push(`Existem ${tiposInconsistencia['Pagamento sem liquidação']} registros de pagamentos sem liquidação prévia, o que contraria o procedimento legal de execução da despesa pública.`);
    }
    
    // Observações sobre inconsistências de datas
    if (tiposInconsistencia['Data futura']) {
        observacoes.push(`Foram identificados ${tiposInconsistencia['Data futura']} registros com datas futuras, que podem ser erros de digitação ou problemas na importação dos dados.`);
    }
    
    if (tiposInconsistencia['Sequência cronológica inválida']) {
        observacoes.push(`Existem ${tiposInconsistencia['Sequência cronológica inválida']} violações na sequência cronológica esperada (empenho → liquidação → pagamento), indicando possíveis erros nos registros de datas.`);
    }
    
    // Observações sobre duplicidades
    if (resultado.duplicidades.length > 0) {
        observacoes.push(`Foram encontrados ${resultado.duplicidades.length} documentos duplicados (empenhos, liquidações ou pagamentos), o que pode indicar problemas no controle de numeração ou registros em duplicidade no sistema.`);
    }
    
    // Observações sobre anomalias estatísticas
    if (resultado.anomalias.length > 0) {
        observacoes.push(`O sistema identificou ${resultado.anomalias.length} valores atípicos (outliers) que se distanciam significativamente da distribuição normal dos dados, sugerindo possíveis erros de registro ou situações excepcionais que merecem análise individual.`);
    }
    
    // Adicionar observação geral sobre a confiabilidade
    if (resultado.resumo.nivelConfianca >= 90) {
        observacoes.push(`Os dados apresentam alta confiabilidade (${resultado.resumo.nivelConfianca.toFixed(2)}%), com poucas inconsistências em relação ao volume total analisado.`);
    } else if (resultado.resumo.nivelConfianca >= 70) {
        observacoes.push(`Os dados apresentam confiabilidade moderada (${resultado.resumo.nivelConfianca.toFixed(2)}%), com inconsistências que merecem atenção, mas não comprometem significativamente a análise geral.`);
    } else {
        observacoes.push(`Os dados apresentam baixa confiabilidade (${resultado.resumo.nivelConfianca.toFixed(2)}%), com um número significativo de inconsistências que podem prejudicar análises e conclusões baseadas nestes registros.`);
    }
    
    // Adicionar recomendações
    if (resultado.inconsistencias.length > 0 || resultado.duplicidades.length > 0) {
        observacoes.push(`Recomenda-se uma revisão dos registros inconsistentes identificados e ajuste dos mecanismos de controle para evitar novas ocorrências de inconsistências semelhantes.`);
    }
    
    if (tiposInconsistencia['Sequência cronológica inválida'] || tiposInconsistencia['Data futura']) {
        observacoes.push(`Sugere-se a implementação de validações de data nos sistemas de origem para prevenir registros com sequência cronológica inválida ou datas futuras.`);
    }
    
    if (resultado.resumo.nivelConfianca < 70) {
        observacoes.push(`Devido ao baixo nível de confiabilidade, recomenda-se realizar uma revisão detalhada dos dados antes de utilizá-los para análises críticas ou tomada de decisão.`);
    }
    
    resultado.resumo.observacoes = observacoes;
}

/**
 * Gera relatório de auditoria em formato HTML
 */
function gerarRelatorioAuditoria(resultado) {
    if (!resultado) {
        return `
            <div class="alert alert-warning">
                <i class="fas fa-exclamation-triangle"></i>
                Não foi possível gerar o relatório de auditoria. Resultados não disponíveis.
            </div>
        `;
    }
    
    // Definir classe CSS conforme nível de confiança
    let nivelConfiancaClass = 'badge-success';
    if (resultado.resumo.nivelConfianca < 70) {
        nivelConfiancaClass = 'badge-danger';
    } else if (resultado.resumo.nivelConfianca < 90) {
        nivelConfiancaClass = 'badge-warning';
    }
    
    let html = `
        <div class="card mb-4">
            <div class="card-header bg-primary text-white">
                <h5 class="mb-0">Relatório de Auditoria de Dados Contábeis</h5>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-4">
                        <div class="card h-100">
                            <div class="card-body text-center">
                                <h2 class="display-4 font-weight-bold ${nivelConfiancaClass}" style="padding: 10px; border-radius: 5px;">
                                    ${resultado.resumo.nivelConfianca.toFixed(1)}%
                                </h2>
                                <p class="lead">Nível de Confiança dos Dados</p>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-8">
                        <div class="card h-100">
                            <div class="card-body">
                                <h5>Resumo da Análise</h5>
                                <table class="table table-sm">
                                    <tbody>
                                        <tr>
                                            <th width="200">Registros Analisados</th>
                                            <td><strong>${resultado.totalRegistros}</strong></td>
                                        </tr>
                                        <tr>
                                            <th>Inconsistências</th>
                                            <td>
                                                <span class="badge badge-${resultado.inconsistencias.length > 0 ? 'danger' : 'success'}">
                                                    ${resultado.inconsistencias.length}
                                                </span>
                                            </td>
                                        </tr>
                                        <tr>
                                            <th>Duplicidades</th>
                                            <td>
                                                <span class="badge badge-${resultado.duplicidades.length > 0 ? 'warning' : 'success'}">
                                                    ${resultado.duplicidades.length}
                                                </span>
                                            </td>
                                        </tr>
                                        <tr>
                                            <th>Valores Atípicos</th>
                                            <td>
                                                <span class="badge badge-${resultado.anomalias.length > 0 ? 'info' : 'success'}">
                                                    ${resultado.anomalias.length}
                                                </span>
                                            </td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="mt-4">
                    <h5>Observações e Recomendações</h5>
                    <div class="p-3 bg-light rounded">
                        <ul class="mb-0">
                            ${resultado.resumo.observacoes.map(obs => `<li>${obs}</li>`).join('')}
                        </ul>
                    </div>
                </div>
    `;
    
    // Adicionar detalhamento das inconsistências se houver
    if (resultado.inconsistencias.length > 0) {
        html += `
            <div class="mt-4">
                <h5>Detalhamento das Inconsistências</h5>
                <div class="table-responsive">
                    <table class="table table-sm table-striped table-hover">
                        <thead>
                            <tr>
                                <th>Tipo</th>
                                <th>Campo</th>
                                <th>Registro</th>
                                <th>Descrição</th>
                            </tr>
                        </thead>
                        <tbody>
        `;
        
        // Limitar a 15 inconsistências para não sobrecarregar o relatório
        const limite = Math.min(15, resultado.inconsistencias.length);
        for (let i = 0; i < limite; i++) {
            const inconsistencia = resultado.inconsistencias[i];
            html += `
                <tr>
                    <td>${inconsistencia.tipo}</td>
                    <td>${inconsistencia.campo}</td>
                    <td>${inconsistencia.registro}</td>
                    <td>${inconsistencia.descricao}</td>
                </tr>
            `;
        }
        
        // Se existirem mais inconsistências, mostrar uma mensagem indicando
        if (resultado.inconsistencias.length > limite) {
            html += `
                <tr>
                    <td colspan="4" class="text-center">
                        <em>... e mais ${resultado.inconsistencias.length - limite} inconsistências não mostradas</em>
                    </td>
                </tr>
            `;
        }
        
        html += `
                        </tbody>
                    </table>
                </div>
            </div>
        `;
    }
    
    html += `
            </div>
            <div class="card-footer text-muted text-center">
                <small>Relatório gerado em ${new Date().toLocaleString('pt-BR')} pelo Sistema SUAD</small>
            </div>
        </div>
    `;
    
    return html;
}

// Inicializar a interface do sistema SUAD quando o documento estiver pronto
document.addEventListener('DOMContentLoaded', function() {
    inicializarSistema();
});

/**
 * Inicializa o sistema SUAD
 */
function inicializarSistema() {
    configurarMenuNavegacao();
    configurarImportacaoDados();
    configurarGeracaoRelatorios();
    configurarFerramentasAdicionais();
    
    // Mostrar tela inicial
    mostrarSecao('dashboard');
    
    console.log("Sistema SUAD inicializado com sucesso!");
}

/**
 * Configura o menu de navegação do sistema
 */
function configurarMenuNavegacao() {
    // Adicionar listeners para os itens do menu
    document.querySelectorAll('.menu-item').forEach(item => {
        item.addEventListener('click', function() {
            const secao = this.getAttribute('data-section');
            mostrarSecao(secao);
        });
    });
}

/**
 * Mostra a seção especificada e esconde as demais
 * @param {string} secaoId - ID da seção a ser mostrada
 */
function mostrarSecao(secaoId) {
    // Esconder todas as seções
    document.querySelectorAll('section').forEach(secao => {
        secao.style.display = 'none';
    });
    
    // Remover classe "active" de todos os itens do menu
    document.querySelectorAll('.menu-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // Mostrar a seção selecionada
    const secaoAlvo = document.getElementById(`${secaoId}Section`);
    if (secaoAlvo) {
        secaoAlvo.style.display = 'block';
    }
    
    // Adicionar classe "active" ao item do menu correspondente
    const menuItem = document.querySelector(`.menu-item[data-section="${secaoId}"]`);
    if (menuItem) {
        menuItem.classList.add('active');
    }
}

/**
 * Configura a funcionalidade de importação de dados
 */
function configurarImportacaoDados() {
    // Configurar upload de arquivo
    const inputArquivo = document.getElementById('importarArquivo');
    if (inputArquivo) {
        inputArquivo.addEventListener('change', handleFileUpload);
    }
    
    // Configurar botão de exemplo (dados de demonstração)
    const btnExemplo = document.getElementById('carregarExemplo');
    if (btnExemplo) {
        btnExemplo.addEventListener('click', carregarDadosExemplo);
    }
}

/**
 * Manipula o upload de arquivo
 */
function handleFileUpload(event) {
    const file = event.target.files[0];
    if (!file) {
        mostrarMensagem('Nenhum arquivo selecionado', 'warning');
        return;
    }
    
    const extensao = file.name.split('.').pop().toLowerCase();
    
    // Verificar extensão do arquivo
    if (extensao !== 'xlsx' && extensao !== 'xls' && extensao !== 'csv') {
        mostrarMensagem('Formato de arquivo não suportado. Use arquivos Excel (.xlsx, .xls) ou CSV (.csv)', 'error');
        return;
    }
    
    // Mostrar indicador de carregamento
    mostrarCarregamento(true);
    
    // Processar o arquivo conforme seu tipo
    if (extensao === 'csv') {
        processarArquivoCSV(file);
    } else {
        processarArquivoExcel(file);
    }
}

/**
 * Processa arquivo CSV
 */
function processarArquivoCSV(file) {
    const reader = new FileReader();
    
    reader.onload = function(e) {
        try {
            const csvData = e.target.result;
            
            // Parsear CSV usando PapaParse
            Papa.parse(csvData, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    processarDadosImportados(results.data);
                },
                error: function(error) {
                    mostrarMensagem(`Erro ao processar arquivo CSV: ${error.message}`, 'error');
                    mostrarCarregamento(false);
                }
            });
        } catch (error) {
            mostrarMensagem(`Erro ao ler arquivo CSV: ${error.message}`, 'error');
            mostrarCarregamento(false);
        }
    };
    
    reader.onerror = function() {
        mostrarMensagem('Erro ao ler o arquivo', 'error');
        mostrarCarregamento(false);
    };
    
    reader.readAsText(file);
}

/**
 * Processa arquivo Excel
 */
function processarArquivoExcel(file) {
    const reader = new FileReader();
    
    reader.onload = function(e) {
        try {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array', cellDates: true });
            
            // Processar a primeira planilha
            const primeiraSheetNome = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[primeiraSheetNome];
            
            // Converter para JSON
            const jsonData = XLSX.utils.sheet_to_json(worksheet, { raw: false, dateNF: 'yyyy-mm-dd' });
            
            processarDadosImportados(jsonData);
        } catch (error) {
            mostrarMensagem(`Erro ao processar arquivo Excel: ${error.message}`, 'error');
            mostrarCarregamento(false);
        }
    };
    
    reader.onerror = function() {
        mostrarMensagem('Erro ao ler o arquivo', 'error');
        mostrarCarregamento(false);
    };
    
    reader.readAsArrayBuffer(file);
}

/**
 * Processa os dados após importação
 */
function processarDadosImportados(dados) {
    // Verificar se há dados válidos
    if (!dados || !Array.isArray(dados) || dados.length === 0) {
        mostrarMensagem('Não foi possível extrair dados do arquivo', 'error');
        mostrarCarregamento(false);
        return;
    }
    
    try {
        // Padronizar os nomes dos campos
        const dadosPadronizados = padronizarCampos(dados);
        
        // Converter tipos de dados (datas, valores monetários)
        const dadosConvertidos = converterTiposDados(dadosPadronizados);
        
        // Armazenar os dados na variável global
        window.allData = dadosConvertidos;
        window.filteredData = [...dadosConvertidos];
        
        // Atualizar interface com resumo dos dados
        atualizarResumoDados(dadosConvertidos);
        
        // Mostrar mensagem de sucesso
        mostrarMensagem(`Dados importados com sucesso! ${dadosConvertidos.length} registros carregados.`, 'success');
        
        // Esconder indicador de carregamento
        mostrarCarregamento(false);
        
        // Redirecionar para a seção de dashboard
        mostrarSecao('dashboard');
    } catch (error) {
        mostrarMensagem(`Erro ao processar dados: ${error.message}`, 'error');
        mostrarCarregamento(false);
    }
}

/**
 * Padroniza os nomes dos campos
 */
function padronizarCampos(dados) {
    // Mapeamento de nomes de campos possíveis para nomes padronizados
    const mapeamentoCampos = {
        // Campos de valores
        'valor_planejado': 'Valor_Planejado',
        'valor_dotacao': 'Valor_Planejado',
        'dotacao': 'Valor_Planejado',
        'valor_empenhado': 'Valor_Empenhado',
        'empenhado': 'Valor_Empenhado',
        'valor_liquidado': 'Valor_Liquidado',
        'liquidado': 'Valor_Liquidado',
        'valor_pago': 'Valor_Pago',
        'pago': 'Valor_Pago',
        
        // Campos de data
        'data_empenho': 'Data_Empenho',
        'dt_empenho': 'Data_Empenho',
        'data_liquidacao': 'Data_Liquidacao',
        'dt_liquidacao': 'Data_Liquidacao',
        'data_pagamento': 'Data_Pagamento',
        'dt_pagamento': 'Data_Pagamento',
        
        // Campos de numeração
        'numero_empenho': 'Numero_Empenho',
        'num_empenho': 'Numero_Empenho',
        'empenho': 'Numero_Empenho',
        'numero_liquidacao': 'Numero_Liquidacao',
        'num_liquidacao': 'Numero_Liquidacao',
        'liquidacao': 'Numero_Liquidacao',
        'numero_pagamento': 'Numero_Pagamento',
        'num_pagamento': 'Numero_Pagamento',
        'ordem_bancaria': 'Numero_Pagamento',
        'ob': 'Numero_Pagamento',
        
        // Campos de classificação
        'natureza_despesa': 'Natureza_Despesa',
        'natureza': 'Natureza_Despesa',
        'nd': 'Natureza_Despesa',
        'categoria_economica': 'Categoria_Economica',
        'categoria': 'Categoria_Economica',
        
        // Campos de entidade
        'unidade_gestora': 'Unidade_Gestora',
        'ug': 'Unidade_Gestora',
        'credor': 'Credor',
        'fornecedor': 'Credor',
        'favorecido': 'Credor',
        
        // Outros campos
        'exercicio': 'Exercicio',
        'ano': 'Exercicio',
        'fonte_recurso': 'Fonte_Recurso',
        'fonte': 'Fonte_Recurso',
        'programa_trabalho': 'Programa_Trabalho',
        'pt': 'Programa_Trabalho',
        'descricao': 'Descricao',
        'objeto': 'Descricao',
        'observacao': 'Observacao'
    };
    
    return dados.map(registro => {
        const novoRegistro = {};
        
        // Verificar cada campo do registro original
        Object.entries(registro).forEach(([campo, valor]) => {
            // Converter nome do campo para minúsculo para facilitar comparação
            const campoLower = campo.toLowerCase().replace(/[\s_-]/g, '_');
            
            // Usar nome padronizado se existir no mapeamento, ou manter o original
            const nomePadronizado = mapeamentoCampos[campoLower] || campo;
            
            // Adicionar ao novo registro
            novoRegistro[nomePadronizado] = valor;
        });
        
        return novoRegistro;
    });
}

/**
 * Converte tipos de dados (datas, valores monetários)
 */
function converterTiposDados(dados) {
    return dados.map(registro => {
        const novoRegistro = { ...registro };
        
        // Converter campos de data
        const camposData = ['Data_Empenho', 'Data_Liquidacao', 'Data_Pagamento', 'Data'];
        camposData.forEach(campo => {
            if (novoRegistro[campo]) {
                novoRegistro[campo] = converterParaData(novoRegistro[campo]);
            }
        });
        
        // Converter campos de valor
        const camposValor = ['Valor_Planejado', 'Valor_Empenhado', 'Valor_Liquidado', 'Valor_Pago'];
        camposValor.forEach(campo => {
            if (novoRegistro[campo] !== undefined) {
                novoRegistro[campo] = converterParaNumero(novoRegistro[campo]);
            } else {
                // Inicializar com zero se o campo não existir
                novoRegistro[campo] = 0;
            }
        });
        
        return novoRegistro;
    });
}

/**
 * Converte um valor para data
 */
function converterParaData(valor) {
    if (valor instanceof Date) {
        return valor;
    }
    
    if (typeof valor === 'string') {
        // Tentar vários formatos de data
        const formatos = [
            // ISO
            /^(\d{4})-(\d{2})-(\d{2})$/, // yyyy-mm-dd
            /^(\d{4})\/(\d{2})\/(\d{2})$/, // yyyy/mm/dd
            
            // Brasileiro
            /^(\d{2})\/(\d{2})\/(\d{4})$/, // dd/mm/yyyy
            /^(\d{2})-(\d{2})-(\d{4})$/, // dd-mm-yyyy
            
            // Americano
            /^(\d{2})\/(\d{2})\/(\d{4})$/, // mm/dd/yyyy
            /^(\d{2})-(\d{2})-(\d{4})$/ // mm-dd-yyyy
        ];
        
        for (const regex of formatos) {
            if (regex.test(valor)) {
                const match = valor.match(regex);
                
                if (match) {
                    // Verificar formato
                    if (regex.source.startsWith('^(\\d{4})')) {
                        // Formato yyyy-mm-dd
                        return new Date(match[1], parseInt(match[2]) - 1, match[3]);
                    } else {
                        // Tentar inferir se é brasileiro ou americano
                        const dia = parseInt(match[1]);
                        const mes = parseInt(match[2]);
                        const ano = parseInt(match[3]);
                        
                        // Se o primeiro número for > 12, provavelmente é dia (formato brasileiro)
                        if (dia > 12) {
                            return new Date(ano, mes - 1, dia);
                        } else {
                            // Assumir formato americano
                            return new Date(ano, dia - 1, mes);
                        }
                    }
                }
            }
        }
        
        // Tentar formato Excel (número de dias desde 1/1/1900)
        const numeroExcel = parseInt(valor);
        if (!isNaN(numeroExcel) && numeroExcel > 0) {
            // Data base do Excel (1/1/1900)
            const dataBase = new Date(1900, 0, 1);
            
            // Adicionar dias
            const dataConvertida = new Date(dataBase);
            dataConvertida.setDate(dataBase.getDate() + numeroExcel - 2); // -2 para corrigir o erro do Excel
            
            return dataConvertida;
        }
    }
    
    // Se não conseguir converter, retornar null
    return null;
}

/**
 * Converte um valor para número
 */
function converterParaNumero(valor) {
    if (typeof valor === 'number') {
        return valor;
    }
    
    if (typeof valor === 'string') {
        // Remover formatação de moeda
        const valorLimpo = valor.replace(/[^\d,.-]/g, '')
                              .replace(/\./g, 'X')  // Guardar ponto que pode ser milhar
                              .replace(/,/g, '.')   // Converter vírgula para ponto
                              .replace(/X/g, '');   // Remover pontos (separadores de milhar)
        
        return parseFloat(valorLimpo) || 0;
    }
    
    return 0;
}

/**
 * Atualiza o resumo dos dados na interface
 */
function atualizarResumoDados(dados) {
    // Calcular valores totais
    const totalRegistros = dados.length;
    const valorPlanejado = dados.reduce((soma, item) => soma + (item.Valor_Planejado || 0), 0);
    const valorEmpenhado = dados.reduce((soma, item) => soma + (item.Valor_Empenhado || 0), 0);
    const valorLiquidado = dados.reduce((soma, item) => soma + (item.Valor_Liquidado || 0), 0);
    const valorPago = dados.reduce((soma, item) => soma + (item.Valor_Pago || 0), 0);
    
    // Percentuais
    const percentualExecucao = valorPlanejado > 0 ? (valorEmpenhado / valorPlanejado) * 100 : 0;
    const percentualLiquidacao = valorEmpenhado > 0 ? (valorLiquidado / valorEmpenhado) * 100 : 0;
    const percentualPagamento = valorLiquidado > 0 ? (valorPago / valorLiquidado) * 100 : 0;
    
    // Atualizar caixas de resumo
    document.getElementById('totalRegistros').textContent = totalRegistros;
    document.getElementById('valorPlanejado').textContent = formatarMoeda(valorPlanejado);
    document.getElementById('valorEmpenhado').textContent = formatarMoeda(valorEmpenhado);
    document.getElementById('valorLiquidado').textContent = formatarMoeda(valorLiquidado);
    document.getElementById('valorPago').textContent = formatarMoeda(valorPago);
    document.getElementById('percentualExecucao').textContent = `${percentualExecucao.toFixed(2)}%`;
    document.getElementById('percentualLiquidacao').textContent = `${percentualLiquidacao.toFixed(2)}%`;
    document.getElementById('percentualPagamento').textContent = `${percentualPagamento.toFixed(2)}%`;
    
    // Atualizar barras de progresso
    document.getElementById('progressoExecucao').style.width = `${Math.min(100, percentualExecucao)}%`;
    document.getElementById('progressoLiquidacao').style.width = `${Math.min(100, percentualLiquidacao)}%`;
    document.getElementById('progressoPagamento').style.width = `${Math.min(100, percentualPagamento)}%`;
    
    // Atualizar classe das barras de progresso de acordo com o percentual
    atualizarClasseBarra('progressoExecucao', percentualExecucao);
    atualizarClasseBarra('progressoLiquidacao', percentualLiquidacao);
    atualizarClasseBarra('progressoPagamento', percentualPagamento);
    
    // Atualizar gráficos
    atualizarGraficosDashboard(dados);
}

/**
 * Atualiza a classe da barra de progresso conforme o percentual
 */
function atualizarClasseBarra(idBarra, percentual) {
    const barra = document.getElementById(idBarra);
    if (!barra) return;
    
    // Remover todas as classes de cor
    barra.classList.remove('bg-success', 'bg-warning', 'bg-danger', 'bg-info');
    
    // Adicionar classe conforme o percentual
    if (percentual >= 90) {
        barra.classList.add('bg-success');
    } else if (percentual >= 70) {
        barra.classList.add('bg-info');
    } else if (percentual >= 40) {
        barra.classList.add('bg-warning');
    } else {
        barra.classList.add('bg-danger');
    }
}

/**
 * Atualiza os gráficos do dashboard
 */
function atualizarGraficosDashboard(dados) {
    // Verificar se a biblioteca Chart.js está disponível
    if (typeof Chart === 'undefined') {
        console.error('Chart.js não está disponível');
        return;
    }
    
    // Destruir gráficos existentes se houver
    Chart.getChart('graficoExecucao')?.destroy();
    Chart.getChart('graficoExecucaoMensal')?.destroy();
    Chart.getChart('graficoNaturezas')?.destroy();
    
    // Criar gráfico de execução orçamentária
    criarGraficoExecucao(dados);
    
    // Criar gráfico de execução mensal
    criarGraficoExecucaoMensal(dados);
    
    // Criar gráfico de naturezas de despesa
    criarGraficoNaturezas(dados);
}

/**
 * Cria o gráfico de execução orçamentária
 */
function criarGraficoExecucao(dados) {
    const canvas = document.getElementById('graficoExecucao');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    
    // Calcular valores
    const valorPlanejado = dados.reduce((soma, item) => soma + (item.Valor_Planejado || 0), 0);
    const valorEmpenhado = dados.reduce((soma, item) => soma + (item.Valor_Empenhado || 0), 0);
    const valorLiquidado = dados.reduce((soma, item) => soma + (item.Valor_Liquidado || 0), 0);
    const valorPago = dados.reduce((soma, item) => soma + (item.Valor_Pago || 0), 0);
    
    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: ['Planejado', 'Empenhado', 'Liquidado', 'Pago'],
            datasets: [{
                label: 'Execução Orçamentária',
                data: [valorPlanejado, valorEmpenhado, valorLiquidado, valorPago],
                backgroundColor: [
                    'rgba(54, 162, 235, 0.7)',
                    'rgba(255, 206, 86, 0.7)',
                    'rgba(75, 192, 192, 0.7)',
                    'rgba(153, 102, 255, 0.7)'
                ],
                borderColor: [
                    'rgba(54, 162, 235, 1)',
                    'rgba(255, 206, 86, 1)',
                    'rgba(75, 192, 192, 1)',
                    'rgba(153, 102, 255, 1)'
                ],
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function(value) {
                            return formatarMoeda(value);
                        }
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return formatarMoeda(context.parsed.y);
                        }
                    }
                }
            }
        }
    });
}

/**
 * Cria o gráfico de execução mensal
 */
function criarGraficoExecucaoMensal(dados) {
    const canvas = document.getElementById('graficoExecucaoMensal');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    
    // Agrupar por mês
    const empenhosPorMes = {};
    const liquidacoesPorMes = {};
    const pagamentosPorMes = {};
    
    // Processar empenhos por mês
    dados.filter(d => d.Data_Empenho instanceof Date && d.Valor_Empenhado > 0).forEach(registro => {
        const data = registro.Data_Empenho;
        const mes = `${data.getFullYear()}-${String(data.getMonth() + 1).padStart(2, '0')}`;
        
        if (!empenhosPorMes[mes]) empenhosPorMes[mes] = 0;
        empenhosPorMes[mes] += registro.Valor_Empenhado;
    });
    
    // Processar liquidações por mês
    dados.filter(d => d.Data_Liquidacao instanceof Date && d.Valor_Liquidado > 0).forEach(registro => {
        const data = registro.Data_Liquidacao;
        const mes = `${data.getFullYear()}-${String(data.getMonth() + 1).padStart(2, '0')}`;
        
        if (!liquidacoesPorMes[mes]) liquidacoesPorMes[mes] = 0;
        liquidacoesPorMes[mes] += registro.Valor_Liquidado;
    });
    
    // Processar pagamentos por mês
    dados.filter(d => d.Data_Pagamento instanceof Date && d.Valor_Pago > 0).forEach(registro => {
        const data = registro.Data_Pagamento;
        const mes = `${data.getFullYear()}-${String(data.getMonth() + 1).padStart(2, '0')}`;
        
        if (!pagamentosPorMes[mes]) pagamentosPorMes[mes] = 0;
        pagamentosPorMes[mes] += registro.Valor_Pago;
    });
    
    // Obter todos os meses únicos e ordenar
    const todosMeses = [...new Set([
        ...Object.keys(empenhosPorMes),
        ...Object.keys(liquidacoesPorMes),
        ...Object.keys(pagamentosPorMes)
    ])].sort();
    
    // Formatar labels de meses para exibição
    const labelsFormatados = todosMeses.map(mes => {
        const [ano, numMes] = mes.split('-');
        const nomesMeses = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
        return `${nomesMeses[parseInt(numMes) - 1]}/${ano}`;
    });
    
    // Preparar dados para o gráfico
    const dadosEmpenhos = todosMeses.map(mes => empenhosPorMes[mes] || 0);
    const dadosLiquidacoes = todosMeses.map(mes => liquidacoesPorMes[mes] || 0);
    const dadosPagamentos = todosMeses.map(mes => pagamentosPorMes[mes] || 0);
    
    new Chart(ctx, {
        type: 'line',
        data: {
            labels: labelsFormatados,
            datasets: [
                {
                    label: 'Empenhado',
                    data: dadosEmpenhos,
                    borderColor: 'rgba(255, 206, 86, 1)',
                    backgroundColor: 'rgba(255, 206, 86, 0.2)',
                    fill: true,
                    tension: 0.4
                },
                {
                    label: 'Liquidado',
                    data: dadosLiquidacoes,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    fill: true,
                    tension: 0.4
                },
                {
                    label: 'Pago',
                    data: dadosPagamentos,
                    borderColor: 'rgba(153, 102, 255, 1)',
                    backgroundColor: 'rgba(153, 102, 255, 0.2)',
                    fill: true,
                    tension: 0.4
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function(value) {
                            return formatarMoeda(value);
                        }
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return `${context.dataset.label}: ${formatarMoeda(context.parsed.y)}`;
                        }
                    }
                }
            }
        }
    });
}

/**
 * Cria o gráfico de naturezas de despesa
 */
function criarGraficoNaturezas(dados) {
    const canvas = document.getElementById('graficoNaturezas');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    
    // Agrupar por natureza de despesa
    const porNatureza = {};
    
    dados.filter(d => d.Natureza_Despesa && d.Valor_Empenhado > 0).forEach(registro => {
        const natureza = registro.Natureza_Despesa;
        
        if (!porNatureza[natureza]) {
            porNatureza[natureza] = {
                valor: 0,
                descricao: obterDescricaoNaturezaDespesa(natureza)
            };
        }
        
        porNatureza[natureza].valor += registro.Valor_Empenhado;
    });
    
    // Ordenar naturezas por valor
    const naturezasOrdenadas = Object.entries(porNatureza)
        .sort((a, b) => b[1].valor - a[1].valor)
        .slice(0, 10); // Limitar às 10 maiores
    
    // Preparar dados para o gráfico
    const labels = naturezasOrdenadas.map(([natureza, dados]) => {
        const descricaoResumida = dados.descricao.length > 25 ? 
            dados.descricao.substring(0, 22) + '...' : 
            dados.descricao;
        return `${natureza} - ${descricaoResumida}`;
    });
    
    const valores = naturezasOrdenadas.map(([_, dados]) => dados.valor);
    
    // Cores para o gráfico
    const cores = [
        '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
        '#FF9F40', '#8AC926', '#1982C4', '#FF595E', '#6A4C93'
    ];
    
    new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: labels,
            datasets: [{
                data: valores,
                backgroundColor: cores,
                borderColor: cores.map(cor => cor.replace('1)', '1)')), // Manter opacidade total na borda
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'right',
                    labels: {
                        font: {
                            size: 10
                        }
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const valor = formatarMoeda(context.parsed);
                            const percentual = (context.parsed / context.dataset.data.reduce((a, b) => a + b, 0) * 100).toFixed(2);
                            return `${context.label}: ${valor} (${percentual}%)`;
                        }
                    }
                }
            }
        }
    });
}

/**
 * Carrega dados de exemplo para demonstração
 */
function carregarDadosExemplo() {
    // Mostrar indicador de carregamento
    mostrarCarregamento(true);
    
    // Obter a data atual
    const hoje = new Date();
    const anoAtual = hoje.getFullYear();
    
    // Gerar dados de exemplo
    const dadosExemplo = gerarDadosExemplo(anoAtual);
    
    // Processar os dados gerados
    processarDadosImportados(dadosExemplo);
}

/**
 * Gera dados de exemplo para demonstração
 */
function gerarDadosExemplo(ano) {
    const naturezas = [
        { codigo: '3.3.90.30', descricao: 'Material de Consumo' },
        { codigo: '3.3.90.39', descricao: 'Outros Serviços de Terceiros - PJ' },
        { codigo: '3.3.90.14', descricao: 'Diárias' },
        { codigo: '3.3.90.33', descricao: 'Passagens e Despesas com Locomoção' },
        { codigo: '3.3.90.36', descricao: 'Outros Serviços de Terceiros - PF' },
        { codigo: '4.4.90.52', descricao: 'Equipamentos e Material Permanente' },
        { codigo: '3.3.90.40', descricao: 'Serviços de Tecnologia da Informação' },
        { codigo: '3.3.90.37', descricao: 'Locação de Mão-de-Obra' },
        { codigo: '4.4.90.51', descricao: 'Obras e Instalações' }
    ];
    
    const credores = [
        'Empresa ABC Ltda.',
        'Serviços Gerais Ltda.',
        'Informática Sistemas S.A.',
        'Construtora XYZ',
        'Materiais de Escritório e Cia.',
        'Limpeza & Conservação S.A.',
        'Consultoria Técnica Especializada',
        'Suprimentos Eletrônicos S.A.',
        'Equipamentos Profissionais Ltda.',
        'Mobiliário Corporativo S.A.'
    ];
    
    // Configurações para distribuição de valores
    const dotacaoTotal = 10000000; // 10 milhões
    const distribuicaoNaturezas = [30, 25, 5, 5, 5, 15, 10, 3, 2]; // Percentuais
    
    // Distribuição temporal (pesos para cada mês)
    const distribuicaoMensal = [5, 5, 8, 7, 8, 12, 10, 9, 11, 10, 8, 7];
    
    // Array para armazenar os dados gerados
    const dados = [];
    
    // Gerar dados para cada natureza de despesa
    naturezas.forEach((natureza, indexNatureza) => {
        // Calcular valores para esta natureza
        const dotacaoNatureza = dotacaoTotal * (distribuicaoNaturezas[indexNatureza] / 100);
        
        // Escolher alguns credores para esta natureza
        const numCredores = Math.floor(Math.random() * 3) + 2; // 2 a 4 credores
        const credoresEscolhidos = shuffleArray([...credores]).slice(0, numCredores);
        
        // Distribuir o valor entre os meses
        for (let mes = 0; mes < 12; mes++) {
            // Verificar se este mês terá movimentação
            const pesoMes = distribuicaoMensal[mes];
            const probabilidadeMes = pesoMes / distribuicaoMensal.reduce((a, b) => a + b, 0);
            
            if (Math.random() < probabilidadeMes * 2) { // Multiplicar para aumentar chances
                // Escolher um credor aleatório
                const credorEscolhido = credoresEscolhidos[Math.floor(Math.random() * credoresEscolhidos.length)];
                
                // Calcular valor do empenho
                const valorEmpenhado = (dotacaoNatureza / 12) * (0.7 + Math.random() * 0.6);
                
                // Gerar dados do empenho
                const dataEmpenho = new Date(ano, mes, Math.floor(Math.random() * 28) + 1);
                const numeroEmpenho = `${ano}NE${String(indexNatureza).padStart(2, '0')}${String(mes).padStart(2, '0')}${Math.floor(Math.random() * 100).toString().padStart(2, '0')}`;
                
                // Decidir se terá liquidação e pagamento
                const terLiquidacao = Math.random() < 0.8; // 80% de chance
                let dataLiquidacao = null;
                let numeroLiquidacao = null;
                let valorLiquidado = 0;
                
                if (terLiquidacao) {
                    // Data de liquidação (entre 1 e 30 dias após o empenho)
                    const diasParaLiquidacao = Math.floor(Math.random() * 30) + 1;
                    dataLiquidacao = new Date(dataEmpenho);
                    dataLiquidacao.setDate(dataLiquidacao.getDate() + diasParaLiquidacao);
                    
                    // Número da liquidação
                    numeroLiquidacao = `${ano}LQ${numeroEmpenho.substring(6)}`;
                    
                    // Valor liquidado (pode ser o total ou parcial)
                    valorLiquidado = Math.random() < 0.7 ? 
                        valorEmpenhado : // Liquidação total
                        valorEmpenhado * (0.6 + Math.random() * 0.4); // Liquidação parcial
                }
                
                // Decidir se terá pagamento
                const terPagamento = terLiquidacao && Math.random() < 0.7; // 70% das liquidações são pagas
                let dataPagamento = null;
                let numeroPagamento = null;
                let valorPago = 0;
                
                if (terPagamento) {
                    // Data de pagamento (entre 1 e 20 dias após a liquidação)
                    const diasParaPagamento = Math.floor(Math.random() * 20) + 1;
                    dataPagamento = new Date(dataLiquidacao);
                    dataPagamento.setDate(dataPagamento.getDate() + diasParaPagamento);
                    
                    // Número do pagamento
                    numeroPagamento = `${ano}PG${numeroEmpenho.substring(6)}`;
                    
                    // Valor pago (pode ser o total ou parcial)
                    valorPago = Math.random() < 0.8 ? 
                        valorLiquidado : // Pagamento total
                        valorLiquidado * (0.7 + Math.random() * 0.3); // Pagamento parcial
                }
                
                // Adicionar registro
                dados.push({
                    Exercicio: ano,
                    Natureza_Despesa: natureza.codigo,
                    Descricao_Natureza: natureza.descricao,
                    Credor: credorEscolhido,
                    Valor_Planejado: dotacaoNatureza / 12, // Distribuir igualmente por mês
                    Valor_Empenhado: valorEmpenhado,
                    Data_Empenho: dataEmpenho,
                    Numero_Empenho: numeroEmpenho,
                    Valor_Liquidado: valorLiquidado,
                    Data_Liquidacao: dataLiquidacao,
                    Numero_Liquidacao: numeroLiquidacao,
                    Valor_Pago: valorPago,
                    Data_Pagamento: dataPagamento,
                    Numero_Pagamento: numeroPagamento,
                    Descricao: `${natureza.descricao} - ${credorEscolhido} (Exemplo)`
                });
            }
        }
    });
    
    return dados;
}

/**
 * Embaralha um array usando o algoritmo Fisher-Yates
 */
function shuffleArray(array) {
    const newArray = [...array];
    for (let i = newArray.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
    }
    return newArray;
}

/**
 * Configura a geração de relatórios
 */
function configurarGeracaoRelatorios() {
    // Adicionar listener para o botão de gerar relatório
    const btnGerarRelatorio = document.getElementById('gerarRelatorio');
    if (btnGerarRelatorio) {
        btnGerarRelatorio.addEventListener('click', gerarRelatorio);
    }
    
    // Adicionar listener para o botão de relatório contábil
    const btnGerarRelatorioContabil = document.getElementById('gerarRelatorioContabilBtn');
    if (btnGerarRelatorioContabil) {
        btnGerarRelatorioContabil.addEventListener('click', gerarRelatorioContabilHandler);
    }
}

/**
 * Gera um relatório com base nos filtros selecionados
 */
function gerarRelatorio() {
    // Verificar se há dados
    if (!window.filteredData || window.filteredData.length === 0) {
        mostrarMensagem('Não há dados disponíveis para gerar o relatório.', 'warning');
        return;
    }
    
    // Obter tipo de relatório selecionado
    const tipoRelatorio = document.getElementById('reportType').value;
    
    // Obter elemento para exibir o relatório
    const reportBody = document.getElementById('reportBody');
    const reportTitle = document.getElementById('reportTitle');
    
    if (!reportBody || !reportTitle) {
        mostrarMensagem('Elementos de relatório não encontrados.', 'error');
        return;
    }
    
    // Mostrar indicador de carregamento
    mostrarCarregamento(true);
    
    try {
        let conteudoRelatorio = '';
        let tituloRelatorio = '';
        
        // Gerar conteúdo do relatório conforme o tipo
        switch (tipoRelatorio) {
            case 'execucao_orcamentaria':
                tituloRelatorio = 'Relatório de Execução Orçamentária';
                conteudoRelatorio = gerarRelatorioExecucaoOrcamentaria();
                break;
            case 'natureza_despesa':
                tituloRelatorio = 'Relatório por Natureza de Despesa';
                conteudoRelatorio = gerarRelatorioPorNatureza();
                break;
            case 'credores':
                tituloRelatorio = 'Relatório por Credor';
                conteudoRelatorio = gerarRelatorioPorCredor();
                break;
            case 'execucao_mensal':
                tituloRelatorio = 'Relatório de Execução Mensal';
                conteudoRelatorio = gerarRelatorioExecucaoMensal();
                break;
            case 'liquidacoes_pagamentos':
                tituloRelatorio = 'Relatório de Liquidações e Pagamentos';
                conteudoRelatorio = gerarRelatorioLiquidacoesPagamentos();
                break;
            // Verificar se é um tipo de relatório contábil
            case 'contabil_orcamentario':
            case 'contabil_financeiro':
            case 'contabil_natureza':
            case 'contabil_comparativo':
                return gerarRelatorioContabilDoPadrao(tipoRelatorio);
            default:
                tituloRelatorio = 'Relatório Genérico';
                conteudoRelatorio = 'Tipo de relatório não reconhecido.';
        }
        
        // Atualizar o título e o corpo do relatório
        reportTitle.textContent = tituloRelatorio;
        reportBody.innerHTML = conteudoRelatorio;
        
        // Exibir seção de relatório
        mostrarSecao('report');
        
        // Renderizar gráficos do relatório se necessário
        if (typeof renderizarGraficosRelatorio === 'function') {
            setTimeout(() => renderizarGraficosRelatorio(tipoRelatorio), 100);
        }
    } catch (error) {
        mostrarMensagem(`Erro ao gerar relatório: ${error.message}`, 'error');
        console.error('Erro ao gerar relatório:', error);
    } finally {
        // Esconder indicador de carregamento
        mostrarCarregamento(false);
    }
}

/**
 * Gera um relatório contábil a partir do seletor padrão
 */
function gerarRelatorioContabilDoPadrao(tipoRelatorioPadrao) {
    // Mapear tipo do relatório padrão para tipo contábil
    let tipoRelatorioContabil;
    
    switch (tipoRelatorioPadrao) {
        case 'contabil_orcamentario':
            tipoRelatorioContabil = 'execucao_orcamentaria';
            break;
        case 'contabil_financeiro':
            tipoRelatorioContabil = 'pagamentos_realizados';
            break;
        case 'contabil_natureza':
            tipoRelatorioContabil = 'execucao_por_natureza';
            break;
        case 'contabil_comparativo':
            tipoRelatorioContabil = 'comparativo_planejado_executado';
            break;
        default:
            tipoRelatorioContabil = 'execucao_orcamentaria';
    }
    
    // Obter exercício atual ou usar padrão
    const exercicioAtual = new Date().getFullYear();
    
    // Gerar relatório contábil
    const htmlRelatorio = gerarRelatorioContabil(tipoRelatorioContabil);
    
    // Atualizar título e corpo do relatório
    const reportTitle = document.getElementById('reportTitle');
    const reportBody = document.getElementById('reportBody');
    
    if (reportTitle) {
        const tiposRelatorio = {
            'contabil_orcamentario': 'Relatório Orçamentário Contábil',
            'contabil_financeiro': 'Relatório Financeiro Detalhado',
            'contabil_natureza': 'Análise por Natureza de Despesa',
            'contabil_comparativo': 'Comparativo Planejado vs. Executado'
        };
        
        reportTitle.textContent = tiposRelatorio[tipoRelatorioPadrao] || 'Relatório Contábil';
    }
    
    if (reportBody) {
        reportBody.innerHTML = htmlRelatorio;
    }
    
    // Mostrar seção de relatório
    mostrarSecao('report');
    
    // Renderizar gráficos
    setTimeout(() => {
        renderizarGraficosContabeis(tipoRelatorioContabil);
    }, 100);
    
    // Esconder indicador de carregamento
    mostrarCarregamento(false);
}

/**
 * Função para manipular a geração de relatórios contábeis avançados
 */
function gerarRelatorioContabilHandler() {
    try {
        // Verificar se há dados
        if (!window.filteredData || window.filteredData.length === 0) {
            mostrarMensagem('Não há dados disponíveis para gerar o relatório contábil.', 'warning');
            return;
        }
        
        // Obter tipo de relatório e exercício
        const tipoRelatorio = document.getElementById('tipoRelatorioContabil')?.value || 'execucao_orcamentaria';
        const exercicio = document.getElementById('exercicioRelatorioContabil')?.value || new Date().getFullYear().toString();
        
        // Gerar relatório
        const htmlRelatorio = gerarRelatorioContabil(tipoRelatorio);
        
        // Atualizar título e corpo do relatório
        const relatorioTitle = document.getElementById('relatorioContabilTitle');
        const relatorioBody = document.getElementById('relatorioContabilBody');
        
        if (relatorioTitle) {
            // Formatar título
            let tituloFormatado;
            
            switch (tipoRelatorio) {
                case 'execucao_orcamentaria':
                    tituloFormatado = `Relatório de Execução Orçamentária - ${exercicio}`;
                    break;
                case 'execucao_por_natureza':
                    tituloFormatado = `Execução por Natureza de Despesa - ${exercicio}`;
                    break;
                case 'comparativo_planejado_executado':
                    tituloFormatado = `Comparativo Planejado x Executado - ${exercicio}`;
                    break;
                case 'financeiro_liquidacao':
                    tituloFormatado = `Relatório Financeiro de Liquidação - ${exercicio}`;
                    break;
                case 'pagamentos_realizados':
                    tituloFormatado = `Relatório de Pagamentos Realizados - ${exercicio}`;
                    break;
                case 'restos_pagar':
                    tituloFormatado = `Relatório de Restos a Pagar - ${exercicio}`;
                    break;
                case 'execucao_detalhada_credor':
                    tituloFormatado = `Execução Detalhada por Credor - ${exercicio}`;
                    break;
                case 'indicadores_desempenho':
                    tituloFormatado = `Indicadores de Desempenho Orçamentário - ${exercicio}`;
                    break;
                default:
                    tituloFormatado = `Relatório Contábil - ${exercicio}`;
            }
            
            relatorioTitle.textContent = tituloFormatado;
        }
        
        if (relatorioBody) {
            relatorioBody.innerHTML = htmlRelatorio;
        }
        
        // Renderizar gráficos
        setTimeout(() => {
            renderizarGraficosContabeis(tipoRelatorio);
        }, 100);
        
        mostrarMensagem(`Relatório contábil gerado com sucesso!`, 'success');
    } catch (error) {
        mostrarMensagem(`Erro ao gerar relatório contábil: ${error.message}`, 'error');
        console.error("Erro ao gerar relatório contábil:", error);
    }
}

/**
 * Configura ferramentas adicionais como auditoria
 */
function configurarFerramentasAdicionais() {
    // Configurar ferramenta de auditoria
    const btnIniciarAuditoria = document.getElementById('iniciarAuditoriaBtn');
    if (btnIniciarAuditoria) {
        btnIniciarAuditoria.addEventListener('click', iniciarAuditoria);
    }
}

/**
 * Inicia o processo de auditoria dos dados
 */
function iniciarAuditoria() {
    // Verificar se há dados
    if (!window.filteredData || window.filteredData.length === 0) {
        mostrarMensagem('Não há dados disponíveis para realizar a auditoria.', 'warning');
        return;
    }
    
    // Mostrar indicador de carregamento
    mostrarCarregamento(true);
    
    try {
        // Realizar a auditoria dos dados
        const resultadoAuditoria = auditarDadosContabeis(window.filteredData);
        
        // Gerar relatório de auditoria
        const relatorioHTML = gerarRelatorioAuditoria(resultadoAuditoria);
        
        // Exibir o relatório
        const resultadoAuditoriaDiv = document.getElementById('resultadoAuditoria');
        if (resultadoAuditoriaDiv) {
            resultadoAuditoriaDiv.innerHTML = relatorioHTML;
        }
        
        // Mostrar mensagem de sucesso
        mostrarMensagem('Auditoria concluída com sucesso!', 'success');
    } catch (error) {
        mostrarMensagem(`Erro ao realizar auditoria: ${error.message}`, 'error');
        console.error('Erro na auditoria:', error);
    } finally {
        // Esconder indicador de carregamento
        mostrarCarregamento(false);
    }
}

/**
 * Função para mostrar indicador de carregamento
 */
function mostrarCarregamento(mostrar) {
    const loader = document.getElementById('loader');
    if (loader) {
        loader.style.display = mostrar ? 'flex' : 'none';
    }
}

/**
 * Função para mostrar mensagens de feedback ao usuário
 */
function mostrarMensagem(mensagem, tipo) {
    // Verificar container de mensagens
    const container = document.getElementById('mensagens');
    if (!container) return;
    
    // Criar elemento de mensagem
    const mensagemDiv = document.createElement('div');
    mensagemDiv.className = `alert alert-${tipo === 'error' ? 'danger' : tipo}`;
    mensagemDiv.role = 'alert';
    
    // Adicionar ícone conforme o tipo
    let icone = '';
    switch (tipo) {
        case 'success':
            icone = '<i class="fas fa-check-circle"></i> ';
            break;
        case 'warning':
            icone = '<i class="fas fa-exclamation-triangle"></i> ';
            break;
        case 'error':
        case 'danger':
            icone = '<i class="fas fa-times-circle"></i> ';
            break;
        case 'info':
            icone = '<i class="fas fa-info-circle"></i> ';
            break;
    }
    
    mensagemDiv.innerHTML = `${icone}${mensagem}`;
    
    // Adicionar botão para fechar
    const btnFechar = document.createElement('button');
    btnFechar.type = 'button';
    btnFechar.className = 'close';
    btnFechar.setAttribute('aria-label', 'Fechar');
    btnFechar.innerHTML = '<span aria-hidden="true">&times;</span>';
    btnFechar.onclick = function() {
        mensagemDiv.remove();
    };
    
    mensagemDiv.appendChild(btnFechar);
    
    // Adicionar ao container
    container.appendChild(mensagemDiv);
    
    // Remover automaticamente após 5 segundos
    setTimeout(() => {
        if (mensagemDiv.parentNode === container) {
            container.removeChild(mensagemDiv);
        }
    }, 5000);
}

/**
 * Função auxiliar para log de depuração
 */
function logDebug(mensagem) {
    if (window.debugMode) {
        console.log(`[DEBUG] ${mensagem}`);
    }
}

// Inicializar o sistema quando o documento estiver pronto
document.addEventListener('DOMContentLoaded', inicializarSistema);
</script>
</body>
</html>